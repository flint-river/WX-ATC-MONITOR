<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Airport Weather & ATC Monitor</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            padding: 8px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 4px;
            padding-bottom: 4px;
            border-bottom: 1px solid #333;
        }
        
        h1 {
            font-size: 17px;
            margin-bottom: 2px;
            color: #fff;
        }
        
        .subtitle {
            color: #4a90d9;
            font-size: 10px;
            margin-bottom: 1px;
        }
        
        .timestamp {
            color: #888;
            font-size: 10px;
        }
        
        .timezone-box {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 4px;
            margin: 4px 0;
            padding: 4px 6px;
            background: #252540;
            border-radius: 5px;
        }
        
        .tz-item {
            text-align: center;
            padding: 1px 8px;
            min-width: 55px;
        }
        
        .tz-item .tz-time {
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: bold;
            color: #fff;
        }
        
        .tz-item .tz-date {
            font-size: 9px;
            color: #888;
            margin-top: 1px;
        }
        
        .tz-item .tz-label {
            font-size: 9px;
            color: #888;
            text-transform: uppercase;
            margin-top: 0px;
        }
        
        .tz-item.zulu .tz-time {
            color: #4a90d9;
        }
        
        .tz-item.zulu .tz-date {
            color: #4a90d9;
        }
        
        .tz-item.zulu .tz-label {
            color: #4a90d9;
        }
        
        .tz-item.local .tz-time {
            color: #2ecc71;
        }
        
        .tz-item.local .tz-date {
            color: #2ecc71;
        }
        
        .tz-item.local .tz-label {
            color: #2ecc71;
        }
        
        .tz-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 22px;
            height: 22px;
            background: #1a1a2e;
            border: 1px solid #444;
            border-radius: 50%;
            color: #888;
            font-size: 14px;
            cursor: pointer;
            align-self: center;
            transition: all 0.2s;
        }
        
        .tz-toggle:hover {
            background: #333;
            color: #fff;
            border-color: #666;
        }
        
        .tz-toggle.expanded {
            transform: rotate(45deg);
        }
        
        .timezone-box-expanded {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 6px;
            margin: 0 0 8px 0;
            padding: 6px;
            background: #1a1a2e;
            border: 1px solid #333;
            border-radius: 0 0 6px 6px;
            margin-top: -6px;
        }
        
        .timezone-box-expanded .tz-item .tz-time {
            font-size: 18px;
        }
        
        .timezone-box-expanded .tz-item .tz-date {
            font-size: 10px;
            color: #888;
        }
        
        .timezone-box-expanded .tz-item .tz-label {
            font-size: 9px;
        }
        
        /* Weather Map Styles */
        .weather-map-container {
            margin: 6px 0;
            background: #1a1a2e;
            border-radius: 6px;
            overflow: hidden;
        }
        
        .weather-map-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: #252540;
            cursor: pointer;
        }
        
        .weather-map-header h3 {
            margin: 0;
            font-size: 12px;
            color: #4a90d9;
        }
        
        .weather-map-toggle {
            color: #888;
            font-size: 11px;
        }
        
        .weather-map-content {
            padding: 8px;
            display: none;
        }
        
        .weather-map-content.active {
            display: block;
        }
        
        .weather-map-svg {
            width: 100%;
            height: auto;
            max-height: 380px;
        }
        
        .weather-map-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 6px 10px;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
            font-size: 10px;
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
        }
        
        .legend-title {
            font-weight: bold;
            color: #f39c12;
            width: 100%;
            text-align: center;
            margin-bottom: 4px;
            font-size: 11px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.5);
        }
        
        .controls {
            display: flex;
            gap: 6px;
            justify-content: center;
            margin-bottom: 4px;
            flex-wrap: wrap;
        }
        
        .search-box {
            display: flex;
            gap: 4px;
            width: 100%;
            max-width: 380px;
            margin-bottom: 2px;
        }
        
        .search-box input {
            flex: 1;
            background: #252540;
            color: #fff;
            border: 1px solid #444;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .search-box input::placeholder {
            color: #666;
        }
        
        .search-box button {
            padding: 6px 10px;
            font-size: 12px;
        }
        
        .filter-buttons {
            display: flex;
            gap: 2px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 3px;
        }
        
        .filter-btn {
            background: #252540;
            color: #888;
            border: 1px solid #444;
            padding: 4px 7px;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
        }
        
        .filter-btn.active {
            background: #4a90d9;
            color: white;
            border-color: #4a90d9;
        }
        
        .filter-btn:hover {
            border-color: #666;
        }
        
        .wind-threshold-box {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            margin-bottom: 4px;
            font-size: 9px;
            color: #888;
        }
        
        .wind-threshold-box input {
            width: 38px;
            background: #252540;
            color: #e67e22;
            border: 1px solid #444;
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 11px;
            text-align: center;
        }
        
        .wind-threshold-box input:focus {
            outline: none;
            border-color: #e67e22;
        }
        
        .section-controls {
            display: flex;
            gap: 4px;
            justify-content: center;
            margin-bottom: 3px;
        }
        
        .quick-actions {
            display: flex;
            gap: 6px;
            margin-bottom: 4px;
        }
        
        .quick-actions button {
            background: #2a2a4a;
            border: 2px solid #444;
            color: #fff;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            transition: all 0.2s;
        }
        
        .quick-actions button:hover {
            background: #3a3a5a;
            border-color: #666;
        }
        
        .quick-actions .datis-btn {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            border-color: #f39c12;
            color: #000;
        }
        
        .quick-actions .datis-btn:hover {
            background: linear-gradient(135deg, #e67e22, #d35400);
        }
        
        .quick-actions .notams-btn {
            background: linear-gradient(135deg, #3498db, #2980b9);
            border-color: #3498db;
        }
        
        .quick-actions .notams-btn:hover {
            background: linear-gradient(135deg, #2980b9, #1a5276);
        }
        
        .section-controls button {
            background: #2a2a4a;
            border: 1px solid #444;
            color: #888;
            padding: 3px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 9px;
        }
        
        .section-controls button:hover {
            background: #3a3a5a;
            color: #fff;
        }
        
        button {
            background: #4a90d9;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            touch-action: manipulation;
        }
        
        button:disabled {
            background: #555;
        }
        
        .auto-refresh {
            display: flex;
            align-items: center;
            gap: 4px;
            color: #888;
            font-size: 11px;
        }
        
        .auto-refresh select {
            background: #252540;
            color: #fff;
            border: 1px solid #444;
            padding: 8px;
            border-radius: 5px;
            font-size: 13px;
        }
        
        .summary {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
            margin-bottom: 12px;
        }
        
        .summary-card {
            background: #252540;
            padding: 5px 6px;
            border-radius: 5px;
            text-align: center;
        }
        
        .summary-card .count {
            font-size: 22px;
            font-weight: bold;
            margin-bottom: 0px;
        }
        
        .summary-card .label {
            font-size: 9px;
            color: #888;
            text-transform: uppercase;
        }
        
        .summary-card:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
        }
        
        .summary-card.active { border-left: 4px solid #e74c3c; }
        .summary-card.active .count { color: #e74c3c; }
        
        .summary-card.likely { border-left: 4px solid #f39c12; }
        .summary-card.likely .count { color: #f39c12; }
        
        .summary-card.possible { border-left: 4px solid #f1c40f; }
        .summary-card.possible .count { color: #f1c40f; }
        
        .summary-card.none { border-left: 4px solid #2ecc71; }
        .summary-card.none .count { color: #2ecc71; }
        
        .summary-card.residual { border-left: 4px solid #9b59b6; }
        .summary-card.residual .count { color: #9b59b6; }
        
        .summary-card.atc { border-left: 4px solid #e74c3c; }
        .summary-card.atc .count { color: #e74c3c; }
        
        .summary-card.arr-dep-delay { border-left: 4px solid #e67e22; }
        .summary-card.arr-dep-delay .count { color: #e67e22; }
        
        .summary-card.taf-warn { border-left: 4px solid #9b59b6; }
        .summary-card.taf-warn .count { color: #9b59b6; }
        
        .summary-card.precip { border-left: 4px solid #3498db; }
        .summary-card.precip .count { color: #3498db; }
        
        .summary-card.frost { border-left: 4px solid #3498db; }
        .summary-card.frost .count { color: #3498db; }
        
        .summary-card.closure { border-left: 4px solid #8b4513; }
        .summary-card.closure .count { color: #cd853f; }
        
        .summary-card.planned { border-left: 4px solid #2e8b8b; }
        .summary-card.planned .count { color: #3ce7e7; }
        
        .summary-card.lifr { border-left: 4px solid #9b59b6; }
        .summary-card.lifr .count { color: #9b59b6; }
        
        .summary-card.taf-lifr { border-left: 4px solid #8e44ad; }
        .summary-card.taf-lifr .count { color: #8e44ad; }
        
        .summary-card.high-wind { border-left: 4px solid #e67e22; }
        .summary-card.high-wind .count { color: #e67e22; }
        
        .summary-card.tstorm { border-left: 4px solid #9b59b6; }
        .summary-card.tstorm .count { color: #9b59b6; }
        
        .summary-card.taf-tstorm { border-left: 4px solid #8e44ad; }
        .summary-card.taf-tstorm .count { color: #8e44ad; }
        
        .summary-card.taf-wind { border-left: 4px solid #d35400; }
        .summary-card.taf-wind .count { color: #d35400; }
        
        /* AFP, VIP, Rocket, Staffing cards */
        .summary-card.afp { border-left: 4px solid #9b59b6; }
        .summary-card.afp .count { color: #9b59b6; }
        
        .summary-card.vip { border-left: 4px solid #c0392b; }
        .summary-card.vip .count { color: #c0392b; }
        
        .summary-card.rocket { border-left: 4px solid #e67e22; }
        .summary-card.rocket .count { color: #e67e22; }
        
        .summary-card.staffing { border-left: 4px solid #3498db; }
        .summary-card.staffing .count { color: #3498db; }
        
        /* Temperature alert cards */
        .summary-card.temp-freezing { border-left: 4px solid #00bfff; }
        .summary-card.temp-freezing .count { color: #00bfff; }
        
        .summary-card.temp-approach { border-left: 4px solid #5dade2; }
        .summary-card.temp-approach .count { color: #5dade2; }
        
        .summary-card.temp-normal { border-left: 4px solid #27ae60; }
        .summary-card.temp-normal .count { color: #27ae60; }
        
        .summary-card.temp-hot { border-left: 4px solid #e74c3c; }
        .summary-card.temp-hot .count { color: #e74c3c; }
        
        .summary-card.taf-temp-freezing { border-left: 4px solid #0099cc; }
        .summary-card.taf-temp-freezing .count { color: #0099cc; }
        
        .summary-card.taf-temp-approach { border-left: 4px solid #4a9fd4; }
        .summary-card.taf-temp-approach .count { color: #4a9fd4; }
        
        .summary-card.taf-temp-normal { border-left: 4px solid #1e8449; }
        .summary-card.taf-temp-normal .count { color: #1e8449; }
        
        .summary-card.taf-temp-hot { border-left: 4px solid #c0392b; }
        .summary-card.taf-temp-hot .count { color: #c0392b; }
        
        .summary-card.disabled {
            opacity: 0.4;
            cursor: default;
        }
        
        .summary-card.disabled:hover {
            transform: none;
            box-shadow: none;
        }
        
        .summary-card.hub-affected {
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.7);
            border: 2px solid #e74c3c;
        }
        
        .hub-legend {
            text-align: center;
            font-size: 9px;
            color: #888;
            margin-bottom: 4px;
            padding: 3px 6px;
            background: rgba(231, 76, 60, 0.1);
            border-radius: 3px;
            border: 1px dashed #e74c3c;
        }
        
        .hub-legend-symbol {
            color: #e74c3c;
            font-weight: bold;
            font-size: 12px;
        }
        
        .summary-dashboard {
            margin-bottom: 6px;
        }
        
        .summary-row {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 3px;
            margin-bottom: 3px;
        }
        
        @media (max-width: 600px) {
            .summary-row {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        .summary-card {
            cursor: pointer;
        }
        
        .section {
            margin-bottom: 15px;
        }
        
        .section-header {
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px solid #333;
        }
        
        .section-header h2 {
            font-size: 14px;
            font-weight: 600;
        }
        
        .airport-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .airport-card {
            background: #252540;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
            text-decoration: none;
            color: inherit;
            display: block;
        }
        
        .airport-card:hover {
            background: #333355;
        }
        
        .airport-main {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .airport-card .left {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .airport-card .icao {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 14px;
            background: #1a1a2e;
            padding: 6px 8px;
            border-radius: 4px;
        }
        
        .airport-card .name {
            font-weight: 500;
            font-size: 14px;
        }
        
        .airport-card .name a {
            color: #7db8eb;
            text-decoration: none;
        }
        
        .airport-card .name a:hover {
            text-decoration: underline;
        }
        
        .airport-card .notam-link {
            margin-left: 8px;
            font-size: 14px;
            opacity: 0.6;
            text-decoration: none;
        }
        
        .airport-card .notam-link:hover {
            opacity: 1;
            text-decoration: none;
        }
        
        .airport-card .weather {
            font-size: 11px;
            color: #888;
            margin-top: 2px;
        }
        
        .airport-card .right {
            text-align: right;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .airport-card .temp {
            text-align: right;
        }
        
        .airport-card .temp-value {
            font-size: 18px;
            font-weight: bold;
        }
        
        .airport-card .temp-f {
            font-size: 11px;
            color: #888;
        }
        
        .trend {
            font-size: 20px;
            font-weight: bold;
        }
        
        .trend.warming { color: #e74c3c; }
        .trend.cooling { color: #3498db; }
        .trend.steady { color: #888; }
        
        .obs-time {
            font-size: 10px;
            color: #888;
            margin-top: 4px;
        }
        
        .obs-time.stale {
            color: #e74c3c;
        }
        
        .flight-rules {
            font-size: 9px;
            padding: 2px 5px;
            border-radius: 3px;
            display: inline-block;
            margin-top: 3px;
        }
        
        .fr-vfr { background: #2ecc71; color: #000; }
        .fr-mvfr { background: #3498db; color: #fff; }
        .fr-ifr { background: #e74c3c; color: #fff; }
        .fr-lifr { background: #9b59b6; color: #fff; }
        
        .history {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #333;
            display: none;
        }
        
        .history.show {
            display: block;
        }
        
        .history-title {
            font-size: 11px;
            color: #888;
            margin-bottom: 8px;
            text-transform: uppercase;
        }
        
        .history-header {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            padding: 2px 0 4px 0;
            border-bottom: 1px solid #333;
            margin-bottom: 4px;
            gap: 6px;
            color: #666;
            text-transform: uppercase;
        }
        
        .history-header span {
            flex-shrink: 0;
        }
        
        .history-header .time { min-width: 135px; }
        .history-header .ceiling { min-width: 50px; }
        .history-header .wx { flex: 1; min-width: 50px; }
        .history-header .wind { min-width: 55px; }
        .history-header .temp { min-width: 85px; text-align: right; }
        
        .history-row {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            padding: 4px 0;
            border-bottom: 1px solid #1a1a2e;
            gap: 6px;
        }
        
        .history-row .time {
            color: #888;
            min-width: 135px;
            flex-shrink: 0;
            font-size: 10px;
        }
        
        .history-row .ceiling {
            color: #4a90d9;
            min-width: 50px;
            flex-shrink: 0;
        }
        
        .history-row .wx {
            color: #aaa;
            flex: 1;
            min-width: 50px;
        }
        
        .history-row .wind {
            color: #3498db;
            min-width: 55px;
            flex-shrink: 0;
        }
        
        .history-row .temp {
            font-weight: bold;
            min-width: 85px;
            text-align: right;
            flex-shrink: 0;
        }
        
        .loading, .error {
            text-align: center;
            padding: 40px 20px;
        }
        
        .loading .spinner {
            width: 36px;
            height: 36px;
            border: 3px solid #333;
            border-top-color: #4a90d9;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .error {
            background: #3d1f1f;
            border-radius: 8px;
            color: #ff6b6b;
        }
        
        .error button {
            margin-top: 15px;
            background: #c0392b;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            padding-top: 15px;
            border-top: 1px solid #333;
            color: #555;
            font-size: 11px;
        }
        
        .status-msg {
            text-align: center;
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 6px;
            font-size: 13px;
        }
        
        .status-msg.info { background: #1a3a5c; color: #7db8eb; }

        .expand-hint {
            font-size: 10px;
            color: #666;
            margin-top: 4px;
        }
        
        .residual-badge {
            background: #9b59b6;
            color: white;
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 8px;
            display: inline-block;
        }
        
        .recent-frozen-note {
            font-size: 10px;
            color: #9b59b6;
            margin-top: 3px;
        }
        
        .badges {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 4px;
        }
        
        .badge {
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            display: inline-block;
        }
        
        .badge-hub {
            background: #2c3e50;
            color: #bdc3c7;
        }
        
        .badge-rush {
            background: #d35400;
            color: white;
        }
        
        .badge-gdp {
            background: #c0392b;
            color: white;
            animation: pulse 2s infinite;
        }
        
        .badge-gs {
            background: #8e44ad;
            color: white;
            animation: pulse 1.5s infinite;
        }
        
        .badge-delay {
            background: #e67e22;
            color: white;
        }
        
        .badge-constraint {
            background: #b8860b;
            color: white;
        }
        
        .badge-closure {
            background: #8b4513;
            color: white;
        }
        
        .badge-planned {
            background: #2e8b8b;
            color: white;
        }
        
        .badge-deicing {
            background: #1e90ff;
            color: white;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .traffic-section {
            background: #2d1f1f;
            border: 1px solid #5c3a3a;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 20px;
        }
        
        .traffic-section h3 {
            font-size: 14px;
            color: #e74c3c;
            margin-bottom: 10px;
        }
        
        /* Collapsible section styles */
        .collapsible-section {
            margin-bottom: 15px;
        }
        
        .collapsible-section.collapsed {
            display: none;
        }
        
        .section-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            border-radius: 8px 8px 0 0;
            user-select: none;
        }
        
        .section-header:hover {
            filter: brightness(1.1);
        }
        
        .section-header h3 {
            margin: 0;
            font-size: 14px;
        }
        
        .section-toggle {
            font-size: 12px;
            opacity: 0.7;
        }
        
        .section-content {
            padding: 10px 12px;
            border-radius: 0 0 8px 8px;
        }
        
        .section-content.collapsed {
            display: none;
        }
        
        /* Section color themes */
        .section-traffic .section-header { background: #2d1f1f; border: 1px solid #5c3a3a; border-bottom: none; }
        .section-traffic .section-header h3 { color: #e74c3c; }
        .section-traffic .section-content { background: #2d1f1f; border: 1px solid #5c3a3a; border-top: none; }
        
        .section-arr-dep .section-header { background: #3d2a1f; border: 1px solid #e67e22; border-bottom: none; }
        .section-arr-dep .section-header h3 { color: #e67e22; }
        .section-arr-dep .section-content { background: #2d1f1a; border: 1px solid #e67e22; border-top: none; }
        
        .section-precip .section-header { background: #1f2a3d; border: 1px solid #3498db; border-bottom: none; }
        .section-precip .section-header h3 { color: #3498db; }
        .section-precip .section-content { background: #1a2535; border: 1px solid #3498db; border-top: none; }
        
        .section-deicing .section-header { background: #1f2d3d; border: 1px solid #3a68a0; border-bottom: none; }
        .section-deicing .section-header h3 { color: #1e90ff; }
        .section-deicing .section-content { background: #1f2d3d; border: 1px solid #3a68a0; border-top: none; }
        
        .section-constraint .section-header { background: #2d2d1f; border: 1px solid #5c5c3a; border-bottom: none; }
        .section-constraint .section-header h3 { color: #e7c43c; }
        .section-constraint .section-content { background: #2d2d1f; border: 1px solid #5c5c3a; border-top: none; }
        
        .section-planned .section-header { background: #1f2d2d; border: 1px solid #3a5c5c; border-bottom: none; }
        .section-planned .section-header h3 { color: #3ce7e7; }
        .section-planned .section-content { background: #1f2d2d; border: 1px solid #3a5c5c; border-top: none; }
        
        .section-closure .section-header { background: #2d251f; border: 1px solid #5c4a3a; border-bottom: none; }
        .section-closure .section-header h3 { color: #e79c3c; }
        .section-closure .section-content { background: #2d251f; border: 1px solid #5c4a3a; border-top: none; }
        
        .section-afp .section-header { background: #2d1f3d; border: 1px solid #9b59b6; border-bottom: none; }
        .section-afp .section-header h3 { color: #9b59b6; }
        .section-afp .section-content { background: #251a2d; border: 1px solid #9b59b6; border-top: none; }
        
        .section-vip .section-header { background: #3d1f1f; border: 1px solid #c0392b; border-bottom: none; }
        .section-vip .section-header h3 { color: #e74c3c; }
        .section-vip .section-content { background: #2d1a1a; border: 1px solid #c0392b; border-top: none; }
        
        .section-rocket .section-header { background: #3d2d1f; border: 1px solid #e67e22; border-bottom: none; }
        .section-rocket .section-header h3 { color: #e67e22; }
        .section-rocket .section-content { background: #2d251a; border: 1px solid #e67e22; border-top: none; }
        
        .section-staffing .section-header { background: #1f2d3d; border: 1px solid #3498db; border-bottom: none; }
        .section-staffing .section-header h3 { color: #3498db; }
        .section-staffing .section-content { background: #1a252d; border: 1px solid #3498db; border-top: none; }
        
        .section-runway .section-header { background: #2d2d1f; border: 1px solid #8b6914; border-bottom: none; }
        .section-runway .section-header h3 { color: #ffa500; }
        .section-runway .section-content { background: #2d2d1f; border: 1px solid #8b6914; border-top: none; }
        
        .section-taf .section-header { background: #1f2d3d; border: 1px solid #3a5068; border-bottom: none; }
        .section-taf .section-header h3 { color: #4a90d9; }
        .section-taf .section-content { background: #1f2d3d; border: 1px solid #3a5068; border-top: none; }
        
        /* Deicing category section styles */
        .section-deice-active .section-header { background: #3d1f1f; border: 1px solid #e74c3c; border-bottom: none; }
        .section-deice-active .section-header h3 { color: #e74c3c; }
        .section-deice-active .section-content { background: #2d1a1a; border: 1px solid #e74c3c; border-top: none; }
        
        .section-deice-residual .section-header { background: #2d1f3d; border: 1px solid #9b59b6; border-bottom: none; }
        .section-deice-residual .section-header h3 { color: #9b59b6; }
        .section-deice-residual .section-content { background: #251a2d; border: 1px solid #9b59b6; border-top: none; }
        
        .section-deice-likely .section-header { background: #3d2d1f; border: 1px solid #f39c12; border-bottom: none; }
        .section-deice-likely .section-header h3 { color: #f39c12; }
        .section-deice-likely .section-content { background: #2d251a; border: 1px solid #f39c12; border-top: none; }
        
        .section-deice-possible .section-header { background: #3d3d1f; border: 1px solid #f1c40f; border-bottom: none; }
        .section-deice-possible .section-header h3 { color: #f1c40f; }
        .section-deice-possible .section-content { background: #2d2d1a; border: 1px solid #f1c40f; border-top: none; }
        
        .section-lifr .section-header { background: #2d1f3d; border: 1px solid #9b59b6; border-bottom: none; }
        .section-lifr .section-header h3 { color: #9b59b6; }
        .section-lifr .section-content { background: #251a2d; border: 1px solid #9b59b6; border-top: none; }
        
        .section-taf-lifr .section-header { background: #3d1f4d; border: 1px solid #8e44ad; border-bottom: none; }
        .section-taf-lifr .section-header h3 { color: #8e44ad; }
        .section-taf-lifr .section-content { background: #2d1a3d; border: 1px solid #8e44ad; border-top: none; }
        
        .section-ifr .section-header { background: #3d1f1f; border: 1px solid #e74c3c; border-bottom: none; }
        .section-ifr .section-header h3 { color: #e74c3c; }
        .section-ifr .section-content { background: #2d1a1a; border: 1px solid #e74c3c; border-top: none; }
        
        .section-taf-ifr .section-header { background: #3d2525; border: 1px solid #c0392b; border-bottom: none; }
        .section-taf-ifr .section-header h3 { color: #c0392b; }
        .section-taf-ifr .section-content { background: #2d1f1f; border: 1px solid #c0392b; border-top: none; }
        
        .section-high-wind .section-header { background: #3d2a1f; border: 1px solid #e67e22; border-bottom: none; }
        .section-high-wind .section-header h3 { color: #e67e22; }
        .section-high-wind .section-content { background: #2d1f1a; border: 1px solid #e67e22; border-top: none; }
        
        .wind-columns {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
        }
        
        .wind-column {
            min-width: 0;
        }
        
        .wind-column-header {
            font-size: 10px;
            font-weight: bold;
            color: #e67e22;
            padding: 4px 8px;
            background: rgba(230, 126, 34, 0.15);
            border-radius: 4px;
            margin-bottom: 6px;
            text-align: center;
        }
        
        .temp-columns {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
        }
        
        .temp-column {
            min-width: 0;
        }
        
        .temp-column-header {
            font-size: 10px;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
            margin-bottom: 6px;
            text-align: center;
        }
        
        .temp-column-header.freezing {
            color: #00bfff;
            background: rgba(0, 191, 255, 0.15);
        }
        
        .temp-column-header.approach {
            color: #5dade2;
            background: rgba(93, 173, 226, 0.15);
        }
        
        .temp-column-header.normal {
            color: #27ae60;
            background: rgba(39, 174, 96, 0.15);
        }
        
        .temp-column-header.hot {
            color: #e74c3c;
            background: rgba(231, 76, 60, 0.15);
        }
        
        @media (max-width: 600px) {
            .wind-columns {
                grid-template-columns: 1fr;
            }
            .temp-columns {
                grid-template-columns: 1fr;
            }
        }
        
        .section-tstorm .section-header { background: #2d1f3d; border: 1px solid #9b59b6; border-bottom: none; }
        .section-tstorm .section-header h3 { color: #9b59b6; }
        .section-tstorm .section-content { background: #251a2d; border: 1px solid #9b59b6; border-top: none; }
        
        .section-taf-tstorm .section-header { background: #251a2d; border: 1px solid #8e44ad; border-bottom: none; }
        .section-taf-tstorm .section-header h3 { color: #8e44ad; }
        .section-taf-tstorm .section-content { background: #1f1525; border: 1px solid #8e44ad; border-top: none; }
        
        .section-taf-wind .section-header { background: #3d2510; border: 1px solid #d35400; border-bottom: none; }
        .section-taf-wind .section-header h3 { color: #d35400; }
        .section-taf-wind .section-content { background: #2d1a0a; border: 1px solid #d35400; border-top: none; }
        
        .section-deice-none .section-header { background: #1f3d1f; border: 1px solid #2ecc71; border-bottom: none; }
        .section-deice-none .section-header h3 { color: #2ecc71; }
        .section-deice-none .section-content { background: #1a2d1a; border: 1px solid #2ecc71; border-top: none; }
        
        /* Temperature section styles */
        .section-temp-freezing .section-header { background: #1a2d3d; border: 1px solid #00bfff; border-bottom: none; }
        .section-temp-freezing .section-header h3 { color: #00bfff; }
        .section-temp-freezing .section-content { background: #152535; border: 1px solid #00bfff; border-top: none; }
        
        .section-temp-approach .section-header { background: #1a2a3a; border: 1px solid #5dade2; border-bottom: none; }
        .section-temp-approach .section-header h3 { color: #5dade2; }
        .section-temp-approach .section-content { background: #152230; border: 1px solid #5dade2; border-top: none; }
        
        .section-temp-normal .section-header { background: #1a3020; border: 1px solid #27ae60; border-bottom: none; }
        .section-temp-normal .section-header h3 { color: #27ae60; }
        .section-temp-normal .section-content { background: #15281a; border: 1px solid #27ae60; border-top: none; }
        
        .section-temp-hot .section-header { background: #3d1a1a; border: 1px solid #e74c3c; border-bottom: none; }
        .section-temp-hot .section-header h3 { color: #e74c3c; }
        .section-temp-hot .section-content { background: #351515; border: 1px solid #e74c3c; border-top: none; }
        
        .section-taf-temp-freezing .section-header { background: #152535; border: 1px solid #0099cc; border-bottom: none; }
        .section-taf-temp-freezing .section-header h3 { color: #0099cc; }
        .section-taf-temp-freezing .section-content { background: #101f2a; border: 1px solid #0099cc; border-top: none; }
        
        .section-taf-temp-approach .section-header { background: #152230; border: 1px solid #4a9fd4; border-bottom: none; }
        .section-taf-temp-approach .section-header h3 { color: #4a9fd4; }
        .section-taf-temp-approach .section-content { background: #101a25; border: 1px solid #4a9fd4; border-top: none; }
        
        .section-taf-temp-normal .section-header { background: #152515; border: 1px solid #1e8449; border-bottom: none; }
        .section-taf-temp-normal .section-header h3 { color: #1e8449; }
        .section-taf-temp-normal .section-content { background: #101f10; border: 1px solid #1e8449; border-top: none; }
        
        .section-taf-temp-hot .section-header { background: #351515; border: 1px solid #c0392b; border-bottom: none; }
        .section-taf-temp-hot .section-header h3 { color: #c0392b; }
        .section-taf-temp-hot .section-content { background: #2a1010; border: 1px solid #c0392b; border-top: none; }
        
        .temp-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            border-bottom: 1px solid #333;
            font-size: 12px;
        }
        
        .temp-item:last-child {
            border-bottom: none;
        }
        
        .temp-item .airport-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .temp-item .icao {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #fff;
        }
        
        .temp-item .name {
            color: #888;
        }
        
        .temp-item .temp-display {
            font-weight: bold;
            font-size: 14px;
        }
        
        .temp-item .trend-indicator {
            font-size: 14px;
            margin-left: 6px;
        }
        
        .traffic-item {
            font-size: 12px;
            padding: 6px 0;
            border-bottom: 1px solid #3d2a2a;
        }
        
        .traffic-item:last-child {
            border-bottom: none;
        }
        
        .traffic-item .airport {
            font-weight: bold;
            color: #fff;
        }
        
        .traffic-item .program {
            color: #e74c3c;
        }
        
        .traffic-item .reason {
            color: #888;
            font-size: 11px;
        }
        
        .constraint-section {
            background: #2d2d1f;
            border: 1px solid #5c5c3a;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .constraint-section h3 {
            font-size: 14px;
            color: #e7c43c;
            margin-bottom: 10px;
        }
        
        .constraint-item {
            font-size: 12px;
            padding: 6px 0;
            border-bottom: 1px solid #3d3d2a;
        }
        
        .constraint-item:last-child {
            border-bottom: none;
        }
        
        .constraint-item .airport {
            font-weight: bold;
            color: #fff;
        }
        
        .constraint-item .constraint-type {
            color: #e7c43c;
        }
        
        .planned-section {
            background: #1f2d2d;
            border: 1px solid #3a5c5c;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .planned-section h3 {
            font-size: 14px;
            color: #3ce7e7;
            margin-bottom: 10px;
        }
        
        .planned-item {
            font-size: 12px;
            padding: 6px 0;
            border-bottom: 1px solid #2a3d3d;
            color: #aaa;
        }
        
        .planned-item:last-child {
            border-bottom: none;
        }
        
        .planned-item .airport {
            font-weight: bold;
            color: #fff;
        }
        
        .closure-section {
            background: #2d251f;
            border: 1px solid #5c4a3a;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .closure-section h3 {
            font-size: 14px;
            color: #e79c3c;
            margin-bottom: 10px;
        }
        
        .closure-item {
            font-size: 12px;
            padding: 6px 0;
            border-bottom: 1px solid #3d352a;
            color: #aaa;
        }
        
        .closure-item:last-child {
            border-bottom: none;
        }
        
        .closure-item .airport {
            font-weight: bold;
            color: #fff;
        }
        
        .deicing-section {
            background: #1f2d3d;
            border: 1px solid #3a68a0;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .deicing-section h3 {
            font-size: 14px;
            color: #1e90ff;
            margin-bottom: 10px;
        }
        
        .deicing-item {
            font-size: 12px;
            padding: 6px 0;
            border-bottom: 1px solid #2a3d5d;
            color: #aaa;
        }
        
        .deicing-item:last-child {
            border-bottom: none;
        }
        
        .deicing-item .airport {
            font-weight: bold;
            color: #fff;
        }
        
        .forecast-section {
            background: #1f2d3d;
            border: 1px solid #3a5068;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .forecast-section h3 {
            font-size: 14px;
            color: #4a90d9;
            margin-bottom: 10px;
        }
        
        .forecast-section h3[onclick]:hover {
            color: #7db8eb;
        }
        
        .forecast-note {
            font-size: 11px;
            color: #7db8eb;
            padding: 6px 0;
            border-bottom: 1px solid #2a4058;
            cursor: pointer;
        }
        
        .forecast-note:hover {
            background: #1a3050;
        }
        
        .forecast-note:last-child {
            border-bottom: none;
        }
        
        .forecast-note .airport {
            font-weight: bold;
            color: #fff;
        }
        
        .forecast-note .time {
            color: #f39c12;
        }
        
        .forecast-note .taf-expand-icon {
            color: #4a90d9;
            font-size: 10px;
            margin-left: 8px;
        }
        
        .taf-full {
            display: none;
            background: #0d1f30;
            border: 1px solid #2a4058;
            border-radius: 4px;
            padding: 8px;
            margin-top: 6px;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            color: #aaa;
            white-space: pre-wrap;
            word-break: break-word;
            line-height: 1.4;
        }
        
        .taf-full.show {
            display: block;
        }
        
        .taf-inline {
            display: none;
            background: #1a2d40;
            border: 1px solid #2a4058;
            border-radius: 4px;
            padding: 4px 8px;
            margin-top: 4px;
            font-family: 'Courier New', monospace;
            font-size: 9px;
            color: #7db8eb;
            cursor: pointer;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .taf-inline.expanded {
            display: block;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .taf-inline:hover {
            background: #253d55;
        }
        
        .taf-inline.expanded {
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .badge-frost {
            background: #2980b9;
            color: white;
        }
        
        .badge-taf-sn {
            background: #8e44ad;
            color: white;
        }
        
        .wind-info {
            font-size: 11px;
            color: #3498db;
            margin-top: 2px;
        }
        
        .wind-info.gusty {
            color: #e67e22;
        }
        
        .wind-info.strong {
            color: #e74c3c;
        }
        
        .vis-info {
            font-size: 10px;
            color: #888;
        }
        
        .vis-info.low {
            color: #e74c3c;
        }
        
        .hot-estimate {
            font-size: 10px;
            color: #1abc9c;
            margin-top: 3px;
            padding: 3px 6px;
            background: #1a3d3d;
            border-radius: 4px;
            display: inline-block;
        }
        
        .hot-estimate.short {
            background: #3d2a1a;
            color: #e67e22;
        }
        
        .hot-estimate.expired {
            background: #3d1a1a;
            color: #e74c3c;
        }
        
        .runway-status {
            font-size: 10px;
            margin-top: 4px;
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .runway-status.good {
            background: #1a3d1a;
            color: #2ecc71;
        }
        
        .runway-status.limited {
            background: #3d3d1a;
            color: #f1c40f;
        }
        
        .runway-status.critical {
            background: #3d1a1a;
            color: #e74c3c;
            animation: pulse 2s infinite;
        }
        
        .braking-action {
            font-size: 9px;
            padding: 2px 5px;
            border-radius: 3px;
            margin-left: 4px;
        }
        
        .braking-good { background: #27ae60; color: white; }
        .braking-fair { background: #f39c12; color: black; }
        .braking-poor { background: #e67e22; color: white; }
        .braking-nil { background: #c0392b; color: white; }
        
        .notam-section {
            background: #2d2a1f;
            border: 1px solid #5c563a;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        
        .notam-section h3 {
            font-size: 14px;
            color: #f39c12;
            margin-bottom: 10px;
        }
        
        .notam-item {
            font-size: 11px;
            padding: 6px 0;
            border-bottom: 1px solid #3d3a2a;
        }
        
        .notam-item:last-child {
            border-bottom: none;
        }
        
        .taf-forecast {
            font-size: 10px;
            color: #9b59b6;
            margin-top: 3px;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .data-panel {
            background: #252540;
            border-radius: 8px;
            padding: 12px;
        }
        
        .data-panel h3 {
            font-size: 13px;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #333;
        }
        
        .data-panel h3[onclick]:hover {
            opacity: 0.8;
        }
        
        .compact-list {
            font-size: 11px;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .compact-list .item {
            padding: 4px 0;
            border-bottom: 1px solid #1a1a2e;
        }
        
        /* Runway Map Styles */
        .runway-map-btn {
            background: #2a4a5a;
            color: #4a90d9;
            border: 1px solid #4a90d9;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 11px;
            cursor: pointer;
            margin-left: 6px;
            white-space: nowrap;
            position: relative;
            z-index: 10;
        }
        
        .runway-map-btn:hover {
            background: #3a5a6a;
        }
        
        .runway-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .runway-modal.active {
            display: flex;
        }
        
        .runway-modal-content {
            background: #1a1a2e;
            border-radius: 12px;
            padding: 20px;
            max-width: 500px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            border: 1px solid #333;
        }
        
        .runway-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }
        
        .runway-modal-title {
            font-size: 18px;
            font-weight: bold;
            color: #fff;
        }
        
        .runway-modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            padding: 0 5px;
        }
        
        .runway-modal-close:hover {
            color: #fff;
        }
        
        .runway-diagram {
            background: #0d1f0d;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .runway-diagram svg {
            max-width: 100%;
        }
        
        .runway-list {
            font-size: 12px;
        }
        
        .runway-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #252540;
        }
        
        .runway-item:last-child {
            border-bottom: none;
        }
        
        .runway-ident {
            font-weight: bold;
            color: #4a90d9;
        }
        
        .runway-dim {
            color: #888;
        }
        
        .runway-surface {
            color: #aaa;
            text-transform: capitalize;
        }
        
        .runway-closed {
            color: #e74c3c;
            font-weight: bold;
        }
        
        .runway-loading {
            text-align: center;
            padding: 30px;
            color: #888;
        }
        
        .runway-error {
            text-align: center;
            padding: 20px;
            color: #e74c3c;
        }
        
        .runway-faa-link {
            display: block;
            text-align: center;
            margin-top: 15px;
            padding: 10px;
            background: #252540;
            border-radius: 6px;
            color: #4a90d9;
            text-decoration: none;
        }
        
        .runway-faa-link:hover {
            background: #303050;
        }
        
        /* Settings Modal Styles */
        .settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1001;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .settings-modal.active {
            display: flex;
        }
        
        .settings-modal-content {
            background: #1a1a2e;
            border-radius: 12px;
            padding: 20px;
            max-width: 700px;
            width: 100%;
            max-height: 85vh;
            overflow-y: auto;
            border: 1px solid #333;
        }
        
        .settings-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }
        
        .settings-modal-title {
            font-size: 18px;
            font-weight: bold;
            color: #fff;
        }
        
        .settings-modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            padding: 0 5px;
        }
        
        .settings-modal-close:hover {
            color: #fff;
        }
        
        .settings-region-group {
            margin-bottom: 15px;
            background: #252540;
            border-radius: 8px;
            padding: 12px;
        }
        
        .settings-region-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #333;
        }
        
        .settings-region-title {
            font-size: 14px;
            font-weight: bold;
            color: #4a90d9;
        }
        
        .settings-region-actions {
            display: flex;
            gap: 8px;
        }
        
        .settings-region-actions button {
            background: #1a1a2e;
            border: 1px solid #444;
            color: #888;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            cursor: pointer;
        }
        
        .settings-region-actions button:hover {
            background: #333;
            color: #fff;
        }
        
        .settings-airport-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 6px;
        }
        
        .settings-airport-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 6px;
            background: #1a1a2e;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
        }
        
        .settings-airport-item:hover {
            background: #333;
        }
        
        .settings-airport-item input[type="checkbox"] {
            margin: 0;
            cursor: pointer;
        }
        
        .settings-airport-item .icao {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #4a90d9;
        }
        
        .settings-airport-item .name {
            color: #aaa;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .settings-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
        }
        
        .settings-footer .count {
            color: #888;
            font-size: 12px;
        }
        
        .settings-footer button {
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
        }
        
        .settings-footer .save-btn {
            background: #4a90d9;
            color: white;
            border: none;
        }
        
        .settings-footer .save-btn:hover {
            background: #5ba0e9;
        }
        
        .settings-footer .reset-btn {
            background: transparent;
            color: #888;
            border: 1px solid #444;
            margin-right: 10px;
        }
        
        .settings-footer .reset-btn:hover {
            background: #333;
            color: #fff;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>&#x1F6EB; Airport Weather & ATC Monitor</h1>
            <div class="subtitle" id="subtitleText">Top 110 US + Canadian Airports &bull; Search Any Airport Worldwide</div>
            <div class="timestamp" id="timestamp">Loading...</div>
        </header>
        
        <div class="timezone-box" id="timezoneBox">
            <div class="tz-item zulu">
                <div class="tz-time" id="tz-zulu">--:--</div>
                <div class="tz-date" id="tz-zulu-date">---</div>
                <div class="tz-label">Zulu</div>
            </div>
            <div class="tz-item local">
                <div class="tz-time" id="tz-local">--:--</div>
                <div class="tz-date" id="tz-local-date">---</div>
                <div class="tz-label" id="tz-local-label">Local</div>
            </div>
            <div class="tz-toggle" id="tzToggle" onclick="toggleAllTimezones()" title="Show all US timezones">+</div>
        </div>
        <div class="timezone-box-expanded" id="timezoneBoxExpanded" style="display:none;">
            <div class="tz-item">
                <div class="tz-time" id="tz-eastern">--:--</div>
                <div class="tz-date" id="tz-eastern-date">---</div>
                <div class="tz-label">Eastern</div>
            </div>
            <div class="tz-item">
                <div class="tz-time" id="tz-central">--:--</div>
                <div class="tz-date" id="tz-central-date">---</div>
                <div class="tz-label">Central</div>
            </div>
            <div class="tz-item">
                <div class="tz-time" id="tz-mountain">--:--</div>
                <div class="tz-date" id="tz-mountain-date">---</div>
                <div class="tz-label">Mountain</div>
            </div>
            <div class="tz-item">
                <div class="tz-time" id="tz-pacific">--:--</div>
                <div class="tz-date" id="tz-pacific-date">---</div>
                <div class="tz-label">Pacific</div>
            </div>
        </div>
        
        <div class="controls">
            <div class="search-box">
                <input type="text" id="searchInput" placeholder="&#x1F50D; Search any airport (KORD, EGLL, ORD, LHR...)" oninput="debouncedFilter()" onkeydown="if(event.key==='Enter')filterAirports()">
                <button onclick="clearSearch()">&#x2716;</button>
            </div>
        </div>
        
        <div class="filter-buttons">
            <button class="filter-btn active" data-region="all" onclick="setRegionFilter('all')">All</button>
            <button class="filter-btn" data-region="us" onclick="setRegionFilter('us')">US</button>
            <button class="filter-btn" data-region="northeast" onclick="setRegionFilter('northeast')">NE</button>
            <button class="filter-btn" data-region="midwest" onclick="setRegionFilter('midwest')">MW</button>
            <button class="filter-btn" data-region="south" onclick="setRegionFilter('south')">South</button>
            <button class="filter-btn" data-region="west" onclick="setRegionFilter('west')">West</button>
            <button class="filter-btn" data-region="canada" onclick="setRegionFilter('canada')">Canada</button>
            <button class="filter-btn" data-region="dl-hubs" onclick="setRegionFilter('dl-hubs')">DL Hubs</button>
            <button class="filter-btn" data-region="airline-hubs" onclick="setRegionFilter('airline-hubs')">All Hubs</button>
        </div>
        
        <div class="controls" style="margin-bottom: 3px;">
            <button id="refreshBtn" onclick="fetchData()">&#x1F504; Refresh</button>
            <div class="auto-refresh">
                <span>Auto:</span>
                <select id="autoRefresh" onchange="setAutoRefresh()">
                    <option value="0">Off</option>
                    <option value="5" selected>5m</option>
                    <option value="15">15m</option>
                    <option value="30">30m</option>
                </select>
            </div>
            <button onclick="openAirportSettings()" style="background:#4a90d9; padding: 6px 10px;">&#x2699; Customize</button>
        </div>
        
        <!-- Quick Action Buttons + Hub Legend - Combined Row -->
        <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 4px; flex-wrap: wrap;">
            <button class="datis-btn" onclick="openDatisPopup()" style="background: linear-gradient(135deg, #f39c12, #e67e22); border: 2px solid #f39c12; color: #000; padding: 5px 10px; border-radius: 5px; font-size: 11px; font-weight: bold;"> D-ATIS</button>
            <button class="notams-btn" onclick="window.open('https://notams.aim.faa.gov/notamSearch/', '_blank')" style="background: linear-gradient(135deg, #3498db, #2980b9); border: 2px solid #3498db; color: #fff; padding: 5px 10px; border-radius: 5px; font-size: 11px; font-weight: bold;"> NOTAMs</button>
            <span style="font-size: 9px; color: #888; padding: 3px 6px; background: rgba(231, 76, 60, 0.1); border-radius: 3px; border: 1px dashed #e74c3c;"><span style="color: #e74c3c; font-weight: bold;">*</span> = Delta Hub</span>
        </div>
        
        <!-- Summary Cards Dashboard -->
        <div id="summaryDashboard" class="summary-dashboard">
            <div class="summary-row">
                <div class="summary-card active" id="card-active" onclick="scrollToSection('section-active')">
                    <div class="count" id="count-active">-</div>
                    <div class="label">&#x1F534; Active Deice</div>
                </div>
                <div class="summary-card residual" id="card-residual" onclick="scrollToSection('section-residual')">
                    <div class="count" id="count-residual">-</div>
                    <div class="label">&#x1F7E3; Residual</div>
                </div>
                <div class="summary-card likely" id="card-likely" onclick="scrollToSection('section-likely')">
                    <div class="count" id="count-likely">-</div>
                    <div class="label">&#x1F7E0; Likely Deice</div>
                </div>
                <div class="summary-card possible" id="card-possible" onclick="scrollToSection('section-possible')">
                    <div class="count" id="count-possible">-</div>
                    <div class="label">&#x1F7E1; Possible</div>
                </div>
            </div>
            <div class="summary-row">
                <div class="summary-card atc" id="card-atc" onclick="scrollToSection('section-traffic')">
                    <div class="count" id="count-atc">-</div>
                    <div class="label">&#x1F6EB; GDP / GS</div>
                </div>
                <div class="summary-card arr-dep-delay" id="card-arr-dep" onclick="scrollToSection('section-arr-dep')">
                    <div class="count" id="count-arr-dep">-</div>
                    <div class="label">&#x23F1; Arr/Dep Dly</div>
                </div>
                <div class="summary-card planned" id="card-planned" onclick="scrollToSection('section-planned')">
                    <div class="count" id="count-planned">-</div>
                    <div class="label">&#x23F3; POSSIBLE ATC'S</div>
                </div>
                <div class="summary-card closure" id="card-closure" onclick="scrollToSection('section-closure')">
                    <div class="count" id="count-closure">-</div>
                    <div class="label">&#x1F6A7; Rwy Closed</div>
                </div>
            </div>
            <div class="summary-row">
                <div class="summary-card afp" id="card-afp" onclick="scrollToSection('section-afp')">
                    <div class="count" id="count-afp">-</div>
                    <div class="label">&#x1F504; AFP</div>
                </div>
                <div class="summary-card vip" id="card-vip" onclick="scrollToSection('section-vip')">
                    <div class="count" id="count-vip">-</div>
                    <div class="label">&#x1F6A8; VIP MOVEMENT</div>
                </div>
                <div class="summary-card rocket" id="card-rocket" onclick="scrollToSection('section-rocket')">
                    <div class="count" id="count-rocket">-</div>
                    <div class="label">&#x1F680; ROCKET LAUNCHES</div>
                </div>
                <div class="summary-card staffing" id="card-staffing" onclick="scrollToSection('section-staffing')">
                    <div class="count" id="count-staffing">-</div>
                    <div class="label">&#x1F464; ATC STAFFING</div>
                </div>
            </div>
            <div id="faa-advisory-fallback" class="summary-row" style="display: none; justify-content: center;">
                <button onclick="window.open('https://www.fly.faa.gov/adv/adv_spt', '_blank')" style="background: #9b59b6; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                     FAA Ops Plan unavailable - Click to view on FAA.gov 
                </button>
            </div>
            <div class="summary-row">
                <div class="summary-card frost" id="card-frost" onclick="scrollToSection('section-frost')">
                    <div class="count" id="count-frost">-</div>
                    <div class="label">&#x1F319; Frost Risk</div>
                </div>
                <div class="summary-card taf-warn" id="card-taf" onclick="scrollToSection('section-taf')">
                    <div class="count" id="count-taf">-</div>
                    <div class="label">&#x2744; TAF Winter</div>
                </div>
                <div class="summary-card precip" id="card-precip" onclick="scrollToSection('section-precip')">
                    <div class="count" id="count-precip">-</div>
                    <div class="label">&#x1F327; Rain/Precip</div>
                </div>
                <div class="summary-card none" id="card-none" onclick="scrollToSection('section-none')">
                    <div class="count" id="count-none">-</div>
                    <div class="label">&#x1F7E2; Clear</div>
                </div>
            </div>
            <div class="summary-row">
                <div class="summary-card lifr" id="card-lifr" onclick="scrollToSection('section-lifr')">
                    <div class="count" id="count-lifr">-</div>
                    <div class="label">&#x1F7E3; LIFR Now</div>
                </div>
                <div class="summary-card taf-lifr" id="card-taf-lifr" onclick="scrollToSection('section-taf-lifr')">
                    <div class="count" id="count-taf-lifr">-</div>
                    <div class="label">&#x1F4CB; TAF LIFR</div>
                </div>
                <div class="summary-card lifr" id="card-ifr" onclick="scrollToSection('section-ifr')">
                    <div class="count" id="count-ifr">-</div>
                    <div class="label">&#x1F534; IFR Now</div>
                </div>
                <div class="summary-card taf-lifr" id="card-taf-ifr" onclick="scrollToSection('section-taf-ifr')">
                    <div class="count" id="count-taf-ifr">-</div>
                    <div class="label">&#x1F4CB; TAF IFR</div>
                </div>
            </div>
            <div class="summary-row">
                <div class="summary-card high-wind" id="card-high-wind" onclick="scrollToSection('section-high-wind')">
                    <div class="count" id="count-high-wind">-</div>
                    <div class="label">&#x1F4A8; High Wind</div>
                </div>
                <div class="summary-card taf-wind" id="card-taf-wind" onclick="scrollToSection('section-taf-wind')">
                    <div class="count" id="count-taf-wind">-</div>
                    <div class="label">&#x1F4CB; TAF Wind</div>
                </div>
                <div class="summary-card tstorm" id="card-tstorm" onclick="scrollToSection('section-tstorm')">
                    <div class="count" id="count-tstorm">-</div>
                    <div class="label">&#x26A1; T-Storm</div>
                </div>
                <div class="summary-card taf-tstorm" id="card-taf-tstorm" onclick="scrollToSection('section-taf-tstorm')">
                    <div class="count" id="count-taf-tstorm">-</div>
                    <div class="label">&#x1F4CB; TAF TS</div>
                </div>
            </div>
            <!-- Temperature Alert Cards - Current -->
            <div class="summary-row">
                <div class="summary-card temp-freezing" id="card-temp-freezing" onclick="scrollToSection('section-temp-freezing')">
                    <div class="count" id="count-temp-freezing">-</div>
                    <div class="label">&#x1F9CA; Freezing</div>
                </div>
                <div class="summary-card temp-approach" id="card-temp-approach" onclick="scrollToSection('section-temp-approach')">
                    <div class="count" id="count-temp-approach">-</div>
                    <div class="label">&#x2B07; Near Freeze</div>
                </div>
                <div class="summary-card temp-normal" id="card-temp-normal" onclick="scrollToSection('section-temp-normal')">
                    <div class="count" id="count-temp-normal">-</div>
                    <div class="label">&#x1F321; Normal Temps</div>
                </div>
                <div class="summary-card temp-hot" id="card-temp-hot" onclick="scrollToSection('section-temp-hot')">
                    <div class="count" id="count-temp-hot">-</div>
                    <div class="label">&#x1F525; Temps Over 90 F</div>
                </div>
            </div>
            <!-- Temperature Alert Cards - NWS Forecast -->
            <div class="summary-row">
                <div class="summary-card taf-temp-freezing" id="card-taf-temp-freezing" onclick="scrollToSection('section-taf-temp-freezing')">
                    <div class="count" id="count-taf-temp-freezing">-</div>
                    <div class="label">&#x1F321; Fcst Freeze</div>
                </div>
                <div class="summary-card taf-temp-approach" id="card-taf-temp-approach" onclick="scrollToSection('section-taf-temp-approach')">
                    <div class="count" id="count-taf-temp-approach">-</div>
                    <div class="label">&#x1F321; Fcst Near Freeze</div>
                </div>
                <div class="summary-card taf-temp-normal" id="card-taf-temp-normal" onclick="scrollToSection('section-taf-temp-normal')">
                    <div class="count" id="count-taf-temp-normal">-</div>
                    <div class="label">&#x1F321; Fcst Normal Temps</div>
                </div>
                <div class="summary-card taf-temp-hot" id="card-taf-temp-hot" onclick="scrollToSection('section-taf-temp-hot')">
                    <div class="count" id="count-taf-temp-hot">-</div>
                    <div class="label">&#x1F321; Fcst Over 90 F</div>
                </div>
            </div>
        </div>
        
        <!-- Weather Map Section -->
        <div class="weather-map-container">
            <div class="weather-map-header" onclick="toggleWeatherMap()">
                <h3> TAF Weather Map</h3>
                <span class="weather-map-toggle" id="weatherMapToggle"> Show</span>
            </div>
            <div class="weather-map-content" id="weatherMapContent">
                <div id="weatherMapSvg"></div>
                <div class="weather-map-legend">
                    <div class="legend-title">Priority (HighLow):</div>
                    <div class="legend-item"><div class="legend-dot" style="background: #9b59b6;"></div>  T-Storm</div>
                    <div class="legend-item"><div class="legend-dot" style="background: #ff00ff;"></div>  FZ Rain/Ice</div>
                    <div class="legend-item"><div class="legend-dot" style="background: #00ffff;"></div>  Snow</div>
                    <div class="legend-item"><div class="legend-dot" style="background: #c0392b;"></div>  LIFR</div>
                    <div class="legend-item"><div class="legend-dot" style="background: #e74c3c;"></div>  IFR</div>
                    <div class="legend-item"><div class="legend-dot" style="background: #2980b9;"></div>  High Wind</div>
                    <div class="legend-item"><div class="legend-dot" style="background: #f39c12;"></div>  MVFR</div>
                    <div class="legend-item"><div class="legend-dot" style="background: #7f8c8d;"></div>  Fog/Haze</div>
                    <div class="legend-item"><div class="legend-dot" style="background: #27ae60;"></div>  VFR</div>
                </div>
            </div>
        </div>
        
        <div class="wind-threshold-box">
            <span>&#x1F4A8; Wind Alert Threshold:</span>
            <input type="number" id="windThreshold" value="20" min="5" max="100" onchange="updateWindThreshold()">
            <span>kt (or gusts)</span>
        </div>
        
        <div id="content">
            <div class="loading">
                <div class="spinner"></div>
                <div>Fetching METAR data for 110 airports...</div>
            </div>
        </div>
        
        <footer>
            Data: Aviation Weather Center<br>
            Tap airport to see history  Tap city name to open full METAR
        </footer>
    </div>

    <!-- Runway Map Modal -->
    <div id="runwayModal" class="runway-modal" onclick="closeRunwayModal(event)">
        <div class="runway-modal-content" onclick="event.stopPropagation()">
            <div class="runway-modal-header">
                <div class="runway-modal-title" id="runwayModalTitle">Loading...</div>
                <button class="runway-modal-close" onclick="closeRunwayModal()">&times;</button>
            </div>
            <div id="runwayModalBody">
                <div class="runway-loading">Loading runway data...</div>
            </div>
        </div>
    </div>

    <!-- Airport Settings Modal -->
    <div id="settingsModal" class="settings-modal" onclick="closeSettingsModal(event)">
        <div class="settings-modal-content" onclick="event.stopPropagation()">
            <div class="settings-modal-header">
                <div class="settings-modal-title">&#x2699; Customize Monitored Airports</div>
                <button class="settings-modal-close" onclick="closeSettingsModal()">&times;</button>
            </div>
            <div id="settingsModalBody">
                <!-- Content will be generated by JavaScript -->
            </div>
            <div class="settings-footer">
                <div class="count"><span id="selectedAirportCount">110</span> of 110 airports selected</div>
                <div>
                    <button class="reset-btn" onclick="resetAirportSettings()">Reset All</button>
                    <button class="save-btn" onclick="saveAirportSettings()">Save &amp; Refresh</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Top 110 US + Canadian airports by passenger volume (interleaved)
        const AIRPORTS = [
            // 1-10
            'KATL', 'KLAX', 'KORD', 'KDFW', 'KDEN', 'CYYZ', 'KJFK', 'KSFO', 'KLAS', 'KMCO',
            // 11-20
            'KSEA', 'KMIA', 'KPHX', 'KEWR', 'KIAH', 'CYVR', 'KBOS', 'KMSP', 'KDTW', 'KFLL',
            // 21-30
            'KPHL', 'KLGA', 'CYUL', 'KBWI', 'KSLC', 'CYYC', 'KDCA', 'KSAN', 'KTPA', 'KAUS',
            // 31-40
            'KIAD', 'KMDW', 'KHNL', 'KSTL', 'KBNA', 'KOAK', 'KSMF', 'KSJC', 'KRDU', 'KMCI',
            // 41-50
            'KCLE', 'KPIT', 'KCLT', 'KPDX', 'KIND', 'CYEG', 'KCVG', 'KMSY', 'KSAT', 'KMKE',
            // 51-60
            'KBUF', 'KPBI', 'KABQ', 'KONT', 'KRSW', 'CYOW', 'KBUR', 'KOMA', 'KRIC', 'KBDL',
            // 61-70
            'KSNA', 'KJAN', 'KCHS', 'KJAX', 'KORF', 'CYWG', 'CYHZ', 'KANC', 'KLIT', 'KELP',
            // 71-80
            'KTUS', 'KOKC', 'KTUL', 'KGRR', 'KDSM', 'KDAY', 'KSYR', 'KPVD', 'KALB', 'KGSO',
            // 81-90
            'KPWM', 'KBTV', 'KROC', 'CYQB', 'CYYT', 'KBHM', 'KLEX', 'KSDF', 'KCMH', 'KCOS',
            // 91-100
            'KBOI', 'KFSD', 'KICT', 'KMSN', 'KLBB', 'KFAR', 'KBIS', 'KDLH', 'KERI', 'KBGR',
            // 101-110
            'KAVL', 'KMYR', 'KSAV', 'KPNS', 'KFWA', 'KLNK', 'KSGF', 'KXNA', 'KCRP', 'KABI'
        ];

        const AIRPORT_NAMES = {
            // Top 50
            'KATL': 'Atlanta', 'KLAX': 'Los Angeles', 'KORD': 'Chicago ORD',
            'KDFW': 'Dallas/Fort Worth', 'KDEN': 'Denver', 'KJFK': 'New York JFK',
            'KSFO': 'San Francisco', 'KLAS': 'Las Vegas', 'KMCO': 'Orlando',
            'KSEA': 'Seattle', 'KMIA': 'Miami', 'KPHX': 'Phoenix', 'KEWR': 'Newark',
            'KIAH': 'Houston IAH', 'KBOS': 'Boston', 'KMSP': 'Minneapolis',
            'KDTW': 'Detroit', 'KFLL': 'Fort Lauderdale', 'KPHL': 'Philadelphia',
            'KLGA': 'New York LGA', 'KBWI': 'Baltimore', 'KSLC': 'Salt Lake City',
            'KDCA': 'Washington DCA', 'KSAN': 'San Diego', 'KTPA': 'Tampa',
            'KAUS': 'Austin', 'KIAD': 'Washington IAD', 'KMDW': 'Chicago MDW',
            'KHNL': 'Honolulu', 'KSTL': 'St. Louis', 'KBNA': 'Nashville',
            'KOAK': 'Oakland', 'KSMF': 'Sacramento', 'KSJC': 'San Jose',
            'KRDU': 'Raleigh-Durham', 'KMCI': 'Kansas City', 'KCLE': 'Cleveland',
            'KPIT': 'Pittsburgh', 'KCLT': 'Charlotte', 'KPDX': 'Portland OR',
            'KIND': 'Indianapolis', 'KCVG': 'Cincinnati', 'KMSY': 'New Orleans',
            'KSAT': 'San Antonio', 'KMKE': 'Milwaukee', 'KBUF': 'Buffalo',
            'KPBI': 'West Palm Beach', 'KABQ': 'Albuquerque', 'KONT': 'Ontario CA',
            'KRSW': 'Fort Myers',
            // 51-75
            'KBUR': 'Burbank', 'KOMA': 'Omaha', 'KRIC': 'Richmond',
            'KBDL': 'Hartford', 'KSNA': 'Orange County', 'KJAN': 'Jackson MS',
            'KCHS': 'Charleston', 'KJAX': 'Jacksonville', 'KORF': 'Norfolk',
            'KANC': 'Anchorage', 'KLIT': 'Little Rock', 'KELP': 'El Paso',
            'KTUS': 'Tucson', 'KOKC': 'Oklahoma City', 'KTUL': 'Tulsa',
            'KGRR': 'Grand Rapids', 'KDSM': 'Des Moines', 'KDAY': 'Dayton',
            'KSYR': 'Syracuse', 'KPVD': 'Providence', 'KALB': 'Albany',
            'KGSO': 'Greensboro', 'KPWM': 'Portland ME', 'KBTV': 'Burlington VT',
            'KROC': 'Rochester',
            // 76-100
            'KBHM': 'Birmingham', 'KLEX': 'Lexington', 'KSDF': 'Louisville',
            'KCMH': 'Columbus OH', 'KCOS': 'Colorado Springs', 'KBOI': 'Boise',
            'KFSD': 'Sioux Falls', 'KICT': 'Wichita', 'KMSN': 'Madison',
            'KLBB': 'Lubbock', 'KFAR': 'Fargo', 'KBIS': 'Bismarck',
            'KDLH': 'Duluth', 'KERI': 'Erie', 'KBGR': 'Bangor',
            'KAVL': 'Asheville', 'KMYR': 'Myrtle Beach', 'KSAV': 'Savannah',
            'KPNS': 'Pensacola', 'KFWA': 'Fort Wayne', 'KLNK': 'Lincoln',
            'KSGF': 'Springfield MO', 'KXNA': 'NW Arkansas', 'KCRP': 'Corpus Christi',
            'KABI': 'Abilene',
            // Military bases (common for VIP movements)
            'KADW': 'Andrews AFB', 'KDOV': 'Dover AFB', 'KBLV': 'Scott AFB',
            'KNGU': 'Norfolk NS', 'KPHF': 'Newport News', 'KLFI': 'Langley AFB',
            'KDAA': 'Ft Belvoir', 'KNYG': 'Quantico', 'KNBC': 'Beaufort MCAS',
            // Top 10 Canada
            'CYYZ': 'Toronto Pearson', 'CYVR': 'Vancouver', 'CYUL': 'Montreal Trudeau',
            'CYYC': 'Calgary', 'CYEG': 'Edmonton', 'CYOW': 'Ottawa',
            'CYWG': 'Winnipeg', 'CYQB': 'Quebec City', 'CYYT': "St. John's NL",
            'CYHZ': 'Halifax'
        };

        // Timezone offsets from UTC (standard time - will need DST adjustment)
        const AIRPORT_TIMEZONES = {
            // Eastern (-5 standard, -4 DST)
            'KATL': 'America/New_York', 'KJFK': 'America/New_York', 'KMCO': 'America/New_York',
            'KMIA': 'America/New_York', 'KEWR': 'America/New_York', 'KBOS': 'America/New_York',
            'KDTW': 'America/New_York', 'KFLL': 'America/New_York', 'KPHL': 'America/New_York',
            'KLGA': 'America/New_York', 'KBWI': 'America/New_York', 'KDCA': 'America/New_York',
            'KTPA': 'America/New_York', 'KIAD': 'America/New_York', 'KRDU': 'America/New_York',
            'KCLE': 'America/New_York', 'KPIT': 'America/New_York', 'KCLT': 'America/New_York',
            'KIND': 'America/New_York', 'KCVG': 'America/New_York', 'KBUF': 'America/New_York',
            'KPBI': 'America/New_York', 'KRSW': 'America/New_York', 'KRIC': 'America/New_York',
            'KBDL': 'America/New_York', 'KCHS': 'America/New_York', 'KJAX': 'America/New_York',
            'KORF': 'America/New_York', 'KDAY': 'America/New_York', 'KSYR': 'America/New_York',
            'KPVD': 'America/New_York', 'KALB': 'America/New_York', 'KGSO': 'America/New_York',
            'KROC': 'America/New_York', 'KBHM': 'America/New_York', 'KLEX': 'America/New_York',
            'KSDF': 'America/New_York', 'KCMH': 'America/New_York', 'KERI': 'America/New_York',
            'KBGR': 'America/New_York', 'KAVL': 'America/New_York', 'KMYR': 'America/New_York',
            'KSAV': 'America/New_York', 'KPNS': 'America/New_York', 'KFWA': 'America/New_York',
            'KPWM': 'America/New_York', 'KBTV': 'America/New_York',
            // Central (-6 standard, -5 DST)
            'KORD': 'America/Chicago', 'KDFW': 'America/Chicago', 'KIAH': 'America/Chicago',
            'KMSP': 'America/Chicago', 'KMDW': 'America/Chicago', 'KSTL': 'America/Chicago',
            'KBNA': 'America/Chicago', 'KMCI': 'America/Chicago', 'KMSY': 'America/Chicago',
            'KSAT': 'America/Chicago', 'KMKE': 'America/Chicago', 'KAUS': 'America/Chicago',
            'KOMA': 'America/Chicago', 'KJAN': 'America/Chicago', 'KLIT': 'America/Chicago',
            'KELP': 'America/Chicago', 'KOKC': 'America/Chicago', 'KTUL': 'America/Chicago',
            'KGRR': 'America/Chicago', 'KDSM': 'America/Chicago', 'KFSD': 'America/Chicago',
            'KICT': 'America/Chicago', 'KMSN': 'America/Chicago', 'KLBB': 'America/Chicago',
            'KFAR': 'America/Chicago', 'KBIS': 'America/Chicago', 'KDLH': 'America/Chicago',
            'KLNK': 'America/Chicago', 'KSGF': 'America/Chicago', 'KXNA': 'America/Chicago',
            'KCRP': 'America/Chicago', 'KABI': 'America/Chicago',
            // Mountain (-7 standard, -6 DST)
            'KDEN': 'America/Denver', 'KPHX': 'America/Phoenix', 'KSLC': 'America/Denver',
            'KABQ': 'America/Denver', 'KTUS': 'America/Denver', 'KCOS': 'America/Denver',
            'KBOI': 'America/Boise',
            // Pacific (-8 standard, -7 DST)
            'KLAX': 'America/Los_Angeles', 'KSFO': 'America/Los_Angeles', 'KLAS': 'America/Los_Angeles',
            'KSEA': 'America/Los_Angeles', 'KSAN': 'America/Los_Angeles', 'KPDX': 'America/Los_Angeles',
            'KOAK': 'America/Los_Angeles', 'KSMF': 'America/Los_Angeles', 'KSJC': 'America/Los_Angeles',
            'KONT': 'America/Los_Angeles', 'KBUR': 'America/Los_Angeles', 'KSNA': 'America/Los_Angeles',
            // Alaska/Hawaii
            'KANC': 'America/Anchorage', 'KHNL': 'Pacific/Honolulu',
            // Canada
            'CYYZ': 'America/Toronto', 'CYVR': 'America/Vancouver', 'CYUL': 'America/Montreal',
            'CYYC': 'America/Edmonton', 'CYEG': 'America/Edmonton', 'CYOW': 'America/Toronto',
            'CYWG': 'America/Winnipeg', 'CYQB': 'America/Montreal', 'CYYT': 'America/St_Johns',
            'CYHZ': 'America/Halifax'
        };

        // Major airline hubs
        const HUB_AIRPORTS = {
            'KATL': ['Delta'],
            'KLAX': ['American', 'Delta', 'United'],
            'KORD': ['American', 'United'],
            'KDFW': ['American'],
            'KDEN': ['United', 'Southwest', 'Frontier'],
            'KJFK': ['JetBlue', 'Delta'],
            'KSFO': ['United'],
            'KLAS': ['Southwest', 'Spirit'],
            'KMCO': ['Southwest', 'JetBlue'],
            'KSEA': ['Alaska', 'Delta'],
            'KMIA': ['American'],
            'KPHX': ['American', 'Southwest'],
            'KEWR': ['United'],
            'KIAH': ['United'],
            'KBOS': ['JetBlue'],
            'KMSP': ['Delta', 'Sun Country'],
            'KDTW': ['Delta'],
            'KCLT': ['American'],
            'KSLC': ['Delta'],
            'KBWI': ['Southwest'],
            'KMDW': ['Southwest'],
            'KBNA': ['Southwest'],
            'KAUS': ['Southwest'],
            'KFLL': ['Spirit', 'JetBlue'],
            // Canada
            'CYYZ': ['Air Canada', 'WestJet'],
            'CYVR': ['Air Canada', 'WestJet'],
            'CYUL': ['Air Canada'],
            'CYYC': ['WestJet']
        };

        // Traffic management data
        let trafficPrograms = {};
        
        // Additional aviation data
        let tafData = {};
        let currentSearchTerm = '';
        let currentRegionFilter = 'all';

        // Runway counts per airport (for display purposes)
        const RUNWAY_COUNT = {
            'KATL': 5, 'KLAX': 4, 'KORD': 8, 'KDFW': 7, 'KDEN': 6, 'KJFK': 4, 'KSFO': 4, 'KLAS': 4, 'KMCO': 4, 'KSEA': 3,
            'KMIA': 4, 'KPHX': 3, 'KEWR': 3, 'KIAH': 5, 'KBOS': 4, 'KMSP': 4, 'KDTW': 6, 'KFLL': 2, 'KPHL': 4, 'KLGA': 2,
            'KBWI': 3, 'KSLC': 4, 'KDCA': 3, 'KSAN': 1, 'KTPA': 3, 'KAUS': 2, 'KIAD': 4, 'KMDW': 5, 'KHNL': 4, 'KSTL': 4,
            'KBNA': 4, 'KOAK': 4, 'KSMF': 2, 'KSJC': 2, 'KRDU': 3, 'KMCI': 3, 'KCLE': 3, 'KPIT': 4, 'KCLT': 4, 'KPDX': 3,
            'KIND': 3, 'KCVG': 4, 'KMSY': 2, 'KSAT': 3, 'KMKE': 5, 'KBUF': 2, 'KPBI': 3, 'KABQ': 3, 'KONT': 2, 'KRSW': 2,
            'KBUR': 1, 'KOMA': 3, 'KRIC': 2, 'KBDL': 2, 'KSNA': 1, 'KJAN': 2, 'KCHS': 2, 'KJAX': 2, 'KORF': 2, 'KANC': 3,
            'KLIT': 2, 'KELP': 3, 'KTUS': 3, 'KOKC': 3, 'KTUL': 3, 'KGRR': 2, 'KDSM': 2, 'KDAY': 3, 'KSYR': 2, 'KPVD': 2,
            'KALB': 2, 'KGSO': 2, 'KPWM': 2, 'KBTV': 2, 'KROC': 2, 'KBHM': 3, 'KLEX': 2, 'KSDF': 3, 'KCMH': 3, 'KCOS': 3,
            'KBOI': 2, 'KFSD': 2, 'KICT': 3, 'KMSN': 2, 'KLBB': 2, 'KFAR': 2, 'KBIS': 2, 'KDLH': 2, 'KERI': 2, 'KBGR': 2,
            'KAVL': 1, 'KMYR': 2, 'KSAV': 2, 'KPNS': 2, 'KFWA': 2, 'KLNK': 2, 'KSGF': 2, 'KXNA': 2, 'KCRP': 2, 'KABI': 2,
            // Canada
            'CYYZ': 5, 'CYVR': 3, 'CYUL': 3, 'CYYC': 4, 'CYEG': 2, 'CYOW': 3, 'CYWG': 3, 'CYQB': 2, 'CYYT': 2, 'CYHZ': 2
        };

        // Regional groupings
        const AIRPORT_REGIONS = {
            northeast: ['KJFK', 'KEWR', 'KLGA', 'KBOS', 'KPHL', 'KBWI', 'KDCA', 'KIAD', 'KBUF', 'KBDL', 'KSYR', 'KPVD', 'KALB', 'KPWM', 'KBTV', 'KROC', 'KERI', 'KBGR', 'KPIT'],
            midwest: ['KORD', 'KMDW', 'KDTW', 'KMSP', 'KCLE', 'KIND', 'KCVG', 'KMKE', 'KSTL', 'KMCI', 'KOMA', 'KGRR', 'KDSM', 'KDAY', 'KCMH', 'KFSD', 'KICT', 'KMSN', 'KFAR', 'KBIS', 'KDLH', 'KFWA', 'KLNK', 'KSGF'],
            south: ['KATL', 'KMIA', 'KFLL', 'KTPA', 'KMCO', 'KIAH', 'KDFW', 'KAUS', 'KSAT', 'KMSY', 'KBNA', 'KCLT', 'KRDU', 'KRIC', 'KJAN', 'KCHS', 'KJAX', 'KORF', 'KLIT', 'KELP', 'KOKC', 'KTUL', 'KGSO', 'KBHM', 'KLEX', 'KSDF', 'KAVL', 'KMYR', 'KSAV', 'KPNS', 'KXNA', 'KCRP', 'KABI', 'KPBI', 'KRSW', 'KLBB'],
            west: ['KLAX', 'KSFO', 'KLAS', 'KSEA', 'KPHX', 'KDEN', 'KSLC', 'KSAN', 'KPDX', 'KOAK', 'KSMF', 'KSJC', 'KABQ', 'KONT', 'KBUR', 'KSNA', 'KTUS', 'KCOS', 'KBOI', 'KANC', 'KHNL'],
            canada: ['CYYZ', 'CYVR', 'CYUL', 'CYYC', 'CYEG', 'CYOW', 'CYWG', 'CYQB', 'CYYT', 'CYHZ']
        };
        
        // Delta Air Lines hubs
        const DL_HUBS = ['KATL', 'KMSP', 'KDTW', 'KSLC', 'KJFK', 'KLGA', 'KBOS', 'KSEA', 'KLAX'];

        const FROZEN_PRECIP = ['SN', 'FZRA', 'FZFG', 'FZDZ', 'PL', 'GR', 'GS', 'IC', 'SG'];
        const ALL_PRECIP = [...FROZEN_PRECIP, 'RA', 'DZ', 'SHRA', 'TSRA', 'SHSN'];

        let refreshInterval = null;
        let windThreshold = 20; // Default wind alert threshold in knots
        
        // Global storage for current wind data by airport
        const currentWindData = {};

        const CORS_PROXIES = [
            (url) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
            (url) => `https://corsproxy.io/?${encodeURIComponent(url)}`,
            (url) => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`,
            (url) => `https://thingproxy.freeboard.io/fetch/${url}`,
            (url) => `https://cors.sh/${url}`,
            (url) => url
        ];
        
        // Special proxy list for FAA - some proxies work better for .gov sites
        const FAA_PROXIES = [
            (url) => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`,
            (url) => `https://thingproxy.freeboard.io/fetch/${url}`,
            (url) => `https://corsproxy.org/?${encodeURIComponent(url)}`,
            (url) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
            (url) => `https://corsproxy.io/?${encodeURIComponent(url)}`,
            (url) => `https://cors-anywhere.herokuapp.com/${url}`,
            (url) => url
        ];

        // Airport coordinates for NWS forecast lookup
        const AIRPORT_COORDS = {
            "KATL": { "lat": 33.6367, "lon": -84.4281 },
            "KLAX": { "lat": 33.9425, "lon": -118.4081 },
            "KORD": { "lat": 41.9742, "lon": -87.9073 },
            "KDFW": { "lat": 32.8998, "lon": -97.0403 },
            "KDEN": { "lat": 39.8561, "lon": -104.6737 },
            "KJFK": { "lat": 40.6398, "lon": -73.7789 },
            "KSFO": { "lat": 37.6213, "lon": -122.3790 },
            "KLAS": { "lat": 36.0840, "lon": -115.1537 },
            "KMCO": { "lat": 28.4312, "lon": -81.3081 },
            "KSEA": { "lat": 47.4502, "lon": -122.3088 },
            "KMIA": { "lat": 25.7959, "lon": -80.2870 },
            "KPHX": { "lat": 33.4373, "lon": -112.0078 },
            "KEWR": { "lat": 40.6895, "lon": -74.1745 },
            "KIAH": { "lat": 29.9902, "lon": -95.3368 },
            "KBOS": { "lat": 42.3656, "lon": -71.0096 },
            "KMSP": { "lat": 44.8848, "lon": -93.2223 },
            "KDTW": { "lat": 42.2124, "lon": -83.3534 },
            "KFLL": { "lat": 26.0726, "lon": -80.1527 },
            "KPHL": { "lat": 39.8729, "lon": -75.2437 },
            "KLGA": { "lat": 40.7772, "lon": -73.8726 },
            "KBWI": { "lat": 39.1754, "lon": -76.6683 },
            "KSLC": { "lat": 40.7884, "lon": -111.9778 },
            "KDCA": { "lat": 38.8521, "lon": -77.0377 },
            "KSAN": { "lat": 32.7336, "lon": -117.1897 },
            "KTPA": { "lat": 27.9755, "lon": -82.5332 },
            "KAUS": { "lat": 30.1975, "lon": -97.6664 },
            "KIAD": { "lat": 38.9531, "lon": -77.4565 },
            "KMDW": { "lat": 41.7868, "lon": -87.7522 },
            "KHNL": { "lat": 21.3187, "lon": -157.9225 },
            "KSTL": { "lat": 38.7487, "lon": -90.3700 },
            "KBNA": { "lat": 36.1263, "lon": -86.6774 },
            "KOAK": { "lat": 37.7213, "lon": -122.2208 },
            "KSMF": { "lat": 38.6954, "lon": -121.5908 },
            "KSJC": { "lat": 37.3626, "lon": -121.9291 },
            "KRDU": { "lat": 35.8776, "lon": -78.7875 },
            "KMCI": { "lat": 39.2976, "lon": -94.7139 },
            "KCLE": { "lat": 41.4117, "lon": -81.8498 },
            "KPIT": { "lat": 40.4915, "lon": -80.2329 },
            "KCLT": { "lat": 35.2140, "lon": -80.9431 },
            "KPDX": { "lat": 45.5898, "lon": -122.5951 },
            "KIND": { "lat": 39.7173, "lon": -86.2944 },
            "KCVG": { "lat": 39.0488, "lon": -84.6678 },
            "KMSY": { "lat": 29.9934, "lon": -90.2580 },
            "KSAT": { "lat": 29.5337, "lon": -98.4698 },
            "KMKE": { "lat": 42.9472, "lon": -87.8966 },
            "KBUF": { "lat": 42.9405, "lon": -78.7322 },
            "KPBI": { "lat": 26.6832, "lon": -80.0956 },
            "KABQ": { "lat": 35.0402, "lon": -106.6090 },
            "KONT": { "lat": 34.0560, "lon": -117.6012 },
            "KRSW": { "lat": 26.5362, "lon": -81.7552 },
            "KBUR": { "lat": 34.2007, "lon": -118.3585 },
            "KOMA": { "lat": 41.3032, "lon": -95.8941 },
            "KRIC": { "lat": 37.5052, "lon": -77.3197 },
            "KBDL": { "lat": 41.9389, "lon": -72.6832 },
            "KSNA": { "lat": 33.6757, "lon": -117.8682 },
            "KJAN": { "lat": 32.3112, "lon": -90.0759 },
            "KCHS": { "lat": 32.8986, "lon": -80.0405 },
            "KJAX": { "lat": 30.4941, "lon": -81.6879 },
            "KORF": { "lat": 36.8946, "lon": -76.2012 },
            "KANC": { "lat": 61.1744, "lon": -149.9964 },
            "KLIT": { "lat": 34.7294, "lon": -92.2243 },
            "KELP": { "lat": 31.8072, "lon": -106.3778 },
            "KTUS": { "lat": 32.1161, "lon": -110.9410 },
            "KOKC": { "lat": 35.3931, "lon": -97.6007 },
            "KTUL": { "lat": 36.1984, "lon": -95.8881 },
            "KGRR": { "lat": 42.8808, "lon": -85.5228 },
            "KDSM": { "lat": 41.5340, "lon": -93.6631 },
            "KDAY": { "lat": 39.9024, "lon": -84.2194 },
            "KSYR": { "lat": 43.1112, "lon": -76.1063 },
            "KPVD": { "lat": 41.7267, "lon": -71.4325 },
            "KALB": { "lat": 42.7483, "lon": -73.8017 },
            "KGSO": { "lat": 36.0978, "lon": -79.9373 },
            "KPWM": { "lat": 43.6462, "lon": -70.3093 },
            "KBTV": { "lat": 44.4720, "lon": -73.1533 },
            "KROC": { "lat": 43.1189, "lon": -77.6724 },
            "KBHM": { "lat": 33.5629, "lon": -86.7535 },
            "KLEX": { "lat": 38.0365, "lon": -84.6059 },
            "KSDF": { "lat": 38.1744, "lon": -85.7360 },
            "KCMH": { "lat": 39.9980, "lon": -82.8919 },
            "KCOS": { "lat": 38.8058, "lon": -104.7009 },
            "KBOI": { "lat": 43.5644, "lon": -116.2228 },
            "KFSD": { "lat": 43.5820, "lon": -96.7419 },
            "KICT": { "lat": 37.6499, "lon": -97.4331 },
            "KMSN": { "lat": 43.1399, "lon": -89.3375 },
            "KLBB": { "lat": 33.6636, "lon": -101.8228 },
            "KFAR": { "lat": 46.9207, "lon": -96.8158 },
            "KBIS": { "lat": 46.7727, "lon": -100.7468 },
            "KDLH": { "lat": 46.8421, "lon": -92.1936 },
            "KERI": { "lat": 42.0831, "lon": -80.1764 },
            "KBGR": { "lat": 44.8074, "lon": -68.8281 },
            "KAVL": { "lat": 35.4362, "lon": -82.5418 },
            "KMYR": { "lat": 33.6797, "lon": -78.9283 },
            "KSAV": { "lat": 32.1276, "lon": -81.2021 },
            "KPNS": { "lat": 30.4734, "lon": -87.1866 },
            "KFWA": { "lat": 40.9785, "lon": -85.1951 },
            "KLNK": { "lat": 40.8510, "lon": -96.7592 },
            "KSGF": { "lat": 37.2457, "lon": -93.3886 },
            "KXNA": { "lat": 36.2819, "lon": -94.3068 },
            "KCRP": { "lat": 27.7704, "lon": -97.5012 },
            "KABI": { "lat": 32.4113, "lon": -99.6819 },
            // Canadian Airports
            "CYYZ": { "lat": 43.6777, "lon": -79.6248 },
            "CYVR": { "lat": 49.1947, "lon": -123.1839 },
            "CYUL": { "lat": 45.4706, "lon": -73.7408 },
            "CYYC": { "lat": 51.1225, "lon": -114.0134 },
            "CYEG": { "lat": 53.3097, "lon": -113.5800 },
            "CYOW": { "lat": 45.3225, "lon": -75.6692 },
            "CYWG": { "lat": 49.9100, "lon": -97.2399 },
            "CYQB": { "lat": 46.7911, "lon": -71.3933 },
            "CYHZ": { "lat": 44.8808, "lon": -63.5086 },
            "CYYT": { "lat": 47.6186, "lon": -52.7519 }
        };
        
        // NWS Forecast data cache
        let nwsForecastData = {};
        let nwsForecastLoading = false;
        let nwsForecastLastFetch = 0;
        const NWS_CACHE_DURATION = 30 * 60 * 1000; // 30 minutes
        
        // Fetch NWS forecast for a single airport
        async function fetchNWSForecast(icao) {
            const coords = AIRPORT_COORDS[icao];
            if (!coords) return null;
            
            // Skip Canadian airports (NWS doesn't cover them)
            if (icao.startsWith('CY')) return null;
            
            try {
                // Step 1: Get the forecast URL from the points endpoint
                const pointsUrl = `https://api.weather.gov/points/${coords.lat},${coords.lon}`;
                const pointsResponse = await fetch(pointsUrl, {
                    headers: { 'User-Agent': 'AirportDeicingMonitor/1.0' }
                });
                
                if (!pointsResponse.ok) return null;
                const pointsData = await pointsResponse.json();
                
                const forecastUrl = pointsData.properties?.forecast;
                if (!forecastUrl) return null;
                
                // Step 2: Get the actual forecast
                const forecastResponse = await fetch(forecastUrl, {
                    headers: { 'User-Agent': 'AirportDeicingMonitor/1.0' }
                });
                
                if (!forecastResponse.ok) return null;
                const forecastData = await forecastResponse.json();
                
                // Parse the forecast periods to get high/low temps
                const periods = forecastData.properties?.periods || [];
                if (periods.length === 0) return null;
                
                // Get temps for next 24-48 hours
                let lowTemp = null;
                let highTemp = null;
                let lowPeriod = '';
                let highPeriod = '';
                
                // Look at first 4 periods (covers ~48 hours)
                for (let i = 0; i < Math.min(4, periods.length); i++) {
                    const period = periods[i];
                    const temp = period.temperature;
                    const name = period.name;
                    
                    if (name.toLowerCase().includes('night') || name.toLowerCase().includes('overnight')) {
                        if (lowTemp === null || temp < lowTemp) {
                            lowTemp = temp;
                            lowPeriod = name;
                        }
                    } else {
                        if (highTemp === null || temp > highTemp) {
                            highTemp = temp;
                            highPeriod = name;
                        }
                    }
                    
                    // Also track absolute min/max
                    if (lowTemp === null || temp < lowTemp) {
                        lowTemp = temp;
                        lowPeriod = name;
                    }
                    if (highTemp === null || temp > highTemp) {
                        highTemp = temp;
                        highPeriod = name;
                    }
                }
                
                return {
                    icao,
                    lowTempF: lowTemp,
                    highTempF: highTemp,
                    lowPeriod,
                    highPeriod,
                    lowTempC: lowTemp !== null ? Math.round((lowTemp - 32) * 5/9) : null,
                    highTempC: highTemp !== null ? Math.round((highTemp - 32) * 5/9) : null,
                    fetched: Date.now()
                };
            } catch (e) {
                console.log(`NWS forecast error for ${icao}:`, e.message);
                return null;
            }
        }
        
        // Fetch NWS forecasts for all US airports (in batches to be nice to the API)
        async function fetchAllNWSForecasts() {
            // Check cache - don't refetch if recent
            if (Date.now() - nwsForecastLastFetch < NWS_CACHE_DURATION && Object.keys(nwsForecastData).length > 0) {
                console.log('Using cached NWS forecast data');
                return;
            }
            
            if (nwsForecastLoading) return;
            nwsForecastLoading = true;
            
            console.log('Fetching NWS forecasts for US airports...');
            const usAirports = AIRPORTS.filter(icao => !icao.startsWith('CY') && AIRPORT_COORDS[icao]);
            
            // Fetch in batches of 10 with small delay between batches
            const batchSize = 10;
            const delayBetweenBatches = 500; // ms
            
            for (let i = 0; i < usAirports.length; i += batchSize) {
                const batch = usAirports.slice(i, i + batchSize);
                const promises = batch.map(icao => fetchNWSForecast(icao));
                const results = await Promise.all(promises);
                
                for (const result of results) {
                    if (result) {
                        nwsForecastData[result.icao] = result;
                    }
                }
                
                // Small delay between batches
                if (i + batchSize < usAirports.length) {
                    await new Promise(resolve => setTimeout(resolve, delayBetweenBatches));
                }
            }
            
            nwsForecastLastFetch = Date.now();
            nwsForecastLoading = false;
            console.log(`NWS forecasts loaded for ${Object.keys(nwsForecastData).length} airports`);
        }

        // Worldwide runway data - loaded from external JSON
        let RUNWAY_DATA = {};
        let IATA_TO_ICAO = {};
        let AIRPORT_INFO = {};  // Store city, name, elevation for all airports
        let runwayDataLoaded = false;
        
        // Load runway data from external JSON file
        async function loadRunwayData() {
            console.log('=== loadRunwayData() called ===');
            if (runwayDataLoaded) {
                console.log('Already loaded, skipping');
                return;
            }
            try {
                console.log('Attempting to fetch runway_data.json...');
                const response = await fetch('runway_data.json');
                console.log('Fetch response:', response.status, response.statusText, response.ok);
                
                if (response.ok) {
                    console.log('Response OK, parsing JSON...');
                    const data = await response.json();
                    console.log('JSON parsed, keys:', Object.keys(data));
                    
                    IATA_TO_ICAO = data.iata_to_icao || {};
                    console.log('IATA to ICAO mappings loaded:', Object.keys(IATA_TO_ICAO).length);
                    
                    // Convert the airport data to expected format
                    let airportCount = 0;
                    const airports = data.airports || {};
                    console.log('Processing airports object with', Object.keys(airports).length, 'entries');
                    
                    for (const [icao, airport] of Object.entries(airports)) {
                        RUNWAY_DATA[icao] = { 
                            runways: airport.runways || [],
                            elevation_ft: airport.elevation_ft
                        };
                        // Store airport info separately for quick lookup
                        AIRPORT_INFO[icao] = {
                            city: airport.city || '',
                            name: airport.name || '',
                            region: airport.region || '',
                            elevation_ft: airport.elevation_ft,
                            iata: airport.iata || ''
                        };
                        airportCount++;
                    }
                    runwayDataLoaded = true;
                    console.log(`&#x2714; Loaded runway data for ${airportCount} airports worldwide`);
                    console.log('RUNWAY_DATA now has', Object.keys(RUNWAY_DATA).length, 'entries');
                    console.log('Sample - KORD runways:', RUNWAY_DATA['KORD']?.runways?.length || 0);
                    console.log('Sample - KBUF runways:', RUNWAY_DATA['KBUF']?.runways?.length || 0);
                } else {
                    console.error('&#x2717; Failed to load runway data:', response.status, response.statusText);
                    console.log('Loading fallback data instead...');
                    loadFallbackRunwayData();
                }
            } catch (e) {
                console.error('&#x2717; Exception loading runway data:', e);
                console.error('Error name:', e.name);
                console.error('Error message:', e.message);
                console.log('Loading fallback runway data...');
                loadFallbackRunwayData();
            }
        }
        
        // Fallback runway data for top US airports (used if JSON fails to load)
        function loadFallbackRunwayData() {
            console.log('=== Loading FALLBACK runway data ===');
            // Basic runway data for top 20+ airports
            const fallbackData = {
                'KATL': { elevation_ft: 1026, runways: [
                    { le_ident: '08L', he_ident: '26R', length_ft: 9000, width_ft: 150, le_heading_degT: 90 },
                    { le_ident: '08R', he_ident: '26L', length_ft: 10000, width_ft: 150, le_heading_degT: 90 },
                    { le_ident: '09L', he_ident: '27R', length_ft: 12390, width_ft: 150, le_heading_degT: 90 },
                    { le_ident: '09R', he_ident: '27L', length_ft: 9000, width_ft: 150, le_heading_degT: 90 },
                    { le_ident: '10', he_ident: '28', length_ft: 9000, width_ft: 150, le_heading_degT: 100 }
                ]},
                'KLAX': { elevation_ft: 128, runways: [
                    { le_ident: '06L', he_ident: '24R', length_ft: 8926, width_ft: 150, le_heading_degT: 69 },
                    { le_ident: '06R', he_ident: '24L', length_ft: 10285, width_ft: 150, le_heading_degT: 69 },
                    { le_ident: '07L', he_ident: '25R', length_ft: 12091, width_ft: 150, le_heading_degT: 69 },
                    { le_ident: '07R', he_ident: '25L', length_ft: 11096, width_ft: 200, le_heading_degT: 69 }
                ]},
                'KORD': { elevation_ft: 672, runways: [
                    { le_ident: '04L', he_ident: '22R', length_ft: 7500, width_ft: 150, le_heading_degT: 41 },
                    { le_ident: '09L', he_ident: '27R', length_ft: 7967, width_ft: 150, le_heading_degT: 90 },
                    { le_ident: '09R', he_ident: '27L', length_ft: 9687, width_ft: 150, le_heading_degT: 90 },
                    { le_ident: '10L', he_ident: '28R', length_ft: 13000, width_ft: 200, le_heading_degT: 101 },
                    { le_ident: '10C', he_ident: '28C', length_ft: 10801, width_ft: 200, le_heading_degT: 101 },
                    { le_ident: '10R', he_ident: '28L', length_ft: 10141, width_ft: 150, le_heading_degT: 101 }
                ]},
                'KDFW': { elevation_ft: 607, runways: [
                    { le_ident: '13L', he_ident: '31R', length_ft: 9000, width_ft: 150, le_heading_degT: 130 },
                    { le_ident: '13R', he_ident: '31L', length_ft: 9301, width_ft: 200, le_heading_degT: 130 },
                    { le_ident: '17C', he_ident: '35C', length_ft: 13401, width_ft: 200, le_heading_degT: 175 },
                    { le_ident: '17L', he_ident: '35R', length_ft: 8500, width_ft: 150, le_heading_degT: 175 },
                    { le_ident: '17R', he_ident: '35L', length_ft: 13401, width_ft: 200, le_heading_degT: 175 },
                    { le_ident: '18L', he_ident: '36R', length_ft: 13400, width_ft: 200, le_heading_degT: 175 },
                    { le_ident: '18R', he_ident: '36L', length_ft: 13400, width_ft: 200, le_heading_degT: 175 }
                ]},
                'KDEN': { elevation_ft: 5431, runways: [
                    { le_ident: '07', he_ident: '25', length_ft: 12000, width_ft: 150, le_heading_degT: 70 },
                    { le_ident: '08', he_ident: '26', length_ft: 12000, width_ft: 150, le_heading_degT: 80 },
                    { le_ident: '16L', he_ident: '34R', length_ft: 12000, width_ft: 150, le_heading_degT: 160 },
                    { le_ident: '16R', he_ident: '34L', length_ft: 16000, width_ft: 200, le_heading_degT: 160 },
                    { le_ident: '17L', he_ident: '35R', length_ft: 12000, width_ft: 150, le_heading_degT: 170 },
                    { le_ident: '17R', he_ident: '35L', length_ft: 12000, width_ft: 150, le_heading_degT: 170 }
                ]},
                'KJFK': { elevation_ft: 13, runways: [
                    { le_ident: '04L', he_ident: '22R', length_ft: 12079, width_ft: 200, le_heading_degT: 31 },
                    { le_ident: '04R', he_ident: '22L', length_ft: 8400, width_ft: 200, le_heading_degT: 31 },
                    { le_ident: '13L', he_ident: '31R', length_ft: 10000, width_ft: 200, le_heading_degT: 130 },
                    { le_ident: '13R', he_ident: '31L', length_ft: 14511, width_ft: 200, le_heading_degT: 130 }
                ]},
                'KSFO': { elevation_ft: 13, runways: [
                    { le_ident: '01L', he_ident: '19R', length_ft: 7650, width_ft: 200, le_heading_degT: 10 },
                    { le_ident: '01R', he_ident: '19L', length_ft: 8648, width_ft: 200, le_heading_degT: 10 },
                    { le_ident: '10L', he_ident: '28R', length_ft: 11870, width_ft: 200, le_heading_degT: 100 },
                    { le_ident: '10R', he_ident: '28L', length_ft: 10602, width_ft: 200, le_heading_degT: 100 }
                ]},
                'KLAS': { elevation_ft: 2181, runways: [
                    { le_ident: '01L', he_ident: '19R', length_ft: 9775, width_ft: 150, le_heading_degT: 10 },
                    { le_ident: '01R', he_ident: '19L', length_ft: 8504, width_ft: 150, le_heading_degT: 10 },
                    { le_ident: '08L', he_ident: '26R', length_ft: 14510, width_ft: 150, le_heading_degT: 80 },
                    { le_ident: '08R', he_ident: '26L', length_ft: 10527, width_ft: 150, le_heading_degT: 80 }
                ]},
                'KMCO': { elevation_ft: 96, runways: [
                    { le_ident: '17L', he_ident: '35R', length_ft: 9000, width_ft: 150, le_heading_degT: 173 },
                    { le_ident: '17R', he_ident: '35L', length_ft: 10000, width_ft: 150, le_heading_degT: 173 },
                    { le_ident: '18L', he_ident: '36R', length_ft: 12005, width_ft: 200, le_heading_degT: 180 },
                    { le_ident: '18R', he_ident: '36L', length_ft: 12004, width_ft: 200, le_heading_degT: 180 }
                ]},
                'KSEA': { elevation_ft: 433, runways: [
                    { le_ident: '16L', he_ident: '34R', length_ft: 11901, width_ft: 200, le_heading_degT: 160 },
                    { le_ident: '16C', he_ident: '34C', length_ft: 9426, width_ft: 150, le_heading_degT: 160 },
                    { le_ident: '16R', he_ident: '34L', length_ft: 8500, width_ft: 150, le_heading_degT: 160 }
                ]},
                'KBUF': { elevation_ft: 728, runways: [
                    { le_ident: '05', he_ident: '23', length_ft: 8102, width_ft: 150, le_heading_degT: 50 },
                    { le_ident: '14', he_ident: '32', length_ft: 7161, width_ft: 150, le_heading_degT: 140 }
                ]},
                'KBOS': { elevation_ft: 20, runways: [
                    { le_ident: '04L', he_ident: '22R', length_ft: 7861, width_ft: 150, le_heading_degT: 39 },
                    { le_ident: '04R', he_ident: '22L', length_ft: 10006, width_ft: 150, le_heading_degT: 39 },
                    { le_ident: '09', he_ident: '27', length_ft: 7000, width_ft: 150, le_heading_degT: 86 },
                    { le_ident: '15R', he_ident: '33L', length_ft: 10083, width_ft: 150, le_heading_degT: 150 }
                ]},
                'KMSP': { elevation_ft: 841, runways: [
                    { le_ident: '04', he_ident: '22', length_ft: 11006, width_ft: 200, le_heading_degT: 40 },
                    { le_ident: '12L', he_ident: '30R', length_ft: 10000, width_ft: 200, le_heading_degT: 118 },
                    { le_ident: '12R', he_ident: '30L', length_ft: 8200, width_ft: 150, le_heading_degT: 118 },
                    { le_ident: '17', he_ident: '35', length_ft: 8000, width_ft: 150, le_heading_degT: 170 }
                ]},
                'KDTW': { elevation_ft: 645, runways: [
                    { le_ident: '03L', he_ident: '21R', length_ft: 10001, width_ft: 150, le_heading_degT: 26 },
                    { le_ident: '03R', he_ident: '21L', length_ft: 8501, width_ft: 200, le_heading_degT: 26 },
                    { le_ident: '04L', he_ident: '22R', length_ft: 12003, width_ft: 200, le_heading_degT: 36 },
                    { le_ident: '04R', he_ident: '22L', length_ft: 10000, width_ft: 200, le_heading_degT: 36 }
                ]},
                'KCLE': { elevation_ft: 791, runways: [
                    { le_ident: '06L', he_ident: '24R', length_ft: 9956, width_ft: 150, le_heading_degT: 62 },
                    { le_ident: '06R', he_ident: '24L', length_ft: 11000, width_ft: 150, le_heading_degT: 62 },
                    { le_ident: '10', he_ident: '28', length_ft: 6017, width_ft: 150, le_heading_degT: 100 }
                ]}
            };
            
            for (const [icao, data] of Object.entries(fallbackData)) {
                RUNWAY_DATA[icao] = data;
            }
            
            // Basic IATA mappings for top airports
            IATA_TO_ICAO = {
                'ATL': 'KATL', 'LAX': 'KLAX', 'ORD': 'KORD', 'DFW': 'KDFW', 'DEN': 'KDEN',
                'JFK': 'KJFK', 'SFO': 'KSFO', 'LAS': 'KLAS', 'MCO': 'KMCO', 'SEA': 'KSEA',
                'MIA': 'KMIA', 'PHX': 'KPHX', 'EWR': 'KEWR', 'IAH': 'KIAH', 'BOS': 'KBOS',
                'MSP': 'KMSP', 'DTW': 'KDTW', 'FLL': 'KFLL', 'PHL': 'KPHL', 'LGA': 'KLGA',
                'BUF': 'KBUF', 'CLE': 'KCLE'
            };
            
            console.log('&#x2714; Loaded fallback runway data for', Object.keys(fallbackData).length, 'airports');
            console.log('Fallback airports:', Object.keys(fallbackData).join(', '));
            runwayDataLoaded = true;
        }
        
        // Get airport display name - checks both hardcoded US names and worldwide data
        function getAirportName(icao) {
            // First check hardcoded US airport names (more user-friendly)
            if (AIRPORT_NAMES[icao]) return AIRPORT_NAMES[icao];
            
            // Then check worldwide data
            const info = AIRPORT_INFO[icao];
            if (info) {
                if (info.city && info.name) {
                    return `${info.city} - ${info.name}`;
                } else if (info.name) {
                    return info.name;
                } else if (info.city) {
                    return info.city;
                }
            }
            return icao;
        }
        
        // Get full airport info for display
        function getAirportInfo(icao) {
            return AIRPORT_INFO[icao] || null;
        }
        
        // Resolve IATA to ICAO code
        function resolveToICAO(code) {
            if (!code) return null;
            code = code.toUpperCase().trim();
            // If it's already a valid ICAO (4 letters starting with country prefix)
            if (/^[A-Z]{4}$/.test(code)) return code;
            // If it's a 3-letter IATA code, try to resolve
            if (/^[A-Z]{3}$/.test(code)) {
                return IATA_TO_ICAO[code] || null;
            }
            return null;
        }
        
        // Show runway map modal
        function showRunwayMap(icao, evt) {
            if (evt) evt.stopPropagation();
            console.log('showRunwayMap called for:', icao);
            
            const modal = document.getElementById('runwayModal');
            const title = document.getElementById('runwayModalTitle');
            const body = document.getElementById('runwayModalBody');
            
            if (!modal || !title || !body) {
                console.error('Modal elements not found!');
                return;
            }
            
            const airportName = getAirportName(icao);
            const info = getAirportInfo(icao);
            const iataDisplay = info?.iata ? ` (${info.iata})` : '';
            title.textContent = `${icao}${iataDisplay} - ${airportName}`;
            
            // Get wind data from global storage
            const windData = currentWindData[icao] || { direction: null, speed: null, gust: null, variable: false };
            console.log('Wind data for', icao, ':', windData);
            
            console.log('RUNWAY_DATA keys count:', Object.keys(RUNWAY_DATA).length);
            console.log('runwayDataLoaded:', runwayDataLoaded);
            
            const data = RUNWAY_DATA[icao];
            console.log('Data for', icao, ':', data);
            console.log('Has runways:', data?.runways?.length);
            
            if (data && data.runways && data.runways.length > 0) {
                console.log('Calling renderRunwayModal with', data.runways.length, 'runways');
                // Add elevation to data if from info
                if (info?.elevation_ft && !data.elevation_ft) {
                    data.elevation_ft = info.elevation_ft;
                }
                renderRunwayModal(icao, data, windData);
            } else {
                console.log('No runway data - showing fallback');
                console.log('  data exists:', !!data);
                console.log('  data.runways exists:', !!data?.runways);
                console.log('  data.runways.length:', data?.runways?.length);
                console.log('  runwayDataLoaded:', runwayDataLoaded);
                console.log('  RUNWAY_DATA keys:', Object.keys(RUNWAY_DATA).length);
                
                // No runway data - show just the acukwik image
                const diagramUrl = `https://acukwik.com/extimages/Listing-Images/${icao}.jpg`;
                
                let statusMsg = '';
                if (!runwayDataLoaded) {
                    statusMsg = 'Runway data is still loading...';
                } else if (Object.keys(RUNWAY_DATA).length === 0) {
                    statusMsg = 'Could not load runway database. Check console for errors.';
                } else if (!data) {
                    statusMsg = `Airport ${icao} not found in runway database.`;
                } else if (!data.runways || data.runways.length === 0) {
                    statusMsg = `No runway information available for ${icao}.`;
                }
                
                body.innerHTML = `
                    <div class="runway-diagram" style="background:#fff;padding:5px;border-radius:4px;">
                        <img src="${diagramUrl}" alt="${icao} Airport Diagram" 
                             style="max-width:100%;height:auto;display:block;margin:0 auto;"
                             onerror="this.parentElement.innerHTML='<div style=\\'color:#888;text-align:center;padding:40px;background:#1a1a2e;\\'>Diagram not available for ${icao}</div>'">
                    </div>
                    <div style="margin-top:12px;text-align:center;color:#888;font-size:11px;">
                        ${statusMsg}
                    </div>
                    <div style="margin-top:8px;text-align:center;color:#666;font-size:10px;">
                        RUNWAY_DATA entries: ${Object.keys(RUNWAY_DATA).length}
                    </div>
                    <a href="https://www.faa.gov/airports/runway_safety/diagrams/" target="_blank" class="runway-faa-link">
                        &#x1F50D; Search FAA Airport Diagrams
                    </a>
                `;
            }
            
            modal.classList.add('active');
        }
        
        // Render the runway modal content
        function renderRunwayModal(icao, data, windData) {
            const body = document.getElementById('runwayModalBody');
            
            console.log('renderRunwayModal called');
            console.log('  icao:', icao);
            console.log('  data:', data);
            console.log('  data.runways:', data?.runways);
            console.log('  data.runways.length:', data?.runways?.length);
            console.log('  windData:', windData);
            console.log('  windData.speed:', windData?.speed);
            console.log('  windData.direction:', windData?.direction);
            
            // Use acukwik diagram image
            const diagramUrl = `https://acukwik.com/extimages/Listing-Images/${icao}.jpg`;
            
            // Build runway list
            let listHtml = '';
            if (data.runways && data.runways.length > 0) {
                console.log('Building runway list for', data.runways.length, 'runways');
                listHtml = '<div class="runway-list" style="margin-top:12px;">';
                for (const rwy of data.runways) {
                    const length = rwy.length_ft ? `${Number(rwy.length_ft).toLocaleString()}ft` : 'N/A';
                    const width = rwy.width_ft ? `${rwy.width_ft}ft wide` : '';
                    const ident = [rwy.le_ident, rwy.he_ident].filter(Boolean).join('/') || 'N/A';
                    
                    listHtml += `
                        <div class="runway-item">
                            <span class="runway-ident">${ident}</span>
                            <span class="runway-dim">${length} x ${width}</span>
                        </div>
                    `;
                }
                listHtml += '</div>';
            } else {
                console.log('No runway data available for this airport');
                listHtml = `<div style="margin-top:12px;padding:10px;background:#252540;border-radius:6px;text-align:center;color:#888;font-size:11px;">
                    Runway details not available
                </div>`;
            }
            
            // Wind display with arrow - compact for side position
            let windDisplayHtml = '';
            if (windData && windData.speed !== null && windData.speed !== undefined) {
                if (windData.speed === 0) {
                    windDisplayHtml = `
                        <div style="text-align:center;padding:10px;background:#151525;border-radius:6px;">
                            <div style="color:#44ff44;font-size:14px;font-weight:bold;">CALM</div>
                            <div style="color:#888;font-size:10px;">No wind</div>
                        </div>`;
                } else {
                    // Wind arrow SVG
                    let windColor = windData.speed >= 30 ? '#ff4444' : windData.speed >= 20 ? '#ff8c00' : windData.speed >= 10 ? '#ffd700' : '#44ff44';
                    let arrowSvg = '';
                    
                    if (windData.variable) {
                        arrowSvg = `<svg width="70" height="70" viewBox="0 0 70 70">
                            <circle cx="35" cy="35" r="25" fill="none" stroke="${windColor}" stroke-width="3" stroke-dasharray="5,3"/>
                            <text x="35" y="39" fill="${windColor}" font-size="12" font-weight="bold" text-anchor="middle">VRB</text>
                        </svg>`;
                    } else if (windData.direction !== null) {
                        const flowDir = (windData.direction + 180) % 360;
                        const rad = flowDir * Math.PI / 180;
                        const dx = Math.sin(rad);
                        const dy = -Math.cos(rad);
                        const len = 22;
                        const cx = 35, cy = 35;
                        const x1 = cx - dx * len, y1 = cy - dy * len;
                        const x2 = cx + dx * len, y2 = cy + dy * len;
                        
                        arrowSvg = `<svg width="70" height="70" viewBox="0 0 70 70">
                            <circle cx="35" cy="35" r="30" fill="none" stroke="#333" stroke-width="1"/>
                            <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${windColor}" stroke-width="3" stroke-linecap="round"/>
                            <polygon points="${x2},${y2} ${x2 - dx*8 - dy*4},${y2 - dy*8 + dx*4} ${x2 - dx*8 + dy*4},${y2 - dy*8 - dx*4}" fill="${windColor}"/>
                            <text x="35" y="8" fill="#4a90d9" font-size="9" text-anchor="middle">N</text>
                        </svg>`;
                    }
                    
                    let windDir = windData.variable ? 'VRB' : `${String(windData.direction).padStart(3, '0')}&deg;`;
                    let windSpd = `${windData.speed}kt`;
                    if (windData.gust) windSpd += ` G${windData.gust}`;
                    
                    windDisplayHtml = `
                        <div style="text-align:center;padding:8px;background:#151525;border-radius:6px;">
                            <div style="color:#888;font-size:9px;margin-bottom:4px;">WIND</div>
                            ${arrowSvg}
                            <div style="color:${windColor};font-size:12px;font-weight:bold;">${windDir}</div>
                            <div style="color:${windColor};font-size:11px;">${windSpd}</div>
                        </div>`;
                }
            } else {
                // No wind data available - show placeholder
                windDisplayHtml = `
                    <div style="text-align:center;padding:10px;background:#151525;border-radius:6px;">
                        <div style="color:#888;font-size:12px;">WIND</div>
                        <div style="color:#666;font-size:10px;margin-top:4px;">No data</div>
                    </div>`;
            }
            
            // Wind components table
            let windComponentsHtml = '';
            if (windData && windData.speed !== null && windData.speed > 0 && !windData.variable && windData.direction !== null && data.runways && data.runways.length > 0) {
                const components = calculateWindComponents(data.runways, windData);
                
                windComponentsHtml = `
                    <div style="margin-top:12px;padding:10px;background:#151525;border-radius:6px;">
                        <div style="color:#888;font-size:10px;margin-bottom:6px;text-align:center;">WIND COMPONENTS BY RUNWAY</div>
                        <table style="width:100%;font-size:11px;border-collapse:collapse;">
                            <thead>
                                <tr style="color:#888;border-bottom:1px solid #333;">
                                    <th style="padding:4px;text-align:left;">RWY</th>
                                    <th style="padding:4px;text-align:right;">Head/Tail</th>
                                    <th style="padding:4px;text-align:right;">Crosswind</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${components.map(c => `
                                    <tr style="border-bottom:1px solid #252525;">
                                        <td style="padding:4px;color:#4a90d9;font-weight:bold;">${c.runway}</td>
                                        <td style="padding:4px;text-align:right;color:${c.headwind >= 0 ? '#44ff44' : '#ff6b6b'};">
                                            ${Math.abs(c.headwind)}kt ${c.headwind >= 0 ? 'HEAD' : 'TAIL'}
                                        </td>
                                        <td style="padding:4px;text-align:right;color:${Math.abs(c.crosswind) >= 15 ? '#ff8c00' : '#888'};">
                                            ${Math.abs(c.crosswind)}kt ${c.crosswind > 0 ? 'R' : c.crosswind < 0 ? 'L' : ''}
                                        </td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                        ${windData.gust ? `<div style="color:#ff8c00;font-size:10px;text-align:center;margin-top:6px;">Gusts to ${windData.gust}kt - components may be higher</div>` : ''}
                    </div>
                `;
            } else if (windData && windData.variable && windData.speed > 0) {
                windComponentsHtml = `
                    <div style="margin-top:12px;padding:10px;background:#151525;border-radius:6px;text-align:center;">
                        <div style="color:#888;font-size:10px;margin-bottom:4px;">WIND COMPONENTS</div>
                        <div style="color:#ffd700;font-size:12px;">Variable wind - components vary</div>
                    </div>
                `;
            }
            
            // Elevation
            let infoHtml = '';
            if (data.elevation_ft) {
                infoHtml = `<div style="text-align:center;color:#888;font-size:11px;margin-top:8px;">Elevation: ${data.elevation_ft}ft</div>`;
            }
            
            console.log('Setting body.innerHTML with:');
            console.log('  windDisplayHtml length:', windDisplayHtml.length);
            console.log('  windComponentsHtml length:', windComponentsHtml.length);
            console.log('  listHtml length:', listHtml.length);
            console.log('  infoHtml length:', infoHtml.length);
            
            body.innerHTML = `
                <div style="display:flex;gap:10px;align-items:flex-start;">
                    <div class="runway-diagram" style="background:#fff;padding:5px;border-radius:4px;flex:1;min-width:0;">
                        <img src="${diagramUrl}" alt="${icao} Airport Diagram" 
                             style="max-width:100%;height:auto;display:block;margin:0 auto;"
                             onerror="this.parentElement.innerHTML='<div style=\\'color:#888;text-align:center;padding:40px;background:#1a1a2e;\\'>Diagram not available for ${icao}</div>'">
                    </div>
                    <div style="flex-shrink:0;width:90px;">
                        ${windDisplayHtml}
                    </div>
                </div>
                ${windComponentsHtml}
                ${infoHtml}
                ${listHtml}
                <a href="https://www.faa.gov/airports/runway_safety/diagrams/" target="_blank" class="runway-faa-link">
                    &#x1F50D; View Official FAA Diagram
                </a>
            `;
            
            console.log('Modal body innerHTML set, length:', body.innerHTML.length);
        }
        
        // Calculate wind components for each runway direction
        function calculateWindComponents(runways, windData) {
            const results = [];
            const windDir = windData.direction; // True direction wind is FROM
            const windSpeed = windData.speed;
            
            for (const rwy of runways) {
                // Get runway heading (true)
                let heading = parseFloat(rwy.le_heading_degT);
                if (isNaN(heading) && rwy.le_ident) {
                    heading = parseInt(rwy.le_ident.replace(/[LRC]/g, '')) * 10;
                }
                if (isNaN(heading)) continue;
                
                // Calculate for low-end runway (le_ident)
                if (rwy.le_ident) {
                    const leHeading = heading;
                    const leComponents = getWindComponents(windDir, windSpeed, leHeading);
                    results.push({
                        runway: rwy.le_ident,
                        heading: leHeading,
                        headwind: leComponents.headwind,
                        crosswind: leComponents.crosswind
                    });
                }
                
                // Calculate for high-end runway (he_ident) - opposite direction
                if (rwy.he_ident) {
                    const heHeading = (heading + 180) % 360;
                    const heComponents = getWindComponents(windDir, windSpeed, heHeading);
                    results.push({
                        runway: rwy.he_ident,
                        heading: heHeading,
                        headwind: heComponents.headwind,
                        crosswind: heComponents.crosswind
                    });
                }
            }
            
            // Sort by headwind (best runways first - highest headwind)
            results.sort((a, b) => b.headwind - a.headwind);
            
            return results;
        }
        
        // Calculate headwind and crosswind components
        function getWindComponents(windDir, windSpeed, runwayHeading) {
            // Wind direction is where wind comes FROM
            // Runway heading is direction you face when landing
            // Angle difference: how far off the nose is the wind coming from
            const angleDiff = (windDir - runwayHeading) * Math.PI / 180;
            
            // Headwind component: positive = headwind, negative = tailwind
            // cos(0) = 1 = direct headwind
            // cos(180 deg) = -1 = direct tailwind
            const headwind = Math.round(windSpeed * Math.cos(angleDiff));
            
            // Crosswind component: positive = from right, negative = from left
            // sin(90 deg) = 1 = wind from right
            // sin(-90 deg) = -1 = wind from left
            const crosswind = Math.round(windSpeed * Math.sin(angleDiff));
            
            return { headwind, crosswind };
        }
        
        // Generate SVG runway diagram
        function generateRunwaySVG(runways, airportData, windData) {
            const width = 280;
            const height = 280;
            const padding = 45; // Padding for labels
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Check if runways have lat/long data
            const hasLatLon = runways.some(r => r.le_lat !== undefined && r.le_lon !== undefined);
            
            let svgContent = '';
            
            if (hasLatLon) {
                // Use precise lat/long projection
                // Find bounding box of all runway endpoints
                let minLat = Infinity, maxLat = -Infinity;
                let minLon = Infinity, maxLon = -Infinity;
                
                for (const rwy of runways) {
                    if (rwy.le_lat !== undefined) {
                        minLat = Math.min(minLat, rwy.le_lat, rwy.he_lat);
                        maxLat = Math.max(maxLat, rwy.le_lat, rwy.he_lat);
                        minLon = Math.min(minLon, rwy.le_lon, rwy.he_lon);
                        maxLon = Math.max(maxLon, rwy.le_lon, rwy.he_lon);
                    }
                }
                
                // Add 10% padding to bounding box
                const latRange = maxLat - minLat;
                const lonRange = maxLon - minLon;
                const latPad = latRange * 0.15;
                const lonPad = lonRange * 0.15;
                minLat -= latPad; maxLat += latPad;
                minLon -= lonPad; maxLon += lonPad;
                
                // Calculate scale to fit in SVG (accounting for padding)
                const drawWidth = width - 2 * padding;
                const drawHeight = height - 2 * padding;
                
                // Adjust for latitude distortion (cosine of latitude)
                const centerLat = (minLat + maxLat) / 2;
                const cosLat = Math.cos(centerLat * Math.PI / 180);
                const adjustedLonRange = (maxLon - minLon) * cosLat;
                const adjustedLatRange = maxLat - minLat;
                
                // Scale to fit while preserving aspect ratio
                const scaleX = drawWidth / adjustedLonRange;
                const scaleY = drawHeight / adjustedLatRange;
                const scale = Math.min(scaleX, scaleY);
                
                // Calculate center offset
                const usedWidth = adjustedLonRange * scale;
                const usedHeight = adjustedLatRange * scale;
                const offsetX = padding + (drawWidth - usedWidth) / 2;
                const offsetY = padding + (drawHeight - usedHeight) / 2;
                
                // Project lat/lon to SVG coordinates
                // North is up (higher lat = lower Y)
                const projectX = (lon) => offsetX + (lon - minLon) * cosLat * scale;
                const projectY = (lat) => offsetY + (maxLat - lat) * scale;
                
                // Draw each runway
                for (const rwy of runways) {
                    if (rwy.le_lat === undefined) continue;
                    
                    const leX = projectX(rwy.le_lon);
                    const leY = projectY(rwy.le_lat);
                    const heX = projectX(rwy.he_lon);
                    const heY = projectY(rwy.he_lat);
                    
                    // Calculate runway width in pixels (use a minimum)
                    const rwyLength = Math.sqrt((heX - leX) ** 2 + (heY - leY) ** 2);
                    const widthFt = parseFloat(rwy.width_ft) || 150;
                    const lengthFt = parseFloat(rwy.length_ft) || 9000;
                    const scaledWidth = Math.max((widthFt / lengthFt) * rwyLength * 0.8, 5);
                    
                    // Runway color
                    const rwyColor = rwy.closed === '1' ? '#8b0000' : '#3a3a3a';
                    const rwyStroke = rwy.closed === '1' ? '#ff0000' : '#555';
                    
                    // Draw runway as a thick line with rounded ends
                    svgContent += `
                        <line x1="${leX}" y1="${leY}" x2="${heX}" y2="${heY}" 
                            stroke="${rwyStroke}" stroke-width="${scaledWidth + 2}" stroke-linecap="round" fill="none" stroke-opacity="0.5"/>
                        <line x1="${leX}" y1="${leY}" x2="${heX}" y2="${heY}" 
                            stroke="${rwyColor}" stroke-width="${scaledWidth}" stroke-linecap="round"/>
                        <line x1="${leX}" y1="${leY}" x2="${heX}" y2="${heY}" 
                            stroke="#666" stroke-width="1" stroke-dasharray="8,6"/>
                    `;
                    
                    // Calculate direction vector for label placement
                    const dx = heX - leX;
                    const dy = heY - leY;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    const ux = dx / len;
                    const uy = dy / len;
                    
                    // Runway labels at ends
                    const labelOffset = 15;
                    const leIdent = rwy.le_ident || '';
                    const heIdent = rwy.he_ident || '';
                    
                    const leLabelX = leX - ux * labelOffset;
                    const leLabelY = leY - uy * labelOffset;
                    const heLabelX = heX + ux * labelOffset;
                    const heLabelY = heY + uy * labelOffset;
                    
                    if (leIdent) {
                        svgContent += `<text x="${leLabelX}" y="${leLabelY}" fill="#4a90d9" font-size="10" font-weight="bold" text-anchor="middle" dominant-baseline="middle">${leIdent}</text>`;
                    }
                    if (heIdent) {
                        svgContent += `<text x="${heLabelX}" y="${heLabelY}" fill="#4a90d9" font-size="10" font-weight="bold" text-anchor="middle" dominant-baseline="middle">${heIdent}</text>`;
                    }
                }
            } else {
                // Fallback: Use heading-based calculation (original method)
                
                // Find the longest runway for scaling
                let maxLength = 0;
                for (const rwy of runways) {
                    const len = parseFloat(rwy.length_ft) || 0;
                    if (len > maxLength) maxLength = len;
                }
                
                // Scale factor: fit longest runway in ~180px
                const scaleFactor = maxLength > 0 ? 180 / maxLength : 1;
                
                // Group runways by heading (within 15 degrees = same orientation)
                const groups = [];
                for (const rwy of runways) {
                    let heading = parseFloat(rwy.le_heading_degT);
                    if (isNaN(heading) && rwy.le_ident) {
                        heading = parseInt(rwy.le_ident.replace(/[LRC]/g, '')) * 10;
                    }
                    if (isNaN(heading)) heading = 0;
                    
                    const normalizedHeading = heading % 180;
                    
                    let foundGroup = null;
                    for (const g of groups) {
                        const diff = Math.abs(g.heading - normalizedHeading);
                        if (diff < 15 || diff > 165) {
                            foundGroup = g;
                            break;
                        }
                    }
                    
                    if (foundGroup) {
                        foundGroup.runways.push({ ...rwy, heading });
                    } else {
                        groups.push({ heading: normalizedHeading, runways: [{ ...rwy, heading }] });
                    }
                }
                
                // Draw each group of runways
                for (const group of groups) {
                    const numInGroup = group.runways.length;
                    
                    for (let i = 0; i < numInGroup; i++) {
                        const rwy = group.runways[i];
                        const length = parseFloat(rwy.length_ft) || 5000;
                        const widthFt = parseFloat(rwy.width_ft) || 150;
                        const heading = rwy.heading;
                        
                        const scaledLength = length * scaleFactor;
                        const scaledWidth = Math.max(widthFt * scaleFactor * 0.5, 6);
                        
                        const headingRad = heading * Math.PI / 180;
                        const dx = Math.sin(headingRad);
                        const dy = -Math.cos(headingRad);
                        
                        const perpDx = Math.cos(headingRad);
                        const perpDy = Math.sin(headingRad);
                        
                        let offsetX = 0, offsetY = 0;
                        if (numInGroup > 1) {
                            const spacing = 25;
                            const offset = (i - (numInGroup - 1) / 2) * spacing;
                            offsetX = perpDx * offset;
                            offsetY = perpDy * offset;
                        }
                        
                        const rwyX = centerX + offsetX;
                        const rwyY = centerY + offsetY;
                        
                        const heX = rwyX + dx * scaledLength / 2;
                        const heY = rwyY + dy * scaledLength / 2;
                        const leX = rwyX - dx * scaledLength / 2;
                        const leY = rwyY - dy * scaledLength / 2;
                        
                        const rwyColor = rwy.closed === '1' ? '#8b0000' : '#3a3a3a';
                        const rwyStroke = rwy.closed === '1' ? '#ff0000' : '#555';
                        
                        svgContent += `
                            <line x1="${leX}" y1="${leY}" x2="${heX}" y2="${heY}" 
                                stroke="${rwyStroke}" stroke-width="${scaledWidth + 2}" stroke-linecap="round" fill="none" stroke-opacity="0.5"/>
                            <line x1="${leX}" y1="${leY}" x2="${heX}" y2="${heY}" 
                                stroke="${rwyColor}" stroke-width="${scaledWidth}" stroke-linecap="round"/>
                            <line x1="${leX}" y1="${leY}" x2="${heX}" y2="${heY}" 
                                stroke="#666" stroke-width="1" stroke-dasharray="8,6"/>
                        `;
                        
                        const labelOffset = 18;
                        const leIdent = rwy.le_ident || '';
                        const heIdent = rwy.he_ident || '';
                        
                        const leLabelX = leX - dx * labelOffset;
                        const leLabelY = leY - dy * labelOffset;
                        const heLabelX = heX + dx * labelOffset;
                        const heLabelY = heY + dy * labelOffset;
                        
                        if (leIdent) {
                            svgContent += `<text x="${leLabelX}" y="${leLabelY}" fill="#4a90d9" font-size="11" font-weight="bold" text-anchor="middle" dominant-baseline="middle">${leIdent}</text>`;
                        }
                        if (heIdent) {
                            svgContent += `<text x="${heLabelX}" y="${heLabelY}" fill="#4a90d9" font-size="11" font-weight="bold" text-anchor="middle" dominant-baseline="middle">${heIdent}</text>`;
                        }
                    }
                }
            }
            
            // Add compass rose - North pointing UP
            svgContent += `
                <g transform="translate(${width - 25}, 25)">
                    <circle cx="0" cy="0" r="15" fill="none" stroke="#444" stroke-width="1"/>
                    <line x1="0" y1="0" x2="0" y2="-12" stroke="#4a90d9" stroke-width="2"/>
                    <polygon points="0,-15 -4,-8 4,-8" fill="#4a90d9"/>
                    <text x="0" y="-20" fill="#4a90d9" font-size="10" text-anchor="middle">N</text>
                </g>
            `;
            
            // Add wind vector if wind data is available
            if (windData && windData.speed !== null) {
                if (windData.speed === 0) {
                    // Calm wind indicator
                    svgContent += `
                        <rect x="5" y="5" width="80" height="55" fill="#0a1a0a" fill-opacity="0.8" stroke="#333" rx="4"/>
                        <text x="45" y="18" fill="#888" font-size="9" text-anchor="middle">WIND</text>
                        <text x="45" y="38" fill="#44ff44" font-size="14" font-weight="bold" text-anchor="middle">CALM</text>
                        <text x="45" y="52" fill="#888" font-size="9" text-anchor="middle">0kt</text>
                    `;
                } else {
                    svgContent += generateWindVector(centerX, centerY, windData, width, height);
                }
            }
            
            return `
                <svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
                    <rect width="100%" height="100%" fill="#0a1a0a"/>
                    ${svgContent}
                </svg>
            `;
        }
        
        // Generate wind vector overlay
        function generateWindVector(centerX, centerY, windData, svgWidth, svgHeight) {
            const { direction, speed, gust, variable } = windData;
            
            // Wind color based on speed
            let windColor;
            if (speed >= 30 || (gust && gust >= 35)) {
                windColor = '#ff4444'; // Red - severe
            } else if (speed >= 20 || (gust && gust >= 25)) {
                windColor = '#ff8c00'; // Orange - strong
            } else if (speed >= 10) {
                windColor = '#ffd700'; // Yellow - moderate
            } else {
                windColor = '#44ff44'; // Green - light
            }
            
            let svgContent = '';
            
            // Wind legend box background
            svgContent += `
                <rect x="5" y="5" width="80" height="75" fill="#0a1a0a" fill-opacity="0.9" stroke="#333" rx="4"/>
                <text x="45" y="18" fill="#888" font-size="9" text-anchor="middle">WIND</text>
            `;
            
            // Position wind arrow in legend box
            const windCenterX = 45;
            const windCenterY = 45;
            
            if (variable) {
                // Variable wind - show circular indicator
                svgContent += `
                    <circle cx="${windCenterX}" cy="${windCenterY}" r="18" fill="none" stroke="${windColor}" stroke-width="2" stroke-dasharray="5,3"/>
                    <text x="${windCenterX}" y="${windCenterY - 2}" fill="${windColor}" font-size="10" font-weight="bold" text-anchor="middle">VRB</text>
                    <text x="${windCenterX}" y="${windCenterY + 10}" fill="${windColor}" font-size="10" text-anchor="middle">${speed}kt</text>
                `;
            } else if (direction !== null) {
                // Wind direction: METAR says where wind comes FROM
                // Arrow shows where wind is GOING (flow direction) = direction + 180
                const flowDirection = (direction + 180) % 360;
                
                // Convert to our coordinate system: North=up(-Y), East=right(+X)
                const flowRad = flowDirection * Math.PI / 180;
                const dx = Math.sin(flowRad);
                const dy = -Math.cos(flowRad);
                
                // Arrow length based on speed
                const arrowLength = Math.min(25 + speed * 1.2, 55);
                
                // Arrow from tail to head (in flow direction)
                const tailX = windCenterX - dx * arrowLength / 2;
                const tailY = windCenterY - dy * arrowLength / 2;
                const headX = windCenterX + dx * arrowLength / 2;
                const headY = windCenterY + dy * arrowLength / 2;
                
                // Gust extension
                if (gust && gust > speed) {
                    const gustLength = Math.min(25 + gust * 1.2, 65);
                    const gustHeadX = windCenterX + dx * gustLength / 2;
                    const gustHeadY = windCenterY + dy * gustLength / 2;
                    svgContent += `
                        <line x1="${headX}" y1="${headY}" x2="${gustHeadX}" y2="${gustHeadY}" 
                            stroke="${windColor}" stroke-width="3" stroke-dasharray="3,2" opacity="0.6"/>
                    `;
                }
                
                // Main arrow shaft
                svgContent += `
                    <line x1="${tailX}" y1="${tailY}" x2="${headX}" y2="${headY}" 
                        stroke="${windColor}" stroke-width="3" stroke-linecap="round"/>
                `;
                
                // Arrowhead
                const headSize = 8;
                const perpDx = Math.cos(flowRad);
                const perpDy = Math.sin(flowRad);
                svgContent += `
                    <polygon points="${headX},${headY} ${headX - dx*headSize - perpDx*4},${headY - dy*headSize - perpDy*4} ${headX - dx*headSize + perpDx*4},${headY - dy*headSize + perpDy*4}" 
                        fill="${windColor}"/>
                `;
                
                // Wind barbs on the tail side
                let remainingSpeed = speed;
                let barbPos = 0.15;
                while (remainingSpeed >= 5 && barbPos < 0.5) {
                    const posX = tailX + (headX - tailX) * barbPos;
                    const posY = tailY + (headY - tailY) * barbPos;
                    const barbLen = remainingSpeed >= 10 ? 7 : 4;
                    
                    svgContent += `
                        <line x1="${posX}" y1="${posY}" x2="${posX + perpDx*barbLen}" y2="${posY + perpDy*barbLen}" 
                            stroke="${windColor}" stroke-width="2" stroke-linecap="round"/>
                    `;
                    remainingSpeed -= (remainingSpeed >= 10) ? 10 : 5;
                    barbPos += 0.12;
                }
                
                // Speed and direction labels
                let speedText = gust ? `${speed}G${gust}` : `${speed}kt`;
                const dirText = `${String(direction).padStart(3, '0')}&deg;`;
                
                svgContent += `
                    <text x="${windCenterX}" y="70" fill="${windColor}" font-size="10" font-weight="bold" text-anchor="middle">${speedText}</text>
                    <text x="${windCenterX}" y="80" fill="#666" font-size="8" text-anchor="middle">from ${dirText}</text>
                `;
            }
            
            return svgContent;
        }
        
        // Format surface type
        function formatSurface(surface) {
            if (!surface) return 'Unknown';
            // Common surface abbreviations
            const abbrevs = {
                'ASP': 'Asphalt',
                'CON': 'Concrete',
                'ASPH': 'Asphalt',
                'CONC': 'Concrete',
                'GRS': 'Grass',
                'TURF': 'Turf',
                'GVL': 'Gravel',
                'DIRT': 'Dirt'
            };
            
            const upper = surface.toUpperCase();
            for (const [abbr, full] of Object.entries(abbrevs)) {
                if (upper.includes(abbr)) return full;
            }
            
            // Clean up the surface string
            return surface.split('-')[0].split(' - ')[0].trim();
        }
        
        // Close runway modal
        function closeRunwayModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('runwayModal').classList.remove('active');
        }
        
        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeRunwayModal();
                closeSettingsModal();
            }
        });

        // Airport settings - stored in localStorage
        let excludedAirports = JSON.parse(localStorage.getItem('deicingMonitorExcluded') || '[]');
        
        // Major airline hubs - organized geographically East to West
        const MAJOR_HUBS = {
            'Northeast': ['KBOS', 'KJFK', 'KLGA', 'KEWR', 'KPHL', 'KDCA', 'KIAD'],
            'Southeast': ['KATL', 'KMIA', 'KMCO'],
            'Midwest': ['KORD', 'KDTW', 'KMSP'],
            'Southwest': ['KDFW', 'KLAS'],
            'West Coast': ['KLAX', 'KSFO', 'KSEA']
        };
        
        // Flat list of all hub ICAOs
        const ALL_HUBS = Object.values(MAJOR_HUBS).flat();
        
        // My Stations - Hubs + additional key airports, organized geographically
        const MY_STATIONS = {
            'Northeast': ['KBOS', 'KJFK', 'KLGA', 'KEWR', 'KPHL', 'KDCA', 'KIAD'],
            'Southeast': ['KATL', 'KRDU', 'KMIA', 'KFLL', 'KPBI', 'KMCO', 'KTPA'],
            'Midwest': ['KORD', 'KDTW', 'KMSP'],
            'South Central': ['KDFW', 'KAUS'],
            'Mountain': ['KSLC', 'KLAS'],
            'West Coast': ['KLAX', 'KSFO', 'KSEA']
        };
        
        // Flat list of all my stations
        const ALL_MY_STATIONS = Object.values(MY_STATIONS).flat();
        
        // Get effective airports list (excluding user-disabled ones)
        function getEnabledAirports() {
            return AIRPORTS.filter(icao => !excludedAirports.includes(icao));
        }
        
        // Check if an airport is enabled
        function isAirportEnabled(icao) {
            return !excludedAirports.includes(icao);
        }
        
        // Select only hub airports
        function selectHubsOnly() {
            const checkboxes = document.querySelectorAll('#settingsModalBody input[type="checkbox"]');
            checkboxes.forEach(cb => {
                cb.checked = ALL_HUBS.includes(cb.value);
            });
            updateAirportCount();
        }
        
        // Add hub airports to current selection
        function addHubsToSelection() {
            ALL_HUBS.forEach(icao => {
                const cb = document.querySelector(`#settingsModalBody input[value="${icao}"]`);
                if (cb) cb.checked = true;
            });
            updateAirportCount();
        }
        
        // Select only my stations
        function selectMyStationsOnly() {
            const checkboxes = document.querySelectorAll('#settingsModalBody input[type="checkbox"]');
            checkboxes.forEach(cb => {
                cb.checked = ALL_MY_STATIONS.includes(cb.value);
            });
            updateAirportCount();
        }
        
        // Open settings modal
        function openAirportSettings() {
            const modal = document.getElementById('settingsModal');
            const body = document.getElementById('settingsModalBody');
            
            let html = '';
            
            // Major Hubs section first
            html += `
                <div class="settings-region-group" data-region="hubs" style="border: 2px solid #4a90d9; background: #1a2a4a;">
                    <div class="settings-region-header">
                        <div class="settings-region-title" style="color: #4a90d9; font-size: 15px;"> Major Airline Hubs (${ALL_HUBS.length})</div>
                        <div class="settings-region-actions">
                            <button onclick="selectHubsOnly()" style="background:#4a90d9;color:white;border-color:#4a90d9;">Hubs Only</button>
                            <button onclick="addHubsToSelection()">+ Add Hubs</button>
                        </div>
                    </div>
            `;
            
            // Show hubs organized by sub-region
            for (const [subRegion, airports] of Object.entries(MAJOR_HUBS)) {
                html += `<div style="margin-bottom: 8px;"><div style="color: #888; font-size: 10px; margin-bottom: 4px; text-transform: uppercase;">${subRegion}</div><div class="settings-airport-grid">`;
                
                for (const icao of airports) {
                    const name = AIRPORT_NAMES[icao] || icao;
                    const checked = isAirportEnabled(icao) ? 'checked' : '';
                    html += `
                        <label class="settings-airport-item" style="background: #253550;">
                            <input type="checkbox" value="${icao}" ${checked} onchange="updateAirportCount()">
                            <span class="icao">${icao}</span>
                            <span class="name">${name}</span>
                        </label>
                    `;
                }
                html += `</div></div>`;
            }
            html += `</div>`;
            
            // My Stations section - extended hub list
            html += `
                <div class="settings-region-group" data-region="mystations" style="border: 2px solid #27ae60; background: #1a3a2a;">
                    <div class="settings-region-header">
                        <div class="settings-region-title" style="color: #27ae60; font-size: 15px;"> My Stations (${ALL_MY_STATIONS.length})</div>
                        <div class="settings-region-actions">
                            <button onclick="selectMyStationsOnly()" style="background:#27ae60;color:white;border-color:#27ae60;">My Stations Only</button>
                        </div>
                    </div>
            `;
            
            // Show my stations organized by sub-region
            for (const [subRegion, airports] of Object.entries(MY_STATIONS)) {
                html += `<div style="margin-bottom: 8px;"><div style="color: #888; font-size: 10px; margin-bottom: 4px; text-transform: uppercase;">${subRegion}</div><div class="settings-airport-grid">`;
                
                for (const icao of airports) {
                    const name = AIRPORT_NAMES[icao] || icao;
                    const checked = isAirportEnabled(icao) ? 'checked' : '';
                    const isHub = ALL_HUBS.includes(icao);
                    html += `
                        <label class="settings-airport-item" style="background: ${isHub ? '#253550' : '#1a4a3a'};">
                            <input type="checkbox" value="${icao}" ${checked} onchange="updateAirportCount()">
                            <span class="icao">${icao}</span>
                            <span class="name">${name}</span>
                        </label>
                    `;
                }
                html += `</div></div>`;
            }
            html += `</div>`;
            
            // Divider
            html += `<div style="border-top: 1px solid #333; margin: 15px 0; padding-top: 10px; text-align: center; color: #666; font-size: 11px;">All 110 Airports by Region</div>`;
            
            // Group airports by region
            const regionNames = {
                northeast: ' Northeast',
                midwest: ' Midwest', 
                south: ' South',
                west: ' West',
                canada: ' Canada'
            };
            
            for (const [region, title] of Object.entries(regionNames)) {
                const regionAirports = AIRPORT_REGIONS[region] || [];
                
                html += `
                    <div class="settings-region-group" data-region="${region}">
                        <div class="settings-region-header">
                            <div class="settings-region-title">${title} (${regionAirports.length})</div>
                            <div class="settings-region-actions">
                                <button onclick="selectRegion('${region}', true)">All</button>
                                <button onclick="selectRegion('${region}', false)">None</button>
                            </div>
                        </div>
                        <div class="settings-airport-grid">
                `;
                
                for (const icao of regionAirports) {
                    const name = AIRPORT_NAMES[icao] || icao;
                    const checked = isAirportEnabled(icao) ? 'checked' : '';
                    const isHub = ALL_HUBS.includes(icao);
                    const isMyStation = ALL_MY_STATIONS.includes(icao);
                    let borderStyle = '';
                    if (isHub) borderStyle = 'border-left: 2px solid #4a90d9;';
                    else if (isMyStation) borderStyle = 'border-left: 2px solid #27ae60;';
                    html += `
                        <label class="settings-airport-item" ${borderStyle ? `style="${borderStyle}"` : ''}>
                            <input type="checkbox" value="${icao}" ${checked} onchange="updateAirportCount()">
                            <span class="icao">${icao}</span>
                            <span class="name">${name}</span>
                        </label>
                    `;
                }
                
                html += `
                        </div>
                    </div>
                `;
            }
            
            body.innerHTML = html;
            updateAirportCount();
            modal.classList.add('active');
        }
        
        // Close settings modal
        function closeSettingsModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('settingsModal').classList.remove('active');
        }
        
        // Select/deselect all airports in a region
        function selectRegion(region, select) {
            const regionGroup = document.querySelector(`.settings-region-group[data-region="${region}"]`);
            if (!regionGroup) return;
            
            const checkboxes = regionGroup.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = select);
            updateAirportCount();
        }
        
        // Update selected airport count
        function updateAirportCount() {
            const checkboxes = document.querySelectorAll('#settingsModalBody input[type="checkbox"]');
            const checked = Array.from(checkboxes).filter(cb => cb.checked).length;
            document.getElementById('selectedAirportCount').textContent = checked;
        }
        
        // Save airport settings
        function saveAirportSettings() {
            const checkboxes = document.querySelectorAll('#settingsModalBody input[type="checkbox"]');
            excludedAirports = [];
            
            checkboxes.forEach(cb => {
                if (!cb.checked) {
                    excludedAirports.push(cb.value);
                }
            });
            
            localStorage.setItem('deicingMonitorExcluded', JSON.stringify(excludedAirports));
            closeSettingsModal();
            
            // Update subtitle and refresh data
            updateSubtitle();
            fetchData();
        }
        
        // Reset all airports to enabled
        function resetAirportSettings() {
            const checkboxes = document.querySelectorAll('#settingsModalBody input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = true);
            updateAirportCount();
        }
        
        // Update subtitle based on enabled airports
        function updateSubtitle() {
            const enabled = AIRPORTS.length - excludedAirports.length;
            const subtitleEl = document.getElementById('subtitleText');
            if (subtitleEl) {
                if (excludedAirports.length === 0) {
                    subtitleEl.innerHTML = 'Top 110 US + Canadian Airports &bull; Search Any Airport Worldwide';
                } else {
                    subtitleEl.innerHTML = `<span style="color:#f39c12;">Monitoring ${enabled} of 110 Airports</span> &bull; <span style="cursor:pointer;text-decoration:underline;" onclick="openAirportSettings()">Customize</span>`;
                }
            }
        }

        function parseMetar(metar) {
            if (!metar || metar.length < 10) return null;

            const result = {
                raw: metar,
                icao: null,
                temp_c: null,
                dewpoint_c: null,
                dewpoint_spread: null,
                altimeter: null,
                weather: [],
                rmk_weather: [],
                weather_intensity: {},
                visibility: 10,
                visibility_text: '',
                ceiling: null,
                ceiling_text: '',
                cloud_layers: [],
                flight_rules: 'VFR',
                frozen_precip: false,
                rmk_frozen_precip: false,
                has_precip: false,
                has_moisture: false,
                obs_time: null,
                wind_dir: null,
                wind_speed: null,
                wind_gust: null,
                wind_variable: false,
                remarks: ''
            };

            const icaoMatch = metar.match(/\b([A-Z]{4})\b/);
            if (icaoMatch) result.icao = icaoMatch[1];
            else return null;

            // Extract observation time (format: 031852Z = day 03, 18:52 UTC)
            const timeMatch = metar.match(/\b(\d{2})(\d{2})(\d{2})Z\b/);
            if (timeMatch) {
                const day = parseInt(timeMatch[1]);
                const hour = parseInt(timeMatch[2]);
                const min = parseInt(timeMatch[3]);
                const now = new Date();
                const obsDate = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), day, hour, min));
                // Handle month rollover
                if (obsDate > now) {
                    obsDate.setUTCMonth(obsDate.getUTCMonth() - 1);
                }
                result.obs_time = obsDate;
            }

            // Extract wind data (format: 27015G25KT or VRB05KT)
            const windMatch = metar.match(/\b(VRB|\d{3})(\d{2,3})(G(\d{2,3}))?KT\b/);
            if (windMatch) {
                if (windMatch[1] === 'VRB') {
                    result.wind_variable = true;
                    result.wind_dir = 'VRB';
                } else {
                    result.wind_dir = parseInt(windMatch[1]);
                }
                result.wind_speed = parseInt(windMatch[2]);
                if (windMatch[4]) {
                    result.wind_gust = parseInt(windMatch[4]);
                }
            }

            const tempMatch = metar.match(/\s(M?\d{2})\/(M?\d{2})\s/);
            if (tempMatch) {
                const tempStr = tempMatch[1];
                const dewStr = tempMatch[2];
                result.temp_c = tempStr.startsWith('M') ? -parseInt(tempStr.slice(1)) : parseInt(tempStr);
                result.dewpoint_c = dewStr.startsWith('M') ? -parseInt(dewStr.slice(1)) : parseInt(dewStr);
                result.dewpoint_spread = result.temp_c - result.dewpoint_c;
            }
            
            // Parse altimeter (pressure) - format: A2992 or Q1013
            const altMatch = metar.match(/\b(A\d{4}|Q\d{4})\b/);
            if (altMatch) {
                const altStr = altMatch[1];
                if (altStr.startsWith('A')) {
                    result.altimeter = parseFloat(altStr.slice(1)) / 100; // inHg
                } else {
                    result.altimeter = parseInt(altStr.slice(1)); // hPa
                }
            }
            
            // Extract remarks section first
            const rmkMatch = metar.match(/\sRMK\s(.+)$/);
            if (rmkMatch) {
                result.remarks = rmkMatch[1];
            }
            
            // Split METAR into main body (before RMK) and remarks
            const rmkIndex = metar.indexOf(' RMK ');
            const mainBody = rmkIndex > 0 ? metar.substring(0, rmkIndex) : metar;
            const rmkSection = rmkIndex > 0 ? metar.substring(rmkIndex) : '';

            // Parse visibility with text (from main body)
            const visMatch = mainBody.match(/\s(\d+)\s?SM\b/);
            const visFracMatch = mainBody.match(/\s(\d+)?\s?(\d\/\d+)\s?SM\b/);
            const visP6Match = mainBody.match(/\bP6SM\b/);
            
            if (visP6Match) {
                result.visibility = 7;
                result.visibility_text = 'P6SM';
            } else if (visFracMatch) {
                const whole = visFracMatch[1] ? parseInt(visFracMatch[1]) : 0;
                const frac = visFracMatch[2];
                const [num, den] = frac.split('/').map(Number);
                result.visibility = whole + (num / den);
                result.visibility_text = visFracMatch[0].trim();
            } else if (visMatch) {
                result.visibility = parseInt(visMatch[1]);
                result.visibility_text = visMatch[1] + 'SM';
            }

            // Parse weather from MAIN BODY only (not remarks)
            // Match patterns like: +SN, -SN, SN, +FZRA, -TSRA, etc.
            const wxPattern = /\s(\+|-|VC)?((TS|SH|FZ|DR|BL|MI|PR|BC|RE)*)?(DZ|RA|SN|SG|IC|PL|GR|GS|UP|BR|FG|FU|VA|DU|SA|HZ|PY|PO|SQ|FC|SS|DS)\b/g;
            const wxMatches = mainBody.matchAll(wxPattern);
            
            for (const match of wxMatches) {
                const intensity = match[1] || ''; // +, -, or empty
                const descriptor = match[2] || ''; // TS, SH, FZ, DR, BL, etc.
                const precip = match[4]; // The main weather type
                
                // Build the full weather code
                let wxCode = descriptor + precip;
                
                // Store intensity separately
                result.weather_intensity[wxCode] = intensity === '+' ? 'heavy' : intensity === '-' ? 'light' : 'moderate';
                
                // Add to weather array with intensity for display
                const displayCode = intensity + wxCode;
                if (!result.weather.includes(displayCode) && !result.weather.includes(wxCode)) {
                    result.weather.push(displayCode);
                }
                
                // Check for precipitation
                if (['DZ', 'RA', 'SN', 'SG', 'IC', 'PL', 'GR', 'GS', 'UP'].includes(precip)) {
                    result.has_precip = true;
                }
                
                // Check for frozen precip
                if (['SN', 'SG', 'IC', 'PL', 'GR', 'GS'].includes(precip) || 
                    (descriptor.includes('FZ') && ['DZ', 'RA', 'FG'].includes(precip))) {
                    result.frozen_precip = true;
                }
                
                // Check for moisture
                if (['BR', 'FG'].includes(precip)) {
                    result.has_moisture = true;
                }
            }
            
            // Parse weather from REMARKS section (for display as "RMK: xxx")
            // RMK weather is less operationally significant - track separately
            if (rmkSection) {
                const rmkWxMatches = rmkSection.matchAll(wxPattern);
                for (const match of rmkWxMatches) {
                    const intensity = match[1] || '';
                    const descriptor = match[2] || '';
                    const precip = match[4];
                    const displayCode = intensity + descriptor + precip;
                    
                    if (!result.rmk_weather.includes(displayCode)) {
                        result.rmk_weather.push(displayCode);
                    }
                    
                    // Track frozen precip in remarks separately (less significant than main body)
                    if (['SN', 'SG', 'IC', 'PL', 'GR', 'GS'].includes(precip) || 
                        (descriptor.includes('FZ') && ['DZ', 'RA', 'FG'].includes(precip))) {
                        result.rmk_frozen_precip = true;
                    }
                }
            }
            
            // Fallback: also check for simple codes that might be missed in main body
            // Use regex with space/intensity prefix to avoid matching airport codes (e.g., KMSN matching SN)
            for (const code of FROZEN_PRECIP) {
                const codeRegex = new RegExp(`\\s[-+]?${code}\\b`);
                if (codeRegex.test(mainBody) && !result.weather.some(w => w.includes(code))) {
                    result.weather.push(code);
                    result.frozen_precip = true;
                    result.has_precip = true;
                }
            }

            // Parse cloud layers (from main body)
            const cloudPattern = /(SKC|CLR|FEW|SCT|BKN|OVC|VV)(\d{3})/g;
            const cloudMatches = mainBody.matchAll(cloudPattern);
            for (const match of cloudMatches) {
                const type = match[1];
                const alt = parseInt(match[2]) * 100;
                const text = match[1] + match[2];
                result.cloud_layers.push({ type, altitude: alt, text });
                
                // Track ceiling (BKN, OVC, or VV)
                if ((type === 'BKN' || type === 'OVC' || type === 'VV') && 
                    (result.ceiling === null || alt < result.ceiling)) {
                    result.ceiling = alt;
                    result.ceiling_text = text;
                }
            }

            const vis = result.visibility;
            const ceil = result.ceiling;
            if ((ceil !== null && ceil < 500) || vis < 1) result.flight_rules = 'LIFR';
            else if ((ceil !== null && ceil < 1000) || vis < 3) result.flight_rules = 'IFR';
            else if ((ceil !== null && ceil < 3000) || vis < 5) result.flight_rules = 'MVFR';

            return result;
        }

        function categorize(parsed) {
            if (parsed.temp_c === null) return 'unknown';
            
            const temp = parsed.temp_c;
            
            // Active: frozen precip in MAIN BODY of METAR (not just remarks)
            if (temp <= 0 && parsed.frozen_precip) return 'active';
            // Check for freezing rain/drizzle in main body with any intensity prefix
            if (parsed.weather.some(wx => wx.includes('FZRA') || wx.includes('FZDZ'))) return 'active';
            
            // Residual: frozen precip only in RMK section, OR recent history had frozen
            // RMK weather (like DRSN) is less significant - indicates nearby/peripheral conditions
            if (temp <= 3 && !parsed.frozen_precip && (parsed.had_recent_frozen || parsed.rmk_frozen_precip)) return 'residual';
            
            if (temp <= 0 && parsed.has_precip) return 'likely';
            if (temp <= 0 && parsed.has_moisture) return 'likely';
            if (temp <= 0) return 'possible';
            if (temp <= 3 && parsed.has_precip) return 'marginal';
            return 'none';
        }
        
        function checkRecentFrozen(history) {
            if (!history || history.length < 2) return { hadFrozen: false, lastFrozenTime: null, frozenTypes: [] };
            
            // Skip the first (current) observation, check the rest
            const pastObs = history.slice(1);
            const frozenTypes = new Set();
            let lastFrozenTime = null;
            
            for (const obs of pastObs) {
                for (const wx of obs.weather) {
                    // Strip intensity prefix (+/-) and check if it contains any frozen precip code
                    const stripped = wx.replace(/^[-+]/, '');
                    for (const code of FROZEN_PRECIP) {
                        if (stripped === code || stripped.includes(code)) {
                            frozenTypes.add(code);
                            if (!lastFrozenTime && obs.obs_time) {
                                lastFrozenTime = obs.obs_time;
                            }
                        }
                    }
                }
            }
            
            return {
                hadFrozen: frozenTypes.size > 0,
                lastFrozenTime: lastFrozenTime,
                frozenTypes: Array.from(frozenTypes)
            };
        }

        // Format weather display with ceiling and RMK weather
        function formatWeatherDisplay(apt, includeCeiling = true) {
            const parts = [];
            
            // Add ceiling if exists and requested (default true for backward compatibility)
            if (includeCeiling !== false && apt.ceiling_text) {
                parts.push(apt.ceiling_text);
            }
            
            // Add main body weather
            if (apt.weather && apt.weather.length > 0) {
                parts.push(...apt.weather);
            }
            
            // Add RMK weather with prefix
            if (apt.rmk_weather && apt.rmk_weather.length > 0) {
                parts.push('RMK:' + apt.rmk_weather.join(' '));
            }
            
            return parts.length > 0 ? parts.join(' ') : '&mdash;';
        }
        
        // Format weather for history rows (no ceiling - shown separately)
        function formatHistoryWeather(h) {
            const parts = [];
            if (h.weather && h.weather.length > 0) {
                parts.push(...h.weather);
            }
            if (h.rmk_weather && h.rmk_weather.length > 0) {
                parts.push('RMK:' + h.rmk_weather.join(' '));
            }
            return parts.length > 0 ? parts.join(' ') : '&mdash;';
        }

        function getLocalTime(icao) {
            const tz = AIRPORT_TIMEZONES[icao];
            if (!tz) return null;
            
            try {
                const now = new Date();
                const localTime = new Date(now.toLocaleString('en-US', { timeZone: tz }));
                return localTime;
            } catch (e) {
                return null;
            }
        }
        
        // Parse local time string like "11:00 am EST" or Zulu "0459Z" and convert to both formats
        function parseLocalTimeToZulu(timeStr) {
            if (!timeStr) return null;
            
            console.log('parseLocalTimeToZulu input:', timeStr);
            
            // Handle 4-digit Zulu format (e.g., "0459" or "0459Z" or "1829")
            const zuluMatch4 = timeStr.match(/^(\d{4})Z?$/);
            if (zuluMatch4) {
                const hours = parseInt(zuluMatch4[1].substring(0, 2));
                const mins = zuluMatch4[1].substring(2, 4);
                const zuluStr = `${String(hours).padStart(2, '0')}${mins}Z`;
                
                // Convert to EST/EDT local
                const now = new Date();
                const isDST = now.toLocaleString('en-US', {timeZone: 'America/New_York', timeZoneName: 'short'}).includes('EDT');
                const offset = isDST ? 4 : 5;
                let localHours = hours - offset;
                if (localHours < 0) localHours += 24;
                const ampm = localHours >= 12 ? 'pm' : 'am';
                let displayHours = localHours > 12 ? localHours - 12 : (localHours === 0 ? 12 : localHours);
                const localStr = `${displayHours}:${mins} ${ampm} ${isDST ? 'EDT' : 'EST'}`;
                console.log('Parsed 4-digit Zulu:', { zulu: zuluStr, local: localStr });
                return { zulu: zuluStr, local: localStr, combined: `${zuluStr} (${localStr})` };
            }
            
            // Handle HH:MMZ format (e.g., "16:00Z")
            const zuluMatchColon = timeStr.match(/(\d{1,2}):(\d{2})Z/i);
            if (zuluMatchColon) {
                const hours = parseInt(zuluMatchColon[1]);
                const mins = zuluMatchColon[2];
                const zuluStr = `${String(hours).padStart(2, '0')}${mins}Z`;
                
                const now = new Date();
                const isDST = now.toLocaleString('en-US', {timeZone: 'America/New_York', timeZoneName: 'short'}).includes('EDT');
                const offset = isDST ? 4 : 5;
                let localHours = hours - offset;
                if (localHours < 0) localHours += 24;
                const ampm = localHours >= 12 ? 'pm' : 'am';
                let displayHours = localHours > 12 ? localHours - 12 : (localHours === 0 ? 12 : localHours);
                const localStr = `${displayHours}:${mins} ${ampm} ${isDST ? 'EDT' : 'EST'}`;
                console.log('Parsed HH:MMZ:', { zulu: zuluStr, local: localStr });
                return { zulu: zuluStr, local: localStr, combined: `${zuluStr} (${localStr})` };
            }
            
            // Parse local time format: "11:00 am EST" or "3:30 pm EDT"
            const localMatch = timeStr.match(/(\d{1,2}):(\d{2})\s*(am|pm)\s*(EST|EDT|CST|CDT|MST|MDT|PST|PDT)/i);
            if (localMatch) {
                let hours = parseInt(localMatch[1]);
                const mins = localMatch[2];
                const ampm = localMatch[3].toLowerCase();
                const tz = localMatch[4].toUpperCase();
                
                // Convert to 24-hour format
                if (ampm === 'pm' && hours !== 12) hours += 12;
                if (ampm === 'am' && hours === 12) hours = 0;
                
                // Timezone offsets from UTC (standard time)
                const tzOffsets = {
                    'EST': 5, 'EDT': 4,
                    'CST': 6, 'CDT': 5,
                    'MST': 7, 'MDT': 6,
                    'PST': 8, 'PDT': 7
                };
                
                const offset = tzOffsets[tz] || 5;
                let zuluHours = hours + offset;
                if (zuluHours >= 24) zuluHours -= 24;
                
                const zuluStr = `${String(zuluHours).padStart(2, '0')}${mins}Z`;
                const localStr = timeStr; // Keep original local format
                console.log('Parsed local time:', { zulu: zuluStr, local: localStr });
                return { zulu: zuluStr, local: localStr, combined: `${zuluStr} (${localStr})` };
            }
            
            // Return as-is if can't parse
            console.log('Could not parse time, returning as-is:', timeStr);
            return { zulu: timeStr, local: '', combined: timeStr };
        }

        function getRushStatus(icao) {
            const localTime = getLocalTime(icao);
            if (!localTime) return null;
            
            const hour = localTime.getHours();
            const dayOfWeek = localTime.getDay(); // 0 = Sunday
            
            // Weekends have different patterns
            const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
            
            if (isWeekend) {
                // Weekend patterns are less pronounced
                if (hour >= 7 && hour < 11) return 'AM RUSH';
                if (hour >= 15 && hour < 19) return 'PM RUSH';
            } else {
                // Weekday patterns
                if (hour >= 6 && hour < 9) return 'AM RUSH';
                if (hour >= 16 && hour < 19) return 'PM RUSH';
            }
            
            return null;
        }

        function getHubInfo(icao) {
            return HUB_AIRPORTS[icao] || null;
        }

        async function fetchTrafficManagement() {
            // FAA Airport Status API - now returns XML
            const url = 'https://nasstatus.faa.gov/api/airport-status-information';
            
            try {
                const text = await tryFetch(url);
                trafficPrograms = {};
                
                // Check if response is XML (starts with <)
                if (text.trim().startsWith('<')) {
                    // Parse XML response
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(text, 'text/xml');
                    
                    // Check for parse errors
                    const parseError = xmlDoc.querySelector('parsererror');
                    if (parseError) {
                        console.log('XML parse error:', parseError.textContent);
                        return;
                    }
                    
                    // Get update time for logging
                    const updateTime = xmlDoc.querySelector('Update_Time')?.textContent || 'unknown';
                    console.log('FAA NAS Status XML - Updated:', updateTime);
                    
                    // Log root element and all top-level children to understand structure
                    const root = xmlDoc.documentElement;
                    console.log('XML Root element:', root?.tagName);
                    console.log('XML Top-level children:', Array.from(root?.children || []).map(c => c.tagName).join(', '));
                    
                    // Log all list sections
                    const gdpList = xmlDoc.querySelector('Ground_Delay_List');
                    const gsList = xmlDoc.querySelector('Ground_Stop_List');
                    const delayList = xmlDoc.querySelector('Arrival_Departure_Delay_List');
                    console.log('Ground_Delay_List exists:', !!gdpList, gdpList ? `(${gdpList.children.length} children)` : '');
                    console.log('Ground_Stop_List exists:', !!gsList, gsList ? `(${gsList.children.length} children)` : '');
                    console.log('Arrival_Departure_Delay_List exists:', !!delayList, delayList ? `(${delayList.children.length} children)` : '');
                    
                    // If Ground_Stop_List exists, log its raw content
                    if (gsList) {
                        console.log('Ground_Stop_List raw:', gsList.innerHTML?.substring(0, 500));
                    }
                    
                    // Search raw XML for DCA to see all mentions
                    const dcaMatches = text.match(/DCA[^<]*</g);
                    if (dcaMatches) {
                        console.log('=== DCA mentions in raw XML ===', dcaMatches);
                    }
                    
                    // Parse Ground Delay Programs
                    const gdpNodes = xmlDoc.querySelectorAll('Ground_Delay_List Ground_Delay');
                    console.log('Found', gdpNodes.length, 'Ground Delay Programs');
                    for (const gdp of gdpNodes) {
                        const arpt = gdp.querySelector('ARPT')?.textContent;
                        if (!arpt) continue;
                        
                        const icao = 'K' + arpt;
                        if (!trafficPrograms[icao]) trafficPrograms[icao] = [];
                        
                        // Log all child elements to see what's available
                        console.log(`GDP ${arpt} fields:`, Array.from(gdp.children).map(c => `${c.tagName}=${c.textContent}`).join(', '));
                        
                        const avgDelay = gdp.querySelector('Avg')?.textContent || 
                                        gdp.querySelector('Avg_Delay')?.textContent || 
                                        gdp.querySelector('Average')?.textContent || '';
                        const maxDelay = gdp.querySelector('Max')?.textContent || 
                                        gdp.querySelector('Max_Delay')?.textContent || 
                                        gdp.querySelector('Maximum')?.textContent || '';
                        const reason = gdp.querySelector('Reason')?.textContent || '';
                        
                        // Try multiple field name variations for times
                        const startTime = gdp.querySelector('Start_Time')?.textContent || 
                                         gdp.querySelector('Starttime')?.textContent ||
                                         gdp.querySelector('Start')?.textContent ||
                                         gdp.querySelector('Issued')?.textContent || '';
                        const endTime = gdp.querySelector('End_Time')?.textContent || 
                                       gdp.querySelector('Endtime')?.textContent ||
                                       gdp.querySelector('End')?.textContent ||
                                       gdp.querySelector('Expire')?.textContent ||
                                       gdp.querySelector('Expected_End')?.textContent || '';
                        
                        // Scope and rates - try multiple variations
                        const scope = gdp.querySelector('Scope')?.textContent || 
                                     gdp.querySelector('Controlled_Element')?.textContent ||
                                     gdp.querySelector('Delay_Asgmt_Ctrl')?.textContent ||
                                     gdp.querySelector('Impact')?.textContent || '';
                        const arrivalRate = gdp.querySelector('Arrival_Rate')?.textContent || 
                                           gdp.querySelector('AAR')?.textContent || 
                                           gdp.querySelector('Arr_Rate')?.textContent ||
                                           gdp.querySelector('arrival_rate')?.textContent || '';
                        const departureRate = gdp.querySelector('Departure_Rate')?.textContent || 
                                             gdp.querySelector('ADR')?.textContent || 
                                             gdp.querySelector('Dep_Rate')?.textContent ||
                                             gdp.querySelector('departure_rate')?.textContent || '';
                        
                        trafficPrograms[icao].push({
                            type: 'GDP',
                            avgDelay: avgDelay,
                            maxDelay: maxDelay,
                            startTime: startTime,
                            endTime: endTime,
                            scope: scope,
                            arrivalRate: arrivalRate,
                            departureRate: departureRate,
                            reason: reason
                        });
                        
                        console.log(`GDP ${icao}: avg=${avgDelay}, max=${maxDelay}, start=${startTime}, end=${endTime}, scope=${scope}`);
                    }
                    
                    // Parse Ground Stops - try multiple selector patterns
                    let gsNodes = xmlDoc.querySelectorAll('Ground_Stop_List Ground_Stop');
                    console.log('Found', gsNodes.length, 'Ground Stops with selector: Ground_Stop_List Ground_Stop');
                    
                    // Try alternative selectors if none found
                    if (gsNodes.length === 0) {
                        gsNodes = xmlDoc.querySelectorAll('Ground_Stop');
                        console.log('Trying alternate selector Ground_Stop:', gsNodes.length, 'found');
                    }
                    if (gsNodes.length === 0) {
                        gsNodes = xmlDoc.querySelectorAll('GroundStop');
                        console.log('Trying alternate selector GroundStop:', gsNodes.length, 'found');
                    }
                    
                    // If still none found but gsList exists, try iterating its children directly
                    if (gsNodes.length === 0 && gsList && gsList.children.length > 0) {
                        console.log('No GS nodes found with selectors, iterating gsList children directly');
                        console.log('gsList children tag names:', Array.from(gsList.children).map(c => c.tagName).join(', '));
                        gsNodes = gsList.children;
                    }
                    
                    for (const gs of gsNodes) {
                        // Try multiple ways to get airport code
                        let arpt = gs.querySelector('ARPT')?.textContent;
                        if (!arpt) arpt = gs.querySelector('arpt')?.textContent;
                        if (!arpt) arpt = gs.querySelector('Airport')?.textContent;
                        if (!arpt) arpt = gs.getAttribute('ARPT');
                        if (!arpt) arpt = gs.getAttribute('airport');
                        
                        if (!arpt) {
                            console.log('GS node found but no ARPT:', gs.outerHTML?.substring(0, 200));
                            continue;
                        }
                        
                        const icao = arpt.length === 3 ? 'K' + arpt : arpt;
                        if (!trafficPrograms[icao]) trafficPrograms[icao] = [];
                        
                        // Log all child elements
                        console.log(`GS ${arpt} fields:`, Array.from(gs.children).map(c => `${c.tagName}=${c.textContent?.substring(0,50)}`).join(', '));
                        
                        const startTime = gs.querySelector('Start_Time')?.textContent || 
                                         gs.querySelector('Starttime')?.textContent ||
                                         gs.querySelector('Start')?.textContent ||
                                         gs.querySelector('Issued')?.textContent || '';
                        const endTime = gs.querySelector('End_Time')?.textContent || 
                                       gs.querySelector('Endtime')?.textContent ||
                                       gs.querySelector('End')?.textContent ||
                                       gs.querySelector('Expire')?.textContent ||
                                       gs.querySelector('Expected_End')?.textContent || 'TBD';
                        const reason = gs.querySelector('Reason')?.textContent || '';
                        // Scope for ground stops
                        const scope = gs.querySelector('Scope')?.textContent || 
                                     gs.querySelector('Controlled_Element')?.textContent ||
                                     gs.querySelector('Delay_Asgmt_Ctrl')?.textContent ||
                                     gs.querySelector('Impact')?.textContent || '';
                        
                        trafficPrograms[icao].push({
                            type: 'GROUND STOP',
                            startTime: startTime,
                            endTime: endTime,
                            scope: scope,
                            reason: reason
                        });
                        
                        console.log(`GS ${icao}: start=${startTime}, end=${endTime}, scope=${scope}, reason=${reason}`);
                    }
                    
                    // Parse Arrival/Departure Delays - try multiple selectors
                    // Structure might be: Arrival_Departure_Delay_List > Delay with Arrival_Departure child or attribute
                    const delayNodes = xmlDoc.querySelectorAll('Arrival_Departure_Delay_List Delay, Arrival_Departure_Delay_List Arrival_Delay, Arrival_Departure_Delay_List Departure_Delay');
                    console.log('Found', delayNodes.length, 'Arrival/Departure Delays');
                    for (const delay of delayNodes) {
                        const arpt = delay.querySelector('ARPT')?.textContent;
                        if (!arpt) continue;
                        
                        const icao = 'K' + arpt;
                        if (!trafficPrograms[icao]) trafficPrograms[icao] = [];
                        
                        const minDelay = delay.querySelector('Min')?.textContent || '';
                        const maxDelay = delay.querySelector('Max')?.textContent || '';
                        const avgDelay = delay.querySelector('Avg')?.textContent || '';
                        const trend = delay.querySelector('Trend')?.textContent || '';
                        const reason = delay.querySelector('Reason')?.textContent || '';
                        const startTime = delay.querySelector('Start_Time')?.textContent || 
                                         delay.querySelector('Starttime')?.textContent || '';
                        const endTime = delay.querySelector('End_Time')?.textContent || 
                                       delay.querySelector('Endtime')?.textContent || '';
                        
                        // Determine if arrival or departure
                        const typeAttr = delay.getAttribute('Arrival_Departure');
                        const typeChild = delay.querySelector('Arrival_Departure')?.textContent;
                        const tagName = delay.tagName;
                        
                        let delayType = 'DELAY';
                        if (typeAttr === 'Arrival' || typeChild === 'Arrival' || tagName === 'Arrival_Delay') {
                            delayType = 'ARR DELAY';
                        } else if (typeAttr === 'Departure' || typeChild === 'Departure' || tagName === 'Departure_Delay') {
                            delayType = 'DEP DELAY';
                        }
                        
                        trafficPrograms[icao].push({
                            type: delayType,
                            minDelay: minDelay,
                            maxDelay: maxDelay,
                            avgDelay: avgDelay,
                            trend: trend,
                            startTime: startTime,
                            endTime: endTime,
                            reason: reason
                        });
                    }
                    
                    // Parse Deicing (if present in XML)
                    const deiceNodes = xmlDoc.querySelectorAll('Deicing_List Airport, Deice_List Airport');
                    if (deiceNodes.length > 0) console.log('Found', deiceNodes.length, 'Deicing Programs');
                    for (const deice of deiceNodes) {
                        const arpt = deice.querySelector('ARPT')?.textContent || deice.textContent?.trim();
                        if (!arpt) continue;
                        
                        const icao = 'K' + arpt;
                        if (!trafficPrograms[icao]) trafficPrograms[icao] = [];
                        
                        trafficPrograms[icao].push({
                            type: 'DEICING',
                            reason: 'Formal deicing program active'
                        });
                    }
                    
                    console.log('Traffic programs loaded (XML):', Object.keys(trafficPrograms).length, 'airports affected');
                    if (Object.keys(trafficPrograms).length > 0) {
                        console.log('Affected airports:', Object.keys(trafficPrograms).join(', '));
                        // Log detail for each airport showing ALL programs
                        for (const [icao, progs] of Object.entries(trafficPrograms)) {
                            console.log(`  ${icao}: ${progs.length} program(s)`);
                            for (const p of progs) {
                                console.log(`    - ${p.type}: avg=${p.avgDelay || 'N/A'}, end=${p.endTime || 'N/A'}, reason=${p.reason?.substring(0,50) || 'N/A'}`);
                            }
                        }
                        // Specifically check DCA
                        if (trafficPrograms['KDCA']) {
                            console.log('=== DCA PROGRAMS ===', trafficPrograms['KDCA']);
                        }
                    }
                    
                } else {
                    // Try JSON parsing as fallback
                    try {
                        const data = JSON.parse(text);
                        if (data && Array.isArray(data)) {
                            for (const item of data) {
                                const icao = 'K' + item.airportId;
                                if (AIRPORTS.includes(icao)) {
                                    const programs = [];
                                    
                                    if (item.groundDelay && item.groundDelay.status === true) {
                                        programs.push({
                                            type: 'GDP',
                                            avgDelay: item.groundDelay.avgDelay || '',
                                            maxDelay: item.groundDelay.maxDelay || '',
                                            startTime: item.groundDelay.startTime || '',
                                            endTime: item.groundDelay.endTime || '',
                                            scope: item.groundDelay.scope || '',
                                            arrivalRate: item.groundDelay.arrivalRate || item.groundDelay.aar || '',
                                            departureRate: item.groundDelay.departureRate || item.groundDelay.adr || '',
                                            reason: item.groundDelay.reason || ''
                                        });
                                    }
                                    
                                    if (item.groundStop && item.groundStop.status === true) {
                                        programs.push({
                                            type: 'GROUND STOP',
                                            startTime: item.groundStop.startTime || '',
                                            endTime: item.groundStop.endTime || 'TBD',
                                            scope: item.groundStop.scope || '',
                                            reason: item.groundStop.reason || ''
                                        });
                                    }
                                    
                                    if (item.arrivalDelay && item.arrivalDelay.status === true) {
                                        programs.push({
                                            type: 'ARR DELAY',
                                            minDelay: item.arrivalDelay.minDelay || '',
                                            maxDelay: item.arrivalDelay.maxDelay || '',
                                            avgDelay: item.arrivalDelay.avgDelay || '',
                                            startTime: item.arrivalDelay.startTime || '',
                                            endTime: item.arrivalDelay.endTime || '',
                                            trend: item.arrivalDelay.trend || '',
                                            reason: item.arrivalDelay.reason || ''
                                        });
                                    }
                                    
                                    if (item.departureDelay && item.departureDelay.status === true) {
                                        programs.push({
                                            type: 'DEP DELAY',
                                            minDelay: item.departureDelay.minDelay || '',
                                            maxDelay: item.departureDelay.maxDelay || '',
                                            avgDelay: item.departureDelay.avgDelay || '',
                                            startTime: item.departureDelay.startTime || '',
                                            endTime: item.departureDelay.endTime || '',
                                            trend: item.departureDelay.trend || '',
                                            reason: item.departureDelay.reason || ''
                                        });
                                    }
                                    
                                    if (item.deicing && item.deicing.status === true) {
                                        programs.push({
                                            type: 'DEICING',
                                            startTime: item.deicing.startTime || '',
                                            reason: 'Formal deicing program active'
                                        });
                                    }
                                    
                                    if (programs.length > 0) {
                                        trafficPrograms[icao] = programs;
                                    }
                                }
                            }
                        }
                        console.log('Traffic programs loaded (JSON):', Object.keys(trafficPrograms).length, 'airports affected');
                    } catch (jsonErr) {
                        console.log('Traffic data parse failed - not JSON or XML');
                    }
                }
                
            } catch (e) {
                console.log('Traffic management fetch failed:', e.message);
            }
        }

        // FAA ATCSCC Advisory Database - more detailed info on GDPs, constraints, runway closures
        let faaAdvisoryData = {
            terminalActive: {},      // Active GDPs/Ground Stops with end times
            terminalPlanned: {},     // Planned/possible ground stops
            terminalConstraints: {}, // Weather constraints (TSTMS, LOW CIGS, etc.)
            runwayClosures: {},      // Runway/taxiway closures
            enRouteConstraints: [],  // En route issues
            plannedATCsList: [],     // Ordered list of planned ATCs
            rawText: ''
        };
        let faaAdvisoryFetchFailed = false;

        // Special fetch function for FAA that tries FAA-specific proxies
        async function tryFetchFAA(url, proxyIndex = 0, minLength = 10) {
            if (proxyIndex >= FAA_PROXIES.length) {
                console.warn('All FAA fetch methods failed for:', url.substring(0, 60));
                return '';
            }
            
            const proxyUrl = FAA_PROXIES[proxyIndex](url);
            
            try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 15000);
                
                const response = await fetch(proxyUrl, { 
                    signal: controller.signal,
                    headers: { 
                        'Accept': 'text/html, text/plain, */*'
                    }
                });
                clearTimeout(timeout);
                
                if (!response.ok) {
                    console.log(`FAA Proxy ${proxyIndex} returned HTTP ${response.status}`);
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const text = await response.text();
                console.log(`FAA Proxy ${proxyIndex} returned ${text.length} bytes`);
                
                // Check for access denied
                if (text.includes('Access Denied') || text.includes('403 Forbidden')) {
                    console.log(`FAA Proxy ${proxyIndex} got Access Denied`);
                    throw new Error('Access Denied');
                }
                
                if (!text || text.length < minLength) {
                    throw new Error('Response too short: ' + text.length);
                }
                return text;
            } catch (e) {
                console.log(`FAA Proxy ${proxyIndex} failed:`, e.message);
                return tryFetchFAA(url, proxyIndex + 1, minLength);
            }
        }
        
        async function fetchFAAAdvisory() {
            // Reset data before fetching
            faaAdvisoryData = {
                terminalActive: {},
                terminalPlanned: {},
                terminalConstraints: {},
                runwayClosures: {},
                enRouteConstraints: [],
                afpPrograms: [],
                vipMovements: [],
                plannedLaunches: [],
                staffingTriggers: [],
                plannedATCsList: [],  // Ordered list as they appear in advisory
                rawText: ''
            };
            
            // Try multiple URLs - adv_spt is the latest, adv_otherdis is backup
            const now = new Date();
            const month = String(now.getUTCMonth() + 1).padStart(2, '0');
            const day = String(now.getUTCDate()).padStart(2, '0');
            const year = now.getUTCFullYear();
            const dateStr = `${month}${day}${year}`;
            const titleDate = `${month}/${day}/${year}`;
            
            const urlsToTry = [
                'https://www.fly.faa.gov/adv/adv_spt',
                'https://fly.faa.gov/adv/adv_spt',
                `https://www.fly.faa.gov/adv/adv_otherdis?advn=2&adv_date=${dateStr}&facId=ATCSCC&title=ATCSCC%20ADVZY%20002%20DCC%20${titleDate}%20OPERATIONS%20PLAN&titleDate=${titleDate}`,
                `https://www.fly.faa.gov/adv/adv_otherdis?advn=1&adv_date=${dateStr}&facId=ATCSCC&title=ATCSCC%20ADVZY%20001%20DCC%20${titleDate}%20OPERATIONS%20PLAN&titleDate=${titleDate}`
            ];
            
            let text = null;
            
            for (const url of urlsToTry) {
                console.log('Trying FAA Advisory URL:', url.substring(0, 60));
                
                try {
                    const response = await tryFetchFAA(url, 0, 100);
                    
                    if (!response || response.includes('Access Denied') || response.includes('403 Forbidden')) {
                        console.log('FAA Advisory: Access Denied for', url.substring(0, 40));
                        continue;
                    }
                    
                    // The response might be HTML - extract the pre/textarea content
                    let extractedText = response;
                    
                    // Try to find the raw text in common HTML containers
                    const preMatch = response.match(/<pre[^>]*>([\s\S]*?)<\/pre>/i);
                    const textareaMatch = response.match(/<textarea[^>]*>([\s\S]*?)<\/textarea>/i);
                    
                    if (preMatch) {
                        extractedText = preMatch[1];
                        console.log('Extracted text from <pre> tag');
                    } else if (textareaMatch) {
                        extractedText = textareaMatch[1];
                        console.log('Extracted text from <textarea> tag');
                    }
                    
                    // Decode HTML entities
                    extractedText = extractedText
                        .replace(/&lt;/g, '<')
                        .replace(/&gt;/g, '>')
                        .replace(/&amp;/g, '&')
                        .replace(/&nbsp;/g, ' ')
                        .replace(/&#58;/g, ':')
                        .replace(/&#47;/g, '/')
                        .replace(/&#46;/g, '.')
                        .replace(/&#95;/g, '_');
                    
                    // Check for valid advisory content
                    if (extractedText.length > 300 && 
                        (extractedText.includes('TERMINAL') || 
                         extractedText.includes('STAFFING') || 
                         extractedText.includes('VIP') || 
                         extractedText.includes('RUNWAY'))) {
                        console.log(`FAA Advisory: Got valid response (${extractedText.length} chars) from ${url.substring(0,40)}`);
                        text = extractedText;
                        break;
                    }
                } catch (e) {
                    console.log('FAA Advisory error for', url.substring(0, 40), ':', e.message);
                }
            }
            
            if (!text || text.length < 100) {
                console.log('FAA Advisory: Unable to fetch - visit https://www.fly.faa.gov/adv/adv_spt for current ops plan');
                faaAdvisoryFetchFailed = true;
                return;
            }
            
            faaAdvisoryFetchFailed = false;
            
            try {
                // Debug output
                console.log('FAA Advisory raw response length:', text.length);
                console.log('FAA Advisory first 500 chars:', text.substring(0, 500));
                
                faaAdvisoryData.rawText = text;
                
                // Debug: Show all section headers found
                const sectionHeaders = text.match(/^[A-Z][A-Z\s\/\(\)]+:/gm);
                console.log('FAA Advisory section headers found:', sectionHeaders);
                
                // Parse TERMINAL ACTIVE section (active GDPs/Ground Stops)
                const terminalActiveMatch = text.match(/TERMINAL ACTIVE:\s*([\s\S]*?)(?=TERMINAL PLANNED:|EN ROUTE|$)/i);
                if (terminalActiveMatch) {
                    const lines = terminalActiveMatch[1].trim().split('\n');
                    for (const line of lines) {
                        // Format: UNTIL 1829 -SEA GROUND DELAY PROGRAM or AFTER 1829 -SEA...
                        const match = line.match(/(?:UNTIL|AFTER)\s+(\d{4})\s+-([A-Z]{3})\s+(.+)/i);
                        if (match) {
                            const endTime = match[1];
                            const airport = 'K' + match[2];
                            const program = match[3].trim();
                            
                            if (!faaAdvisoryData.terminalActive[airport]) {
                                faaAdvisoryData.terminalActive[airport] = [];
                            }
                            faaAdvisoryData.terminalActive[airport].push({
                                endTime: endTime,
                                program: program
                            });
                        }
                    }
                }
                
                // Parse TERMINAL PLANNED section
                const terminalPlannedMatch = text.match(/TERMINAL PLANNED:\s*([\s\S]*?)(?=EN ROUTE|CDRS|$)/i);
                if (terminalPlannedMatch) {
                    console.log('TERMINAL PLANNED section:', terminalPlannedMatch[1].substring(0, 200));
                    const lines = terminalPlannedMatch[1].trim().split('\n');
                    for (const line of lines) {
                        // Format: AFTER 0200 -SAN GROUND STOP/DELAY PROGRAM POSSIBLE
                        const match = line.match(/(UNTIL|AFTER)\s+(\d{4})\s+-([A-Z\/]+)\s+(.+)/i);
                        if (match) {
                            const timeType = match[1].toUpperCase(); // AFTER or UNTIL
                            const time = match[2]; // 0200
                            const airports = match[3].split('/');
                            const program = match[4].trim();
                            
                            for (const apt of airports) {
                                const icao = 'K' + apt;
                                if (!faaAdvisoryData.terminalPlanned[icao]) {
                                    faaAdvisoryData.terminalPlanned[icao] = [];
                                }
                                // Store with time: "AFTER 0200Z - GROUND STOP/DELAY PROGRAM POSSIBLE"
                                const fullEntry = `${timeType} ${time}Z - ${program}`;
                                faaAdvisoryData.terminalPlanned[icao].push(fullEntry);
                                
                                // Also store in ordered list (preserves advisory order)
                                faaAdvisoryData.plannedATCsList.push({
                                    icao: icao,
                                    time: parseInt(time),
                                    timeType: timeType,
                                    program: fullEntry
                                });
                            }
                        }
                    }
                }
                
                // Parse TERMINAL CONSTRAINTS section
                const constraintsMatch = text.match(/TERMINAL CONSTRAINTS:\s*([\s\S]*?)(?=TERMINAL ACTIVE:|TERMINAL PLANNED:|EN ROUTE|$)/i);
                if (constraintsMatch) {
                    const lines = constraintsMatch[1].trim().split('\n');
                    for (const line of lines) {
                        // Format: FLL/MIA - TSTMS or SFO/SEA - LOW CEILINGS
                        const match = line.match(/([A-Z\/]+)\s+-\s+(.+)/i);
                        if (match) {
                            const airports = match[1].split('/');
                            const constraint = match[2].trim();
                            
                            for (const apt of airports) {
                                const icao = 'K' + apt;
                                faaAdvisoryData.terminalConstraints[icao] = constraint;
                            }
                        }
                    }
                }
                
                // Parse AIRSPACE FLOW PROGRAMS sections (both ACTIVE and PLANNED)
                const afpActiveMatch = text.match(/AIRSPACE FLOW PROGRAM\(S\) ACTIVE:\s*([\s\S]*?)(?=AIRSPACE FLOW PROGRAM\(S\) PLANNED|PLANNED LAUNCH|VIP|FLIGHT CHECK|NEXT PLANNING|$)/i);
                const afpPlannedMatch = text.match(/AIRSPACE FLOW PROGRAM\(S\) PLANNED:\s*([\s\S]*?)(?=PLANNED LAUNCH|VIP|FLIGHT CHECK|NEXT PLANNING|$)/i);
                
                if (afpActiveMatch) {
                    console.log('AFP ACTIVE section found:', afpActiveMatch[1].substring(0, 100));
                    if (!afpActiveMatch[1].toUpperCase().includes('NONE')) {
                        const lines = afpActiveMatch[1].trim().split('\n');
                        for (const line of lines) {
                            if (line.trim().length > 5 && !line.includes('---') && !line.includes('AIRSPACE')) {
                                faaAdvisoryData.afpPrograms.push('[ACTIVE] ' + line.trim());
                            }
                        }
                    }
                }
                if (afpPlannedMatch) {
                    console.log('AFP PLANNED section found:', afpPlannedMatch[1].substring(0, 100));
                    if (!afpPlannedMatch[1].toUpperCase().includes('NONE')) {
                        const lines = afpPlannedMatch[1].trim().split('\n');
                        for (const line of lines) {
                            if (line.trim().length > 5 && !line.includes('---') && !line.includes('PLANNED LAUNCH')) {
                                faaAdvisoryData.afpPrograms.push('[PLANNED] ' + line.trim());
                            }
                        }
                    }
                }
                
                // Parse PLANNED LAUNCH/REENTRY section (Rocket Launches)
                const launchMatch = text.match(/PLANNED LAUNCH\/REENTRY:\s*([\s\S]*?)(?=FLIGHT CHECK|VIP MOVEMENT|NEXT PLANNING|$)/i);
                if (launchMatch) {
                    console.log('LAUNCH section found:', launchMatch[1].substring(0, 500));
                    if (!launchMatch[1].toUpperCase().includes('NONE')) {
                        const content = launchMatch[1].trim();
                        const lines = content.split('\n').filter(l => l.trim().length > 0 && !l.includes('---'));
                        
                        let currentMission = '';
                        let currentTimes = [];
                        
                        for (const line of lines) {
                            const trimmed = line.trim();
                            
                            // Check if this line has PRIMARY or BACKUP time
                            if (trimmed.match(/PRIMARY:|BACKUP:/i)) {
                                // If line starts with PRIMARY/BACKUP, it's a time line
                                if (trimmed.match(/^(PRIMARY|BACKUP):/i)) {
                                    currentTimes.push(trimmed);
                                } else {
                                    // Line contains both mission and time (e.g., "SPACEX... PRIMARY: ...")
                                    const primaryIdx = trimmed.search(/PRIMARY:/i);
                                    const backupIdx = trimmed.search(/BACKUP:/i);
                                    const splitIdx = Math.min(
                                        primaryIdx >= 0 ? primaryIdx : Infinity,
                                        backupIdx >= 0 ? backupIdx : Infinity
                                    );
                                    
                                    if (splitIdx < Infinity) {
                                        // Save previous mission if exists
                                        if (currentMission) {
                                            const entry = currentTimes.length > 0 
                                                ? currentMission + ' | ' + currentTimes.join(' | ')
                                                : currentMission;
                                            faaAdvisoryData.plannedLaunches.push(entry);
                                        }
                                        
                                        currentMission = trimmed.substring(0, splitIdx).trim();
                                        // Extract times from rest of line - split on PRIMARY/BACKUP boundaries
                                        const timePart = trimmed.substring(splitIdx);
                                        currentTimes = [];
                                        // Match PRIMARY: ... or BACKUP: ... up to next PRIMARY/BACKUP or end
                                        const timeMatches = timePart.match(/(PRIMARY|BACKUP):\s*[^]*?(?=\s+(?:PRIMARY|BACKUP):|$)/gi);
                                        if (timeMatches) {
                                            currentTimes = timeMatches.map(t => t.trim());
                                        }
                                    }
                                }
                            } else if (trimmed.match(/^[A-Z]/)) {
                                // New mission line (starts with letter, no PRIMARY/BACKUP)
                                // Save previous mission if exists
                                if (currentMission) {
                                    const entry = currentTimes.length > 0 
                                        ? currentMission + ' | ' + currentTimes.join(' | ')
                                        : currentMission;
                                    faaAdvisoryData.plannedLaunches.push(entry);
                                }
                                currentMission = trimmed;
                                currentTimes = [];
                            }
                        }
                        
                        // Don't forget the last mission
                        if (currentMission) {
                            const entry = currentTimes.length > 0 
                                ? currentMission + ' | ' + currentTimes.join(' | ')
                                : currentMission;
                            faaAdvisoryData.plannedLaunches.push(entry);
                        }
                        
                        console.log('Parsed launches:', faaAdvisoryData.plannedLaunches);
                    }
                }
                
                // Parse VIP MOVEMENT(S) section
                const vipMatch = text.match(/VIP MOVEMENT\(S\):\s*([\s\S]*?)(?=NEXT PLANNING|$)/i);
                if (vipMatch) {
                    console.log('VIP section found:', vipMatch[1].substring(0, 200));
                    if (!vipMatch[1].toUpperCase().includes('NONE')) {
                        const lines = vipMatch[1].trim().split('\n');
                        for (const line of lines) {
                            if (line.trim().length > 5 && !line.includes('---') && !line.includes('NEXT PLANNING')) {
                                faaAdvisoryData.vipMovements.push(line.trim());
                            }
                        }
                    }
                }
                
                // Parse RUNWAY/EQUIPMENT/POSSIBLE SYSTEM IMPACT REPORTS section
                const runwayMatch = text.match(/RUNWAY\/EQUIPMENT.*?:\s*([\s\S]*?)(?=AIRSPACE FLOW|PLANNED LAUNCH|FLIGHT CHECK|VIP|NEXT PLANNING|$)/i);
                if (runwayMatch) {
                    console.log('RUNWAY section found:', runwayMatch[1].substring(0, 200));
                    const lines = runwayMatch[1].trim().split('\n');
                    for (const line of lines) {
                        // Format: LGA - RWY 13/31 & 4/22 WEEKEND/NIGHTLY CLSD UNTIL...
                        const match = line.match(/^([A-Z]{3})\s+-\s+(.+)/i);
                        if (match) {
                            const icao = 'K' + match[1];
                            const issue = match[2].trim();
                            
                            if (!faaAdvisoryData.runwayClosures[icao]) {
                                faaAdvisoryData.runwayClosures[icao] = [];
                            }
                            faaAdvisoryData.runwayClosures[icao].push(issue);
                        }
                    }
                }
                
                // Parse STAFFING TRIGGER section
                const staffingMatch = text.match(/STAFFING TRIGGER[S\(\)]*:\s*([\s\S]*?)(?=TERMINAL|EN ROUTE|$)/i);
                if (staffingMatch) {
                    console.log('STAFFING section found:', staffingMatch[1].substring(0, 100));
                    if (!staffingMatch[1].toUpperCase().includes('NONE')) {
                        const lines = staffingMatch[1].trim().split('\n');
                        for (const line of lines) {
                            if (line.trim().length > 5 && !line.includes('---')) {
                                faaAdvisoryData.staffingTriggers.push(line.trim());
                            }
                        }
                    }
                }
                
                const activeCount = Object.keys(faaAdvisoryData.terminalActive).length;
                const constraintCount = Object.keys(faaAdvisoryData.terminalConstraints).length;
                const runwayCount = Object.keys(faaAdvisoryData.runwayClosures).length;
                const afpCount = faaAdvisoryData.afpPrograms.length;
                const vipCount = faaAdvisoryData.vipMovements.length;
                const launchCount = faaAdvisoryData.plannedLaunches.length;
                const staffingCount = faaAdvisoryData.staffingTriggers.length;
                
                console.log(`FAA Advisory loaded: ${activeCount} active, ${constraintCount} constraints, ${runwayCount} runway, ${afpCount} AFP, ${vipCount} VIP, ${launchCount} launches, ${staffingCount} staffing`);
                // Log details of active programs
                if (activeCount > 0) {
                    for (const [icao, progs] of Object.entries(faaAdvisoryData.terminalActive)) {
                        for (const p of progs) {
                            console.log(`  Advisory ${icao}: Until ${p.endTime}Z - ${p.program}`);
                        }
                    }
                }
                if (vipCount > 0) console.log('  VIP:', faaAdvisoryData.vipMovements);
                if (launchCount > 0) console.log('  Launches:', faaAdvisoryData.plannedLaunches);
                
            } catch (e) {
                console.error('FAA Advisory fetch failed:', e.message);
            }
        }

        async function fetchTAFs() {
            try {
                const ids = AIRPORTS.join(',');
                const url = `https://aviationweather.gov/api/data/taf?ids=${ids}&format=raw`;
                console.log('Fetching TAFs from:', url);
                const text = await tryFetch(url, 0, 20);
                
                tafData = {};
                
                if (!text || text.length < 30) {
                    console.log('TAF: No data or empty response');
                    return;
                }
                
                console.log('TAF response length:', text.length);
                
                // More robust TAF splitting:
                // 1. First normalize line endings and split by double newlines or TAF prefix
                // 2. TAFs can start with "TAF " or "TAF\n" followed by ICAO
                // 3. Need to handle both US (K) and Canadian (C) airports
                
                // Split on "TAF " followed by valid ICAO pattern, using lookahead to keep delimiter
                // Also split on double newlines as TAF separator
                let tafParts = text.split(/\n\s*\n+/);
                
                // If that doesn't work well, try splitting on TAF prefix
                if (tafParts.length < 5) {
                    tafParts = text.split(/(?=TAF\s+(?:K[A-Z]{3}|C[A-Z]{3}|[A-Z]{4}))/);
                }
                
                console.log('TAF parts found:', tafParts.length);
                
                const now = new Date();
                const currentHour = now.getUTCHours();
                const currentDay = now.getUTCDate();
                
                for (let taf of tafParts) {
                    taf = taf.trim();
                    if (!taf || taf.length < 20) continue;
                    
                    // Extract ICAO - can be "TAF KORD" or "TAF\nKORD" or just start of string
                    const icaoMatch = taf.match(/(?:TAF\s+)?([KC][A-Z]{3})\s+\d{6}Z/);
                    if (!icaoMatch) continue;
                    
                    const icao = icaoMatch[1];
                    
                    // Verify this TAF is actually for this airport by checking it appears near the start
                    const icaoPos = taf.indexOf(icao);
                    if (icaoPos > 10) continue; // ICAO should be near the beginning
                    
                    // Find where this TAF ends - look for start of another TAF within this block
                    // This handles cases where split didn't work perfectly
                    const nextTafMatch = taf.substring(20).match(/\bTAF\s+([KC][A-Z]{3})\s+\d{6}Z/);
                    if (nextTafMatch) {
                        // Truncate at the next TAF
                        const nextTafPos = taf.indexOf(nextTafMatch[0], 20);
                        if (nextTafPos > 0) {
                            taf = taf.substring(0, nextTafPos).trim();
                        }
                    }
                    
                    const forecasts = [];
                    let conditionChanges = [];
                    let nextFrozenStart = null;
                    let frozenEndsAt = null;
                    let tempForecasts = [];
                    
                    // Parse FM (From) groups - format: FM041200
                    const fmPattern = /FM(\d{2})(\d{2})(\d{2})\s+([^F]+?)(?=FM\d{6}|TEMPO|BECMG|PROB|$)/g;
                    let fmMatches = [...taf.matchAll(fmPattern)];
                    
                    for (const fm of fmMatches) {
                        const day = parseInt(fm[1]);
                        const hour = parseInt(fm[2]);
                        const minute = parseInt(fm[3]);
                        const conditions = fm[4].trim();
                        
                        // Check for frozen precip in this period
                        const hasFrozen = /\b(\+|-)?((SN)|(FZRA)|(FZDZ)|(PL)|(FZFG)|(GS)|(GR)|(IC))\b/.test(conditions);
                        
                        // Extract temperature if present (TX/TN groups or temp remarks)
                        const tempMatch = conditions.match(/\b(TX|TN)(M?\d{2})\/(\d{2})(\d{2})Z\b/);
                        if (tempMatch) {
                            const tempType = tempMatch[1]; // TX = max, TN = min
                            const tempVal = tempMatch[2].startsWith('M') ? -parseInt(tempMatch[2].slice(1)) : parseInt(tempMatch[2]);
                            const tempDay = parseInt(tempMatch[3]);
                            const tempHour = parseInt(tempMatch[4]);
                            tempForecasts.push({
                                type: tempType,
                                temp: tempVal,
                                day: tempDay,
                                hour: tempHour
                            });
                        }
                        
                        conditionChanges.push({
                            type: 'FM',
                            day: day,
                            hour: hour,
                            minute: minute,
                            conditions: conditions,
                            hasFrozen: hasFrozen,
                            timeStr: `${String(hour).padStart(2,'0')}${String(minute).padStart(2,'0')}Z`
                        });
                    }
                    
                    // Parse TEMPO groups - format: TEMPO 0412/0418
                    const tempoPattern = /TEMPO\s+(\d{2})(\d{2})\/(\d{2})(\d{2})\s+([^T\n]+?)(?=TEMPO|FM|BECMG|PROB|$)/g;
                    let tempoMatches = [...taf.matchAll(tempoPattern)];
                    
                    for (const tempo of tempoMatches) {
                        const startDay = parseInt(tempo[1]);
                        const startHour = parseInt(tempo[2]);
                        const endDay = parseInt(tempo[3]);
                        const endHour = parseInt(tempo[4]);
                        const conditions = tempo[5].trim();
                        
                        const hasFrozen = /\b(\+|-)?((SN)|(FZRA)|(FZDZ)|(PL)|(FZFG)|(GS)|(GR)|(IC))\b/.test(conditions);
                        
                        conditionChanges.push({
                            type: 'TEMPO',
                            startDay: startDay,
                            startHour: startHour,
                            endDay: endDay,
                            endHour: endHour,
                            conditions: conditions,
                            hasFrozen: hasFrozen,
                            timeStr: `${String(startHour).padStart(2,'0')}Z-${String(endHour).padStart(2,'0')}Z`
                        });
                    }
                    
                    // Parse BECMG groups - format: BECMG 0412/0414
                    const becmgPattern = /BECMG\s+(\d{2})(\d{2})\/(\d{2})(\d{2})\s+([^B\n]+?)(?=TEMPO|FM|BECMG|PROB|$)/g;
                    let becmgMatches = [...taf.matchAll(becmgPattern)];
                    
                    for (const becmg of becmgMatches) {
                        const startDay = parseInt(becmg[1]);
                        const startHour = parseInt(becmg[2]);
                        const endDay = parseInt(becmg[3]);
                        const endHour = parseInt(becmg[4]);
                        const conditions = becmg[5].trim();
                        
                        const hasFrozen = /\b(\+|-)?((SN)|(FZRA)|(FZDZ)|(PL)|(FZFG)|(GS)|(GR)|(IC))\b/.test(conditions);
                        const hasNSW = /\bNSW\b/.test(conditions); // No Significant Weather
                        
                        conditionChanges.push({
                            type: 'BECMG',
                            startDay: startDay,
                            startHour: startHour,
                            endDay: endDay,
                            endHour: endHour,
                            conditions: conditions,
                            hasFrozen: hasFrozen,
                            hasNSW: hasNSW,
                            timeStr: `${String(startHour).padStart(2,'0')}-${String(endHour).padStart(2,'0')}Z`
                        });
                    }
                    
                    // Find when frozen precip starts and ends
                    let currentlyFrozen = false;
                    for (const change of conditionChanges) {
                        if (change.hasFrozen && !currentlyFrozen) {
                            nextFrozenStart = change;
                            currentlyFrozen = true;
                        } else if (!change.hasFrozen && currentlyFrozen && change.type === 'FM') {
                            frozenEndsAt = change;
                            break;
                        } else if (change.hasNSW && currentlyFrozen) {
                            frozenEndsAt = change;
                            break;
                        }
                    }
                    
                    // Collect frozen precip forecasts for display
                    const frozenPattern = /\b(\+|-)?((SN)|(FZRA)|(FZDZ)|(PL)|(FZFG)|(GS)|(GR)|(IC))\b/g;
                    const matches = taf.matchAll(frozenPattern);
                    
                    for (const match of matches) {
                        const wx = match[0].replace(/^[+-]/, '');
                        const beforeMatch = taf.substring(0, match.index);
                        const timeMatch = beforeMatch.match(/(FM\d{6}|TEMPO\s+\d{4}\/\d{4}|BECMG\s+\d{4}\/\d{4}|\d{4}\/\d{4})\s*[^\n]*$/);
                        
                        forecasts.push({
                            raw: timeMatch ? timeMatch[0].substring(0, 30) + ' ' + match[0] : match[0],
                            wx: wx,
                            intensity: match[1] || ''
                        });
                    }
                    
                    // Deduplicate forecasts
                    const uniqueForecasts = [];
                    const seen = new Set();
                    for (const fc of forecasts) {
                        if (!seen.has(fc.wx)) {
                            seen.add(fc.wx);
                            uniqueForecasts.push(fc);
                        }
                    }
                    
                    if (uniqueForecasts.length > 0 || taf.length > 20) {
                        tafData[icao] = {
                            raw: taf.substring(0, 500),
                            frozenForecasts: uniqueForecasts,
                            conditionChanges: conditionChanges,
                            nextFrozenStart: nextFrozenStart,
                            frozenEndsAt: frozenEndsAt,
                            tempForecasts: tempForecasts,
                            summary: buildTafSummary(conditionChanges, nextFrozenStart, frozenEndsAt)
                        };
                    }
                }
                
                // Count airports with frozen precip forecasts
                let frozenCount = 0;
                for (const icao in tafData) {
                    if (tafData[icao].frozenForecasts.length > 0) frozenCount++;
                }
                console.log('TAFs loaded:', Object.keys(tafData).length, 'airports,', frozenCount, 'with frozen precip');
                
            } catch (e) {
                console.error('TAF fetch failed:', e.message);
                tafData = {};
            }
        }
        
        // Build a human-readable TAF summary for deicing
        function buildTafSummary(changes, frozenStart, frozenEnd) {
            if (!changes || changes.length === 0) return null;
            
            const frozenChanges = changes.filter(c => c.hasFrozen);
            const clearChanges = changes.filter(c => !c.hasFrozen && (c.type === 'FM' || c.hasNSW));
            
            let summary = '';
            
            if (frozenStart) {
                summary = ` ${frozenStart.type} ${frozenStart.timeStr}`;
            }
            
            if (frozenEnd) {
                summary += summary ? ` &#x2192; ` : '';
                summary += `&#x2714; Ends ${frozenEnd.type} ${frozenEnd.timeStr}`;
            }
            
            return summary || null;
        }

        function getFrostRisk(icao, tempC) {
            // Frost risk: below 4 degC during night/early morning hours
            if (tempC === null || tempC > 4) return false;
            
            const localTime = getLocalTime(icao);
            if (!localTime) return false;
            
            const hour = localTime.getHours();
            // High frost risk window: 10pm - 9am when temps are near/below freezing
            return (hour >= 22 || hour < 9) && tempC <= 4;
        }

        // Holdover Time estimation based on FAA HOT guidelines
        // Returns detailed HOT info for Type I, II, and IV fluids
        function estimateHoldoverTime(tempC, weather, weatherIntensity) {
            if (tempC === null) return null;
            
            // Determine precipitation type and intensity
            let precipType = null;
            let intensity = 'moderate';
            
            for (const wx of weather) {
                const baseWx = wx.replace(/^[+-]/, '');
                const wxIntensity = wx.startsWith('+') ? 'heavy' : wx.startsWith('-') ? 'light' : 
                    (weatherIntensity && weatherIntensity[baseWx]) || 'moderate';
                
                if (baseWx.includes('FZRA') || baseWx === 'FZRA') {
                    precipType = 'freezing_rain';
                    intensity = wxIntensity;
                } else if (baseWx.includes('FZDZ') || baseWx === 'FZDZ') {
                    precipType = 'freezing_drizzle';
                    intensity = wxIntensity;
                } else if (baseWx === 'PL' || baseWx.includes('PL')) {
                    precipType = 'ice_pellets';
                    intensity = wxIntensity;
                } else if (baseWx === 'SN' || baseWx.includes('SN')) {
                    precipType = 'snow';
                    intensity = wxIntensity;
                } else if (baseWx === 'SG') {
                    precipType = 'snow_grains';
                    intensity = wxIntensity;
                } else if (baseWx === 'FZFG' || baseWx.includes('FZFG')) {
                    precipType = 'freezing_fog';
                    intensity = 'moderate';
                } else if ((baseWx === 'RA' || baseWx.includes('RA')) && tempC <= 0) {
                    // Rain at/below freezing = potential for ice
                    precipType = 'rain_freezing_surface';
                    intensity = wxIntensity;
                }
            }
            
            if (!precipType) return null;
            
            // FAA HOT Table values (approximate ranges in minutes)
            // Based on FAA Holdover Time Guidelines
            const hotTables = {
                // Type I (heated, diluted) - shortest times, used for deicing
                typeI: {
                    freezing_rain: { light: [5, 9], moderate: [2, 5], heavy: [0, 2] },
                    freezing_drizzle: { light: [9, 15], moderate: [6, 9], heavy: [2, 6] },
                    snow: {
                        // Varies by temp
                        light: tempC >= -3 ? [11, 17] : tempC >= -14 ? [8, 15] : [6, 11],
                        moderate: tempC >= -3 ? [6, 11] : tempC >= -14 ? [5, 9] : [4, 7],
                        heavy: tempC >= -3 ? [0, 6] : tempC >= -14 ? [0, 5] : [0, 4]
                    },
                    snow_grains: { light: [8, 15], moderate: [5, 8], heavy: [2, 5] },
                    ice_pellets: { light: [5, 10], moderate: [2, 5], heavy: [0, 2] },
                    freezing_fog: { light: [15, 25], moderate: [10, 15], heavy: [5, 10] },
                    rain_freezing_surface: { light: [3, 6], moderate: [1, 3], heavy: [0, 1] }
                },
                // Type IV (thickened, longer protection) - longest times
                typeIV: {
                    freezing_rain: { light: [15, 25], moderate: [8, 15], heavy: [3, 8] },
                    freezing_drizzle: { light: [25, 45], moderate: [15, 25], heavy: [8, 15] },
                    snow: {
                        light: tempC >= -3 ? [35, 65] : tempC >= -14 ? [25, 50] : [18, 35],
                        moderate: tempC >= -3 ? [20, 40] : tempC >= -14 ? [15, 30] : [10, 20],
                        heavy: tempC >= -3 ? [10, 20] : tempC >= -14 ? [8, 15] : [5, 10]
                    },
                    snow_grains: { light: [30, 55], moderate: [18, 30], heavy: [10, 18] },
                    ice_pellets: { light: [10, 20], moderate: [5, 10], heavy: [2, 5] },
                    freezing_fog: { light: [45, 75], moderate: [30, 45], heavy: [15, 30] },
                    rain_freezing_surface: { light: [8, 15], moderate: [3, 8], heavy: [0, 3] }
                }
            };
            
            const typeIHot = hotTables.typeI[precipType]?.[intensity] || [0, 5];
            const typeIVHot = hotTables.typeIV[precipType]?.[intensity] || [5, 15];
            
            // Get the range values
            const typeIRange = Array.isArray(typeIHot) ? typeIHot : [typeIHot, typeIHot];
            const typeIVRange = Array.isArray(typeIVHot) ? typeIVHot : [typeIVHot, typeIVHot];
            
            // Determine urgency status
            let status = 'ok';
            if (typeIVRange[1] <= 10) status = 'critical';
            else if (typeIVRange[1] <= 20) status = 'short';
            else if (typeIVRange[1] <= 35) status = 'caution';
            
            // Friendly precip name
            const precipNames = {
                freezing_rain: 'FZRA',
                freezing_drizzle: 'FZDZ',
                snow: 'Snow',
                snow_grains: 'SG',
                ice_pellets: 'PL',
                freezing_fog: 'FZFG',
                rain_freezing_surface: 'RA/Cold'
            };
            
            return {
                precipType: precipType,
                precipName: precipNames[precipType] || precipType,
                intensity: intensity,
                typeI: { min: typeIRange[0], max: typeIRange[1] },
                typeIV: { min: typeIVRange[0], max: typeIVRange[1] },
                status: status,
                recommendation: status === 'critical' ? 'Two-step deice required' :
                               status === 'short' ? 'Use Type IV, minimize taxi time' :
                               status === 'caution' ? 'Type IV recommended' : 'Standard procedures'
            };
        }

        // Extract field condition info from METAR remarks (for braking action)
        function extractFieldConditions(metar) {
            if (!metar) return null;
            
            const result = {
                brakingAction: null,
                ficonReports: []
            };
            
            // Look for FICON (Field Condition) in remarks
            // Formats: FICON 5/5/5, MU45, BRAKING GOOD/FAIR/POOR/NIL
            const muMatch = metar.match(/\bMU(\d{2})/);
            if (muMatch) {
                const mu = parseInt(muMatch[1]);
                if (mu >= 40) result.brakingAction = 'GOOD';
                else if (mu >= 30) result.brakingAction = 'FAIR';
                else if (mu >= 20) result.brakingAction = 'POOR';
                else result.brakingAction = 'NIL';
            }
            
            const brakingMatch = metar.match(/BRAKING\s+(GOOD|FAIR|MEDIUM|POOR|NIL)/i);
            if (brakingMatch) {
                result.brakingAction = brakingMatch[1].toUpperCase();
            }
            
            // Look for FICON reports
            const ficonMatch = metar.match(/FICON[^A-Z].*?(?=\s{2}|$)/i);
            if (ficonMatch) {
                result.ficonReports.push(ficonMatch[0]);
            }
            
            return (result.brakingAction || result.ficonReports.length > 0) ? result : null;
        }

        // Calculate runway availability (simplified - braking action from METAR only)
        function getRunwayStatus(icao, metarRaw) {
            const totalRunways = RUNWAY_COUNT[icao] || 2;
            let brakingAction = null;
            
            // Check METAR for field conditions
            if (metarRaw) {
                const fieldCond = extractFieldConditions(metarRaw);
                if (fieldCond && fieldCond.brakingAction) {
                    brakingAction = fieldCond.brakingAction;
                }
            }
            
            let status = 'good';
            
            // Braking action affects status
            if (brakingAction === 'NIL') {
                status = 'critical';
            } else if (brakingAction === 'POOR') {
                status = 'limited';
            }
            
            return {
                available: totalRunways,
                total: totalRunways,
                status: status,
                brakingAction: brakingAction,
                closedRunways: []
            };
        }

        // Search and filter functions
        // Store searched airports that aren't in the top 100
        let searchedAirports = {};
        
        async function fetchSingleAirport(icao) {
            try {
                // Fetch METAR
                const metarUrl = `https://aviationweather.gov/api/data/metar?ids=${icao}&format=raw&hours=6`;
                const text = await tryFetch(metarUrl);
                const metars = text.trim().split('\n').filter(m => m.length > 10);
                
                if (metars.length === 0) return null;
                
                const parsed = metars.map(parseMetar).filter(p => p !== null);
                if (parsed.length === 0) return null;
                
                // Sort by time (newest first)
                parsed.sort((a, b) => (b.obs_time || 0) - (a.obs_time || 0));
                const history = parsed.slice(0, 6);
                const latest = history[0];
                const recentFrozen = checkRecentFrozen(history);
                
                // Also fetch TAF for this airport
                let tafResult = null;
                try {
                    const tafUrl = `https://aviationweather.gov/api/data/taf?ids=${icao}&format=raw`;
                    const tafText = await tryFetch(tafUrl, 0, 20);
                    if (tafText && tafText.length > 20) {
                        tafResult = parseSingleTaf(icao, tafText);
                    }
                } catch (e) {
                    console.log('TAF fetch failed for', icao, e.message);
                }
                
                return {
                    ...latest,
                    history: history,
                    trend: getTrend(history),
                    had_recent_frozen: recentFrozen.hadFrozen,
                    recent_frozen_types: recentFrozen.frozenTypes,
                    last_frozen_time: recentFrozen.lastFrozenTime,
                    hub_airlines: null,
                    rush_status: null,
                    traffic_programs: null,
                    taf: tafResult,
                    frost_risk: getFrostRisk(icao, latest.temp_c),
                    hot_estimate: estimateHoldoverTime(latest.temp_c, latest.weather, null),
                    runway_status: getRunwayStatus(icao, latest.raw),
                    isSearchResult: true
                };
            } catch (e) {
                console.log('Failed to fetch airport:', icao, e.message);
                return null;
            }
        }
        
        // Parse a single TAF (used for search results)
        function parseSingleTaf(icao, tafText) {
            const forecasts = [];
            
            // Look for frozen precip
            const frozenPattern = /\b(\+|-)?((SN)|(FZRA)|(FZDZ)|(PL)|(FZFG)|(GS)|(GR))\b/g;
            const matches = tafText.matchAll(frozenPattern);
            
            for (const match of matches) {
                const wx = match[0].replace(/^[+-]/, '');
                const beforeMatch = tafText.substring(0, match.index);
                const timeMatch = beforeMatch.match(/(FM\d{6}|TEMPO\s+\d{4}\/\d{4}|BECMG\s+\d{4}\/\d{4}|\d{4}\/\d{4})\s*[^\n]*$/);
                
                forecasts.push({
                    raw: timeMatch ? timeMatch[0].substring(0, 30) + ' ' + wx : wx,
                    wx: wx
                });
            }
            
            // Deduplicate
            const uniqueForecasts = [];
            const seen = new Set();
            for (const fc of forecasts) {
                if (!seen.has(fc.wx)) {
                    seen.add(fc.wx);
                    uniqueForecasts.push(fc);
                }
            }
            
            return {
                raw: tafText.substring(0, 500),
                frozenForecasts: uniqueForecasts
            };
        }
        
        // Debounce timer for search
        let filterTimeout = null;
        function debouncedFilter() {
            if (filterTimeout) clearTimeout(filterTimeout);
            filterTimeout = setTimeout(() => filterAirports(), 300);
        }
        
        async function filterAirports() {
            let searchInput = document.getElementById('searchInput').value.toUpperCase().trim();
            console.log('filterAirports called with:', searchInput);
            
            // Try to resolve IATA to ICAO
            const iataPattern = /^[A-Z]{3}$/;
            const icaoPattern = /^[A-Z]{4}$/;
            let resolvedICAO = null;
            
            if (iataPattern.test(searchInput)) {
                // 3-letter code - try to resolve as IATA
                resolvedICAO = resolveToICAO(searchInput);
                if (resolvedICAO) {
                    console.log(`Resolved IATA ${searchInput} to ICAO ${resolvedICAO}`);
                    searchInput = resolvedICAO;
                } else {
                    console.log(`Could not resolve IATA ${searchInput}, IATA_TO_ICAO has ${Object.keys(IATA_TO_ICAO).length} entries`);
                }
            }
            
            currentSearchTerm = searchInput;
            console.log('currentSearchTerm set to:', currentSearchTerm);
            
            // Check if this looks like an ICAO code not in our list
            if (icaoPattern.test(currentSearchTerm) && !AIRPORTS.includes(currentSearchTerm)) {
                console.log('Fetching non-top-100 airport:', currentSearchTerm);
                // Try to fetch this airport
                const searchStatus = document.getElementById('searchStatus');
                if (!searchStatus) {
                    const searchBox = document.querySelector('.search-box');
                    const statusDiv = document.createElement('div');
                    statusDiv.id = 'searchStatus';
                    statusDiv.style.cssText = 'font-size:11px;color:#4a90d9;margin-top:5px;text-align:center;';
                    searchBox.parentNode.insertBefore(statusDiv, searchBox.nextSibling);
                }
                
                const displayCode = resolvedICAO ? `${document.getElementById('searchInput').value.toUpperCase()} (${currentSearchTerm})` : currentSearchTerm;
                document.getElementById('searchStatus').textContent = ` Searching for ${displayCode}...`;
                
                const airport = await fetchSingleAirport(currentSearchTerm);
                
                if (airport) {
                    searchedAirports[currentSearchTerm] = airport;
                    document.getElementById('searchStatus').textContent = ` Found ${displayCode}`;
                    setTimeout(() => {
                        const el = document.getElementById('searchStatus');
                        if (el) el.textContent = '';
                    }, 3000);
                } else {
                    document.getElementById('searchStatus').textContent = ` No data for ${displayCode}`;
                    setTimeout(() => {
                        const el = document.getElementById('searchStatus');
                        if (el) el.textContent = '';
                    }, 3000);
                }
            } else {
                console.log('Filtering top 110 airports for:', currentSearchTerm);
            }
            
            renderFilteredResults();
        }

        function clearSearch() {
            document.getElementById('searchInput').value = '';
            currentSearchTerm = '';
            searchedAirports = {};
            const searchStatus = document.getElementById('searchStatus');
            if (searchStatus) searchStatus.textContent = '';
            renderFilteredResults();
        }

        function setRegionFilter(region) {
            currentRegionFilter = region;
            
            // Update button states
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.region === region) btn.classList.add('active');
            });
            
            renderFilteredResults();
        }
        
        function updateWindThreshold() {
            const input = document.getElementById('windThreshold');
            const newThreshold = parseInt(input.value) || 20;
            // Clamp to reasonable range
            windThreshold = Math.max(5, Math.min(100, newThreshold));
            input.value = windThreshold;
            // Re-render to update counts and section
            renderFilteredResults();
        }

        function airportMatchesFilter(icao) {
            // Check if airport is excluded by user settings (unless searching specifically for it)
            if (!currentSearchTerm && excludedAirports.includes(icao)) {
                return false;
            }
            
            // Check search term
            if (currentSearchTerm) {
                const name = getAirportName(icao);
                const info = getAirportInfo(icao);
                const iata = info?.iata || '';
                const city = info?.city || '';
                
                const searchUpper = currentSearchTerm.toUpperCase();
                if (!icao.includes(searchUpper) && 
                    !name.toUpperCase().includes(searchUpper) &&
                    !iata.toUpperCase().includes(searchUpper) &&
                    !city.toUpperCase().includes(searchUpper)) {
                    return false;
                }
            }
            
            // Check region filter
            if (currentRegionFilter !== 'all') {
                // Special filter: US only (exclude Canada)
                if (currentRegionFilter === 'us') {
                    if (icao.startsWith('CY')) {
                        return false;
                    }
                }
                // Special filter: Delta hubs
                else if (currentRegionFilter === 'dl-hubs') {
                    if (!DL_HUBS.includes(icao)) {
                        return false;
                    }
                }
                // Special filter: All airline hubs
                else if (currentRegionFilter === 'airline-hubs') {
                    if (!ALL_HUBS.includes(icao)) {
                        return false;
                    }
                }
                // Standard region filter
                else {
                    const regionAirports = AIRPORT_REGIONS[currentRegionFilter] || [];
                    if (!regionAirports.includes(icao)) {
                        return false;
                    }
                }
            }
            
            return true;
        }

        let lastRenderData = null;

        function renderFilteredResults() {
            console.log('renderFilteredResults called');
            console.log('lastRenderData:', !!lastRenderData);
            console.log('searchedAirports count:', Object.keys(searchedAirports).length);
            console.log('currentSearchTerm:', currentSearchTerm);
            
            if (lastRenderData) {
                console.log('Calling renderResults with categories');
                renderResults(lastRenderData.categories, lastRenderData.total);
            } else if (Object.keys(searchedAirports).length > 0) {
                // No main data yet but we have search results - show them
                console.log('No main data, showing search results only');
                const content = document.getElementById('content');
                const searchedAirportsList = Object.values(searchedAirports);
                let html = buildSearchResultsHtml(searchedAirportsList);
                content.innerHTML = html || '<div class="status-msg info">Loading airport data...</div>';
            } else {
                console.log('No data to render');
            }
        }
        
        function buildSearchResultsHtml(searchedAirportsList) {
            if (!searchedAirportsList || searchedAirportsList.length === 0) return '';
            
            let html = `
                <div id="section-search" class="collapsible-section section-search">
                    <div class="section-header" onclick="toggleSection('section-search')" style="background:#1f3d2d;border:1px solid #3a8c5a;border-bottom:none;">
                        <h3 style="color:#3ce78c;">&#x1F50D; Search Results (${searchedAirportsList.length})</h3>
                        <span class="section-toggle">&#x25BC;</span>
                    </div>
                    <div class="section-content" style="background:#1a2d25;border:1px solid #3a8c5a;border-top:none;">
                        <div class="airport-list">
            `;
            
            for (const apt of searchedAirportsList) {
                const cat = categorize(apt);
                const catColors = { active: '#e74c3c', likely: '#f39c12', residual: '#9b59b6', possible: '#f1c40f', none: '#2ecc71', unknown: '#888' };
                const catLabels = { active: '&#x1F534; Active', likely: '&#x1F7E0; Likely', residual: '&#x1F7E3; Residual', possible: '&#x1F7E1; Possible', none: '&#x1F7E2; None', unknown: ' Unknown' };
                const catColor = catColors[cat] || '#888';
                const catLabel = catLabels[cat] || cat;
                
                const name = getAirportName(apt.icao);
                const airportInfo = getAirportInfo(apt.icao);
                const iataCode = airportInfo?.iata || '';
                const elevation = airportInfo?.elevation_ft ? `${airportInfo.elevation_ft}ft` : '';
                const wx = formatWeatherDisplay(apt);
                const frClass = `fr-${apt.flight_rules.toLowerCase()}`;
                const metarUrl = `https://aviationweather.gov/data/metar/?id=${apt.icao}&hours=6`;
                const timeSince = getTimeSince(apt.obs_time);
                const historyId = `history-search-${apt.icao}`;
                
                currentWindData[apt.icao] = {
                    direction: (apt.wind_variable || apt.wind_dir === 'VRB') ? null : apt.wind_dir,
                    speed: apt.wind_speed, gust: apt.wind_gust,
                    variable: apt.wind_variable || apt.wind_dir === 'VRB'
                };
                
                let windHtml = '';
                if (apt.wind_speed !== null) {
                    let windText = apt.wind_variable ? `VRB${apt.wind_speed}kt` : 
                        apt.wind_dir !== null ? `${String(apt.wind_dir).padStart(3, '0')}&deg;/${apt.wind_speed}kt` : `${apt.wind_speed}kt`;
                    if (apt.wind_gust) windText += `G${apt.wind_gust}`;
                    windHtml = `<span class="wind-info"> ${windText}</span>`;
                }
                
                const icaoDisplay = iataCode ? `${apt.icao}/${iataCode}` : apt.icao;
                
                html += `
                    <div class="airport-card" onclick="toggleHistory('${historyId}')" style="border-left:3px solid ${catColor};">
                        <div class="airport-main">
                            <div class="left">
                                <div class="icao" style="background:${catColor}22;">${icaoDisplay}</div>
                                <div>
                                    <div class="name">
                                        <a href="${metarUrl}" target="_blank" onclick="event.stopPropagation();">${name} </a>
                                        <button class="runway-map-btn" onclick="showRunwayMap('${apt.icao}', event)">&#x1F6EB; Map</button>
                                        <span style="margin-left:8px;font-size:10px;color:${catColor};">${catLabel}</span>
                                    </div>
                                    <div class="weather">${wx} <span class="flight-rules ${frClass}">${apt.flight_rules}</span> ${windHtml}</div>
                                    <div class="obs-time ${timeSince.stale ? 'stale' : ''}">${timeSince.zulu} &bull; ${timeSince.text}${elevation ? ` &bull; Elev: ${elevation}` : ''}</div>
                                    ${apt.taf && apt.taf.raw ? `
                                        <div class="taf-forecast" style="cursor:pointer;" onclick="toggleTafInline(document.getElementById('taf-bld-${apt.icao}')); event.stopPropagation();">
                                            &#x1F4CB; TAF: <span style="color:${apt.taf.frozenForecasts && apt.taf.frozenForecasts.length > 0 ? '#9b59b6' : '#4a90d9'};">${apt.taf.frozenForecasts && apt.taf.frozenForecasts.length > 0 ? apt.taf.frozenForecasts[0].wx : 'Available'}</span>
                                            <span style="color:#666;font-size:9px;margin-left:4px;">&#x25BC; expand</span>
                                        </div>
                                        <div class="taf-inline" id="taf-bld-${apt.icao}" onclick="toggleTafInline(this); event.stopPropagation();">${apt.taf.raw}</div>
                                    ` : ''}
                                </div>
                            </div>
                            <div class="right">
                                <div class="trend ${apt.trend.class}" title="${apt.trend.text}">${apt.trend.symbol}</div>
                                <div class="temp">
                                    <div class="temp-value">${tempToF(apt.temp_c)}&deg;F</div>
                                    <div class="temp-f">${apt.temp_c}&deg;C</div>
                                </div>
                            </div>
                        </div>
                        <div class="expand-hint">Tap to see history</div>
                    </div>
                `;
            }
            
            html += `</div></div></div>`;
            return html;
        }

        function tempToF(c) {
            return Math.round(c * 9/5 + 32);
        }
        
        // Generate METAR history HTML for expandable sections
        function generateHistoryHtml(apt, historyId) {
            if (!apt.history || apt.history.length === 0) return '';
            
            let historyHtml = `<div class="history" id="${historyId}"><div class="history-title">Last ${apt.history.length} observations</div>`;
            historyHtml += `<div class="history-header"><span class="time">Time (Z/Local)</span><span class="ceiling">Ceil</span><span class="wx">Weather</span><span class="wind">Wind</span><span class="temp">Temp</span></div>`;
            
            for (const h of apt.history) {
                const hTimeData = formatObsTime(h.obs_time);
                const hTime = hTimeData.combined;
                const hCeiling = h.ceiling_text || '';
                const hWx = formatHistoryWeather(h);
                const hWind = h.wind_speed !== null ? 
                    (h.wind_variable ? `VRB${h.wind_speed}` : `${h.wind_speed}kt`) + (h.wind_gust ? `G${h.wind_gust}` : '') : '';
                const hTemp = h.temp_c !== null ? `${tempToF(h.temp_c)}F/${h.temp_c}C` : 'N/A';
                // Highlight rows with frozen precip
                const hasFrozen = h.weather && h.weather.some(w => {
                    const stripped = w.replace(/^[-+]/, '');
                    return FROZEN_PRECIP.some(code => stripped === code || stripped.includes(code));
                });
                const rowStyle = hasFrozen ? 'background: #3d2850;' : '';
                historyHtml += `<div class="history-row" style="${rowStyle}"><span class="time">${hTime}</span><span class="ceiling">${hCeiling}</span><span class="wx">${hWx}</span><span class="wind">${hWind}</span><span class="temp">${hTemp}</span></div>`;
            }
            historyHtml += '</div>';
            return historyHtml;
        }

        function getTimeSince(obsTime) {
            if (!obsTime) return { text: 'N/A', stale: false, zulu: '' };
            const now = new Date();
            const diffMs = now - obsTime;
            const diffMins = Math.floor(diffMs / 60000);
            
            // Format Zulu time (e.g., "1852Z")
            const zuluTime = obsTime.getUTCHours().toString().padStart(2, '0') + 
                            obsTime.getUTCMinutes().toString().padStart(2, '0') + 'Z';
            
            if (diffMins < 60) {
                return { text: `${diffMins}m ago`, stale: diffMins > 90, zulu: zuluTime };
            } else {
                const hours = Math.floor(diffMins / 60);
                const mins = diffMins % 60;
                return { text: `${hours}h ${mins}m ago`, stale: hours >= 2, zulu: zuluTime };
            }
        }
        
        // Format time for history rows: "1852Z / 1:52 PM EST"
        function formatObsTime(obsTime) {
            if (!obsTime) return { zulu: 'N/A', local: '', combined: 'N/A' };
            
            const zuluTime = obsTime.getUTCHours().toString().padStart(2, '0') + 
                            obsTime.getUTCMinutes().toString().padStart(2, '0') + 'Z';
            const localTime = obsTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', timeZoneName: 'short'});
            
            return {
                zulu: zuluTime,
                local: localTime,
                combined: `${zuluTime} / ${localTime}`
            };
        }

        function getTrend(history) {
            if (!history || history.length < 2) return { symbol: '&mdash;', class: 'steady', text: 'No trend data' };
            
            // Get temps from oldest to newest (history is newest first, so reverse)
            const temps = history.map(h => h.temp_c).filter(t => t !== null).reverse();
            if (temps.length < 2) return { symbol: '&mdash;', class: 'steady', text: 'No trend data' };
            
            const oldest = temps[0];
            const newest = temps[temps.length - 1];
            const diff = newest - oldest;
            
            if (diff >= 3) return { symbol: '&#x2191;', class: 'warming', text: `+${diff}&deg; over ${temps.length} obs` };
            if (diff <= -3) return { symbol: '', class: 'cooling', text: `${diff}&deg; over ${temps.length} obs` };
            return { symbol: '&#x2192;', class: 'steady', text: 'Steady' };
        }

        async function tryFetch(url, proxyIndex = 0, minLength = 10) {
            if (proxyIndex >= CORS_PROXIES.length) {
                console.warn('All fetch methods failed for:', url.substring(0, 60));
                return ''; // Return empty string instead of throwing
            }
            
            const proxyUrl = CORS_PROXIES[proxyIndex](url);
            
            try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 20000);
                
                const response = await fetch(proxyUrl, { 
                    signal: controller.signal,
                    headers: { 
                        'Accept': 'text/plain, application/json, */*',
                        'User-Agent': 'AirportDeicingMonitor/1.0'
                    }
                });
                clearTimeout(timeout);
                
                if (!response.ok) {
                    console.log(`Proxy ${proxyIndex} returned HTTP ${response.status} for ${url.substring(0,50)}`);
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const text = await response.text();
                console.log(`Proxy ${proxyIndex} returned ${text.length} bytes for ${url.substring(0,50)}`);
                
                if (!text || text.length < minLength) {
                    throw new Error('Response too short: ' + text.length);
                }
                return text;
            } catch (e) {
                console.log(`Proxy ${proxyIndex} failed for ${url.substring(0,50)}:`, e.message);
                return tryFetch(url, proxyIndex + 1, minLength);
            }
        }

        async function fetchData() {
            const btn = document.getElementById('refreshBtn');
            const content = document.getElementById('content');
            
            btn.disabled = true;
            btn.textContent = 'Loading...';
            
            content.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <div>Fetching METAR and TAF data...</div>
                    <div id="loadingStatus" style="font-size: 11px; color: #666; margin-top: 10px;"></div>
                </div>
            `;
            
            const updateStatus = (msg) => {
                const el = document.getElementById('loadingStatus');
                if (el) el.innerHTML += msg + '<br>';
            };

            try {
                // Fetch all data sources in parallel
                const trafficPromise = fetchTrafficManagement();
                const advisoryPromise = fetchFAAAdvisory();
                const tafPromise = fetchTAFs();
                const nwsPromise = fetchAllNWSForecasts(); // NWS forecast temps
                
                let metars = [];
                
                // Try fetching all airports at once first
                const ids = AIRPORTS.join(',');
                const baseUrl = `https://aviationweather.gov/api/data/metar?ids=${ids}&format=raw&hours=6`;
                
                let text = await tryFetch(baseUrl);
                // Match both US (KXXX) and Canadian (CYXX) airports
                metars = text.trim().split('\n').filter(m => m.length > 10 && m.match(/(?:K[A-Z]{3}|C[A-Z]{3})/));
                
                // If main request failed, try fetching in smaller batches
                if (metars.length === 0) {
                    console.log('Main METAR fetch failed, trying smaller batches...');
                    updateStatus('Trying alternative fetch method...');
                    
                    // Try just the top 25 airports
                    const top25 = AIRPORTS.slice(0, 25).join(',');
                    const fallbackUrl = `https://aviationweather.gov/api/data/metar?ids=${top25}&format=raw&hours=2`;
                    text = await tryFetch(fallbackUrl);
                    metars = text.trim().split('\n').filter(m => m.length > 10 && m.match(/(?:K[A-Z]{3}|C[A-Z]{3})/));
                }
                
                // If AWC failed, try UCAR as backup
                if (metars.length === 0) {
                    console.log('AWC METAR fetch failed, trying UCAR backup...');
                    updateStatus('Trying UCAR backup source...');
                    
                    // Try UCAR RAP real-time METAR
                    const ucarUrl = `https://rap.ucar.edu/weather/surface/`;
                    try {
                        text = await tryFetch(ucarUrl);
                        
                        if (text && text.length > 500) {
                            // Parse the HTML page for METAR data
                            const lines = text.split('\n');
                            for (const line of lines) {
                                // Look for METAR lines - they contain station IDs
                                for (const icao of AIRPORTS) {
                                    if (line.includes(icao) && line.match(/\d{6}Z/)) {
                                        // Extract the METAR portion
                                        const metarMatch = line.match(new RegExp(`(${icao}\\s+\\d{6}Z[^<]+)`));
                                        if (metarMatch) {
                                            metars.push(metarMatch[1].trim());
                                        }
                                    }
                                }
                            }
                            console.log('UCAR returned', metars.length, 'METARs');
                            if (metars.length > 0) {
                                updateStatus(`UCAR: ${metars.length} airports &#x2714;`);
                            }
                        }
                    } catch (e) {
                        console.log('UCAR fetch error:', e.message);
                    }
                }
                
                // If still no data, try NOAA direct (fetch top airports individually)
                if (metars.length === 0) {
                    console.log('UCAR failed, trying NOAA direct...');
                    updateStatus('Trying NOAA direct source...');
                    
                    const topAirports = AIRPORTS.slice(0, 20);
                    const noaaPromises = topAirports.map(async (icao) => {
                        try {
                            const noaaUrl = `https://tgftp.nws.noaa.gov/data/observations/metar/stations/${icao}.TXT`;
                            const response = await tryFetch(noaaUrl);
                            if (response && response.length > 20) {
                                // NOAA format has timestamp on first line, METAR on second
                                const lines = response.trim().split('\n');
                                if (lines.length >= 2) {
                                    return lines[1].trim();
                                }
                            }
                        } catch (e) {
                            // Individual station fetch failed
                        }
                        return null;
                    });
                    
                    const noaaResults = await Promise.all(noaaPromises);
                    metars = noaaResults.filter(m => m && m.length > 10);
                    
                    if (metars.length > 0) {
                        console.log('NOAA returned', metars.length, 'METARs');
                        updateStatus(`NOAA: ${metars.length} airports &#x2714;`);
                    }
                }
                
                if (metars.length === 0) {
                    throw new Error('All METAR sources unavailable. Please try again later.');
                }
                
                // Wait for all other data
                await Promise.all([trafficPromise, advisoryPromise, tafPromise]);
                
                // Parse all METARs
                const allParsed = metars.map(parseMetar).filter(p => p !== null);
                
                // Group by airport
                const byAirport = {};
                for (const p of allParsed) {
                    if (!byAirport[p.icao]) byAirport[p.icao] = [];
                    byAirport[p.icao].push(p);
                }
                
                // Sort each airport's METARs by time (newest first) and keep last 6
                for (const icao in byAirport) {
                    byAirport[icao].sort((a, b) => (b.obs_time || 0) - (a.obs_time || 0));
                    byAirport[icao] = byAirport[icao].slice(0, 6);
                }
                
                // Create airport objects with latest data and history
                const airportData = [];
                for (const icao of AIRPORTS) {
                    if (byAirport[icao] && byAirport[icao].length > 0) {
                        const history = byAirport[icao];
                        const latest = history[0];
                        const recentFrozen = checkRecentFrozen(history);
                        airportData.push({
                            ...latest,
                            history: history,
                            trend: getTrend(history),
                            had_recent_frozen: recentFrozen.hadFrozen,
                            recent_frozen_types: recentFrozen.frozenTypes,
                            last_frozen_time: recentFrozen.lastFrozenTime,
                            // New indicators
                            hub_airlines: getHubInfo(icao),
                            rush_status: getRushStatus(icao),
                            traffic_programs: trafficPrograms[icao] || null,
                            // TAF data
                            taf: tafData[icao] || null,
                            frost_risk: getFrostRisk(icao, latest.temp_c),
                            // HOT estimate
                            hot_estimate: estimateHoldoverTime(latest.temp_c, latest.weather, null),
                            // Runway status (pass raw METAR for braking extraction)
                            runway_status: getRunwayStatus(icao, latest.raw)
                        });
                    }
                }
                
                // Categorize
                const categories = { active: [], likely: [], residual: [], possible: [], marginal: [], none: [] };
                for (const apt of airportData) {
                    const cat = categorize(apt);
                    if (categories[cat]) categories[cat].push(apt);
                }

                // Sort by airport rank (busiest first)
                for (const cat in categories) {
                    categories[cat].sort((a, b) => {
                        const rankA = AIRPORTS.indexOf(a.icao);
                        const rankB = AIRPORTS.indexOf(b.icao);
                        return rankA - rankB;
                    });
                }

                renderResults(categories, airportData.length);
                
                const now = new Date();
                document.getElementById('timestamp').textContent = 
                    `Updated: ${now.toLocaleTimeString()} | ${airportData.length} airports reporting`;

            } catch (error) {
                console.error('FetchData error:', error);
                content.innerHTML = `
                    <div class="error">
                        <strong>Unable to load data</strong><br><br>
                        ${error.message}<br><br>
                        <small>This can happen due to:</small>
                        <ul style="text-align: left; margin: 10px 0;">
                            <li>CORS proxy services being temporarily unavailable</li>
                            <li>Aviation Weather Center API issues</li>
                            <li>Network connectivity problems</li>
                            <li>Browser security settings blocking requests</li>
                        </ul>
                        <small>Check browser console (F12) for details.</small>
                        <br>
                        <button onclick="fetchData()">Try Again</button>
                    </div>
                `;
            }

            btn.disabled = false;
            btn.textContent = ' Refresh';
        }

        function renderResults(categories, total) {
            // Store data for filtering
            lastRenderData = { categories, total };
            
            const content = document.getElementById('content');
            
            // Apply filters to categories
            const filteredCategories = {
                active: categories.active.filter(a => airportMatchesFilter(a.icao)),
                residual: categories.residual.filter(a => airportMatchesFilter(a.icao)),
                likely: categories.likely.filter(a => airportMatchesFilter(a.icao)),
                possible: categories.possible.filter(a => airportMatchesFilter(a.icao)),
                marginal: categories.marginal.filter(a => airportMatchesFilter(a.icao)),
                none: categories.none.filter(a => airportMatchesFilter(a.icao))
            };
            
            // Calculate counts for dashboard cards
            const affectedAirportsForCount = Object.keys(trafficPrograms).filter(icao => airportMatchesFilter(icao));
            let atcCount = 0;
            let arrDepCount = 0;
            let atcHubs = [];
            let arrDepHubs = [];
            for (const icao of affectedAirportsForCount) {
                const programs = trafficPrograms[icao];
                for (const prog of programs) {
                    // GDP and Ground Stop go in ATC count
                    if (prog.type === 'GDP' || prog.type === 'GROUND STOP') {
                        atcCount++;
                        if (DL_HUBS.includes(icao)) atcHubs.push(icao);
                    }
                    // Arrival and Departure delays in separate count
                    if (prog.type === 'ARR DELAY' || prog.type === 'DEP DELAY') {
                        arrDepCount++;
                        if (DL_HUBS.includes(icao)) arrDepHubs.push(icao);
                    }
                }
            }
            const atcHasHub = atcHubs.length > 0;
            const arrDepHasHub = arrDepHubs.length > 0;
            
            const deicingProgCount = Object.keys(trafficPrograms)
                .filter(icao => airportMatchesFilter(icao) && 
                    trafficPrograms[icao].some(p => p.type === 'DEICING')).length;
            
            const closureAirportsForHub = Object.keys(faaAdvisoryData.runwayClosures)
                .filter(icao => airportMatchesFilter(icao));
            const closureCount = closureAirportsForHub.length;
            const closureHasHub = closureAirportsForHub.some(icao => DL_HUBS.includes(icao));
            
            const plannedAirportsForHub = Object.keys(faaAdvisoryData.terminalPlanned)
                .filter(icao => airportMatchesFilter(icao));
            const plannedCount = plannedAirportsForHub.length;
            const plannedHasHub = plannedAirportsForHub.some(icao => DL_HUBS.includes(icao));
            
            // Count TAF warnings
            let tafCount = 0;
            let tafHubs = [];
            for (const icao of Object.keys(tafData)) {
                if (!airportMatchesFilter(icao)) continue;
                const taf = tafData[icao];
                if (taf && taf.frozenForecasts && taf.frozenForecasts.length > 0) {
                    tafCount++;
                    if (DL_HUBS.includes(icao)) tafHubs.push(icao);
                }
            }
            const tafHasHub = tafHubs.length > 0;
            
            // Count frost risk airports
            const allAirportsForFrost = [
                ...filteredCategories.active,
                ...filteredCategories.residual,
                ...filteredCategories.likely,
                ...filteredCategories.possible,
                ...filteredCategories.marginal,
                ...filteredCategories.none
            ];
            const frostAirportsForHub = allAirportsForFrost.filter(apt => apt.frost_risk);
            const frostCount = frostAirportsForHub.length;
            const frostHasHub = frostAirportsForHub.some(apt => DL_HUBS.includes(apt.icao));
            
            // Count non-frozen precipitation (rain, drizzle, showers - but not snow/ice/freezing)
            const precipAirportsForHub = allAirportsForFrost.filter(apt => {
                if (!apt.weather || apt.weather.length === 0) return false;
                // Check if has non-frozen precip
                const nonFrozenPrecip = ['RA', 'DZ', 'SHRA', 'TSRA', 'SHGR', 'UP'];
                for (const wx of apt.weather) {
                    const stripped = wx.replace(/^[-+]/, '');
                    // Has rain/drizzle but NOT frozen
                    for (const code of nonFrozenPrecip) {
                        if (stripped.includes(code) && !stripped.includes('FZ')) {
                            return true;
                        }
                    }
                }
                return false;
            });
            const precipCount = precipAirportsForHub.length;
            const precipHasHub = precipAirportsForHub.some(apt => DL_HUBS.includes(apt.icao));
            
            // Count runway alerts
            let runwayAlertCount = 0;
            for (const apt of allAirportsForFrost) {
                const status = apt.runway_status;
                if (status && (status.status === 'critical' || status.brakingAction === 'NIL' || status.brakingAction === 'POOR')) {
                    runwayAlertCount++;
                }
            }
            
            // Count LIFR and IFR airports
            const lifrCount = allAirportsForFrost.filter(apt => apt.flight_rules === 'LIFR').length;
            const ifrCount = allAirportsForFrost.filter(apt => apt.flight_rules === 'IFR').length;
            
            // Count TAF LIFR and IFR forecasts
            let tafLifrCount = 0;
            let tafIfrCount = 0;
            for (const icao of AIRPORTS) {
                if (!airportMatchesFilter(icao)) continue;
                const taf = tafData[icao];
                if (taf && taf.raw) {
                    // Check for LIFR conditions in TAF (visibility < 1SM or ceiling < 500)
                    // Look for VV001-004, BKN/OVC001-004, or visibility like 1/4SM, 1/2SM
                    const raw = taf.raw;
                    if (/\b(VV00[0-4]|BKN00[0-4]|OVC00[0-4]|[0-9]\/[0-9]SM|M1\/4SM)\b/.test(raw)) {
                        tafLifrCount++;
                    } else if (/\b(VV00[5-9]|BKN00[5-9]|OVC00[5-9]|BKN010|OVC010|1SM|2SM)\b/.test(raw)) {
                        tafIfrCount++;
                    }
                }
            }
            
            // Count high wind airports and check for Delta hubs
            const highWindAirportsTemp = allAirportsForFrost.filter(apt => {
                const speed = apt.wind_speed || 0;
                const gust = apt.wind_gust || 0;
                return speed >= windThreshold || gust >= windThreshold;
            });
            const highWindCount = highWindAirportsTemp.length;
            const highWindHasHub = highWindAirportsTemp.some(apt => DL_HUBS.includes(apt.icao));
            
            // Count active thunderstorms (TS in current METAR weather)
            const tstormCount = allAirportsForFrost.filter(apt => {
                return apt.weather && apt.weather.some(wx => wx.includes('TS'));
            }).length;
            
            // Count TAF thunderstorms
            let tafTstormCount = 0;
            for (const icao of AIRPORTS) {
                if (!airportMatchesFilter(icao)) continue;
                const taf = tafData[icao];
                if (taf && taf.raw && /\bTS\b/.test(taf.raw)) {
                    tafTstormCount++;
                }
            }
            
            // Count TAF high winds (sustained or gusts at/above threshold)
            let tafWindCount = 0;
            for (const icao of AIRPORTS) {
                if (!airportMatchesFilter(icao)) continue;
                const taf = tafData[icao];
                if (taf && taf.raw) {
                    // Match wind patterns like 25015G25KT or 31030KT
                    const windMatches = taf.raw.matchAll(/\b(\d{3}|VRB)(\d{2,3})(G(\d{2,3}))?KT\b/g);
                    for (const match of windMatches) {
                        const speed = parseInt(match[2]);
                        const gust = match[4] ? parseInt(match[4]) : 0;
                        if (speed >= windThreshold || gust >= windThreshold) {
                            tafWindCount++;
                            break; // Only count airport once
                        }
                    }
                }
            }
            
            // Count temperature categories
            // Freezing: <= 32F (0C)
            // Approaching Freeze: 33-40F (1-4C) AND trending down
            // Normal: 41-89F (5-31C)
            // Hot: >= 90F (32C)
            const tempFreezingAirports = allAirportsForFrost.filter(apt => {
                const tempF = apt.temp_c !== null ? Math.round(apt.temp_c * 9/5 + 32) : null;
                return tempF !== null && tempF <= 32;
            });
            
            const tempApproachAirports = allAirportsForFrost.filter(apt => {
                const tempF = apt.temp_c !== null ? Math.round(apt.temp_c * 9/5 + 32) : null;
                // Show all airports in 33-40F range (near freezing)
                return tempF !== null && tempF > 32 && tempF <= 40;
            });
            
            const tempNormalAirports = allAirportsForFrost.filter(apt => {
                const tempF = apt.temp_c !== null ? Math.round(apt.temp_c * 9/5 + 32) : null;
                return tempF !== null && tempF >= 41 && tempF <= 89;
            });
            
            const tempHotAirports = allAirportsForFrost.filter(apt => {
                const tempF = apt.temp_c !== null ? Math.round(apt.temp_c * 9/5 + 32) : null;
                return tempF !== null && tempF >= 90;
            });
            
            // Count NWS forecast temperature categories
            let tafTempFreezingCount = 0;
            let tafTempApproachCount = 0;
            let tafTempNormalCount = 0;
            let tafTempHotCount = 0;
            
            for (const icao of AIRPORTS) {
                if (!airportMatchesFilter(icao)) continue;
                const nws = nwsForecastData[icao];
                if (nws) {
                    const lowTempF = nws.lowTempF;
                    const highTempF = nws.highTempF;
                    
                    // Categorize based on forecast temps
                    if (lowTempF !== null && lowTempF <= 32) {
                        tafTempFreezingCount++;
                    } else if (lowTempF !== null && lowTempF > 32 && lowTempF <= 40) {
                        tafTempApproachCount++;
                    } else if (highTempF !== null && highTempF >= 90) {
                        tafTempHotCount++;
                    } else if (lowTempF !== null || highTempF !== null) {
                        // Has temp data but doesn't fit other categories
                        tafTempNormalCount++;
                    }
                }
            }
            
            // Helper function to check if any airport in a list is a Delta hub
            const hasDeltaHub = (airports) => airports.some(apt => {
                const icao = apt.icao || apt;
                return DL_HUBS.includes(icao);
            });
            
            // Check Delta hubs for each category
            const activeHasHub = hasDeltaHub(filteredCategories.active);
            const residualHasHub = hasDeltaHub(filteredCategories.residual);
            const likelyHasHub = hasDeltaHub(filteredCategories.likely);
            const possibleHasHub = hasDeltaHub(filteredCategories.possible);
            
            // LIFR/IFR hub checks
            const lifrAirportsForHub = allAirportsForFrost.filter(apt => apt.flight_category === 'LIFR');
            const ifrAirportsForHub = allAirportsForFrost.filter(apt => apt.flight_category === 'IFR');
            const lifrHasHub = hasDeltaHub(lifrAirportsForHub);
            const ifrHasHub = hasDeltaHub(ifrAirportsForHub);
            
            // Thunderstorm hub check
            const tstormAirportsForHub = allAirportsForFrost.filter(apt => apt.weather && apt.weather.some(wx => wx.includes('TS')));
            const tstormHasHub = hasDeltaHub(tstormAirportsForHub);
            
            // Temperature hub checks
            const tempFreezingHasHub = hasDeltaHub(tempFreezingAirports);
            const tempApproachHasHub = hasDeltaHub(tempApproachAirports);
            const tempHotHasHub = hasDeltaHub(tempHotAirports);
            
            // TAF hub checks
            let tafLifrHubs = [], tafIfrHubs = [], tafTstormHubs = [], tafWindHubs = [];
            let tafTempFreezingHubs = [], tafTempApproachHubs = [], tafTempHotHubs = [];
            for (const icao of AIRPORTS) {
                if (!airportMatchesFilter(icao)) continue;
                const taf = tafData[icao];
                if (taf && taf.raw) {
                    if (/\b(VV00[0-4]|BKN00[0-4]|OVC00[0-4]|[0-9]\/[0-9]SM|M1\/4SM)\b/.test(taf.raw)) {
                        tafLifrHubs.push(icao);
                    } else if (/\b(VV00[5-9]|BKN00[5-9]|OVC00[5-9]|BKN010|OVC010|1SM|2SM)\b/.test(taf.raw)) {
                        tafIfrHubs.push(icao);
                    }
                    if (/\bTS\b/.test(taf.raw)) tafTstormHubs.push(icao);
                    const windMatches = taf.raw.matchAll(/\b(\d{3}|VRB)(\d{2,3})(G(\d{2,3}))?KT\b/g);
                    for (const match of windMatches) {
                        const speed = parseInt(match[2]);
                        const gust = match[4] ? parseInt(match[4]) : 0;
                        if (speed >= windThreshold || gust >= windThreshold) {
                            tafWindHubs.push(icao);
                            break;
                        }
                    }
                }
                // TAF temp checks
                const nwsForecast = nwsForecastData[icao];
                if (nwsForecast && nwsForecast.low !== null) {
                    if (nwsForecast.low <= 32) tafTempFreezingHubs.push(icao);
                    else if (nwsForecast.low <= 40) tafTempApproachHubs.push(icao);
                }
                if (nwsForecast && nwsForecast.high !== null && nwsForecast.high >= 90) {
                    tafTempHotHubs.push(icao);
                }
            }
            const tafLifrHasHub = hasDeltaHub(tafLifrHubs);
            const tafIfrHasHub = hasDeltaHub(tafIfrHubs);
            const tafTstormHasHub = hasDeltaHub(tafTstormHubs);
            const tafWindHasHub = hasDeltaHub(tafWindHubs);
            const tafTempFreezingHasHub = hasDeltaHub(tafTempFreezingHubs);
            const tafTempApproachHasHub = hasDeltaHub(tafTempApproachHubs);
            const tafTempHotHasHub = hasDeltaHub(tafTempHotHubs);
            
            // Update dashboard cards with hub indicators
            updateDashboardCard('active', filteredCategories.active.length, activeHasHub);
            updateDashboardCard('residual', filteredCategories.residual.length, residualHasHub);
            updateDashboardCard('likely', filteredCategories.likely.length, likelyHasHub);
            updateDashboardCard('possible', filteredCategories.possible.length, possibleHasHub);
            updateDashboardCard('atc', atcCount, atcHasHub);
            updateDashboardCard('arr-dep', arrDepCount, arrDepHasHub);
            updateDashboardCard('taf', tafCount, tafHasHub);
            updateDashboardCard('frost', frostCount, frostHasHub);
            updateDashboardCard('precip', precipCount, precipHasHub);
            updateDashboardCard('closure', closureCount, closureHasHub);
            updateDashboardCard('planned', plannedCount, plannedHasHub);
            
            // AFP, VIP, Rocket, Staffing counts with hub checking
            const afpProgramsForHub = faaAdvisoryData.afpPrograms || [];
            const vipMovementsForHub = faaAdvisoryData.vipMovements || [];
            const staffingTriggersForHub = faaAdvisoryData.staffingTriggers || [];
            
            const afpCount = afpProgramsForHub.length;
            const vipCount = vipMovementsForHub.length;
            const staffingCount = staffingTriggersForHub.length;
            
            // Delta hub codes to search for (IATA codes commonly used in FAA advisories)
            const DL_HUB_CODES = ['ATL', 'MSP', 'DTW', 'SLC', 'JFK', 'LGA', 'BOS', 'SEA', 'LAX'];
            
            // Check if any Delta hub appears in AFP programs
            const afpHasHub = afpProgramsForHub.some(prog => 
                DL_HUB_CODES.some(code => prog.toUpperCase().includes(code))
            );
            
            // Check if any Delta hub appears in VIP movements
            const vipHasHub = vipMovementsForHub.some(vip => 
                DL_HUB_CODES.some(code => vip.toUpperCase().includes(code))
            );
            
            // Check if any Delta hub appears in staffing triggers
            const staffingHasHub = staffingTriggersForHub.some(staff => 
                DL_HUB_CODES.some(code => staff.toUpperCase().includes(code))
            );
            
            // Calculate rocket launches within 24 hours
            const rocketTotal = (faaAdvisoryData.plannedLaunches || []).length;
            let rocketWithin24 = 0;
            const now24 = new Date();
            const in24Hours24 = new Date(now24.getTime() + 24 * 60 * 60 * 1000);
            for (const launch of (faaAdvisoryData.plannedLaunches || [])) {
                const parts = launch.split(' | ');
                const times = parts.slice(1);
                for (const time of times) {
                    if (time.includes('PRIMARY')) {
                        const dateMatch = time.match(/(\d{1,2})\/(\d{1,2})\/(\d{2})\s+(\d{2})(\d{2})Z/);
                        if (dateMatch) {
                            const month = parseInt(dateMatch[1]) - 1;
                            const day = parseInt(dateMatch[2]);
                            const year = 2000 + parseInt(dateMatch[3]);
                            const hour = parseInt(dateMatch[4]);
                            const minute = parseInt(dateMatch[5]);
                            const launchDate = new Date(Date.UTC(year, month, day, hour, minute));
                            if (launchDate <= in24Hours24) {
                                rocketWithin24++;
                            }
                        }
                        break;
                    }
                }
            }
            const rocketDisplay = rocketTotal > 0 ? `${rocketWithin24}/${rocketTotal}` : '0';
            
            updateDashboardCard('afp', afpCount, afpHasHub);
            updateDashboardCard('vip', vipCount, vipHasHub);
            updateDashboardCard('rocket', rocketDisplay);
            updateDashboardCard('staffing', staffingCount, staffingHasHub);
            
            // Show/hide FAA fallback button
            const fallbackBtn = document.getElementById('faa-advisory-fallback');
            if (fallbackBtn) {
                fallbackBtn.style.display = faaAdvisoryFetchFailed ? 'flex' : 'none';
            }
            
            updateDashboardCard('none', filteredCategories.none.length);
            updateDashboardCard('lifr', lifrCount, lifrHasHub);
            updateDashboardCard('taf-lifr', tafLifrCount, tafLifrHasHub);
            updateDashboardCard('ifr', ifrCount, ifrHasHub);
            updateDashboardCard('taf-ifr', tafIfrCount, tafIfrHasHub);
            updateDashboardCard('high-wind', highWindCount, highWindHasHub);
            updateDashboardCard('tstorm', tstormCount, tstormHasHub);
            updateDashboardCard('taf-tstorm', tafTstormCount, tafTstormHasHub);
            updateDashboardCard('taf-wind', tafWindCount, tafWindHasHub);
            
            // Update temperature dashboard cards
            updateDashboardCard('temp-freezing', tempFreezingAirports.length, tempFreezingHasHub);
            updateDashboardCard('temp-approach', tempApproachAirports.length, tempApproachHasHub);
            updateDashboardCard('temp-normal', tempNormalAirports.length);
            updateDashboardCard('temp-hot', tempHotAirports.length, tempHotHasHub);
            updateDashboardCard('taf-temp-freezing', tafTempFreezingCount, tafTempFreezingHasHub);
            updateDashboardCard('taf-temp-approach', tafTempApproachCount, tafTempApproachHasHub);
            updateDashboardCard('taf-temp-normal', tafTempNormalCount);
            updateDashboardCard('taf-temp-hot', tafTempHotCount, tafTempHotHasHub);
            
            // Traffic management summary - GDP and Ground Stops only
            let trafficHtml = '';
            const affectedAirports = Object.keys(trafficPrograms)
                .filter(icao => airportMatchesFilter(icao))
                .sort((a, b) => {
                    const rankA = AIRPORTS.indexOf(a);
                    const rankB = AIRPORTS.indexOf(b);
                    // If not in AIRPORTS list, put at end
                    return (rankA === -1 ? 999 : rankA) - (rankB === -1 ? 999 : rankB);
                });
            if (affectedAirports.length > 0) {
                let trafficItems = '';
                let validItemCount = 0;
                for (const icao of affectedAirports) {
                    const programs = trafficPrograms[icao];
                    const name = AIRPORT_NAMES[icao] || icao;
                    for (const prog of programs) {
                        // Only show GDP and Ground Stop in this section
                        if (prog.type !== 'GDP' && prog.type !== 'GROUND STOP') continue;
                        
                        // Get info from FAA Advisory as backup/supplement
                        const advisoryInfo = faaAdvisoryData.terminalActive[icao];
                        // Find matching advisory for this program type
                        let matchingAdvisory = null;
                        if (advisoryInfo) {
                            for (const adv of advisoryInfo) {
                                if (prog.type === 'GDP' && adv.program.includes('GROUND DELAY')) {
                                    matchingAdvisory = adv;
                                    break;
                                } else if (prog.type === 'GROUND STOP' && adv.program.includes('GROUND STOP')) {
                                    matchingAdvisory = adv;
                                    break;
                                }
                            }
                            // Fallback to first advisory if no match
                            if (!matchingAdvisory) matchingAdvisory = advisoryInfo[0];
                        }
                        const advisoryEndTime = matchingAdvisory ? matchingAdvisory.endTime : '';
                        const advisoryProgram = matchingAdvisory ? matchingAdvisory.program : '';
                        
                        // Extract scope from advisory program text (e.g., "GROUND DELAY PROGRAM (DAL MAIN/SUB ONLY)")
                        let advisoryScope = '';
                        const scopeMatch = advisoryProgram.match(/\(([^)]+)\)/);
                        if (scopeMatch) advisoryScope = scopeMatch[1];
                        
                        // Build time/delay display
                        let timeDisplay = '';
                        let ratesDisplay = '';
                        
                        if (prog.type === 'GDP') {
                            // Show end time with both Zulu and local
                            let timeParts = [];
                            
                            // Use prog.endTime first (from XML), then advisory
                            const rawEndTime = prog.endTime || advisoryEndTime || '';
                            if (rawEndTime) {
                                const parsed = parseLocalTimeToZulu(rawEndTime);
                                if (parsed && parsed.combined) {
                                    timeParts.push(`Until: ${parsed.combined}`);
                                } else {
                                    timeParts.push(`Until: ${rawEndTime}`);
                                }
                            }
                            
                            // Show delay durations (avg/max)
                            if (prog.avgDelay) timeParts.push(`Avg: ${prog.avgDelay}`);
                            if (prog.maxDelay) timeParts.push(`Max: ${prog.maxDelay}`);
                            
                            timeDisplay = timeParts.join(' | ');
                            
                            // Build rates/scope display
                            let rateParts = [];
                            const scope = prog.scope || advisoryScope;
                            if (scope) rateParts.push(`Scope: ${scope}`);
                            if (prog.arrivalRate) rateParts.push(`AAR: ${prog.arrivalRate}`);
                            if (prog.departureRate) rateParts.push(`ADR: ${prog.departureRate}`);
                            ratesDisplay = rateParts.join(' | ');
                            
                        } else if (prog.type === 'GROUND STOP') {
                            // Get end time - prefer prog.endTime (from XML) which has local format
                            const rawEndTime = prog.endTime || advisoryEndTime || 'TBD';
                            
                            if (rawEndTime && rawEndTime !== 'TBD') {
                                const parsed = parseLocalTimeToZulu(rawEndTime);
                                if (parsed && parsed.combined) {
                                    timeDisplay = `Until: ${parsed.combined}`;
                                } else {
                                    timeDisplay = `Until: ${rawEndTime}`;
                                }
                            } else {
                                timeDisplay = `End: TBD`;
                            }
                            
                            // Scope for ground stops
                            const scope = prog.scope || advisoryScope;
                            if (scope) ratesDisplay = `Scope: ${scope}`;
                        }
                        
                        // Add constraint reason from FAA Advisory if available
                        const constraint = faaAdvisoryData.terminalConstraints[icao];
                        const reasonText = constraint ? constraint : prog.reason;
                        trafficItems += `
                            <div class="traffic-item">
                                <span class="airport">${icao}</span> ${name} - 
                                <span class="program">${prog.type}</span>
                                ${timeDisplay ? `<div style="color: #f39c12; font-size: 11px; margin-top: 2px;">${timeDisplay}</div>` : ''}
                                ${ratesDisplay ? `<div style="color: #3498db; font-size: 11px;">${ratesDisplay}</div>` : ''}
                                ${reasonText ? `<div class="reason">${reasonText}</div>` : ''}
                            </div>
                        `;
                        validItemCount++;
                    }
                }
                // Only show section if we have valid items
                if (validItemCount > 0) {
                    trafficHtml = `
                        <div id="section-traffic" class="collapsible-section section-traffic ${getSectionClass('section-traffic')}">
                            <div class="section-header" onclick="toggleSection('section-traffic')">
                                <h3>&#x1F6EB; ATC: GDP / GS (${validItemCount})</h3>
                                <span class="section-toggle">${getSectionToggle('section-traffic')}</span>
                            </div>
                            <div class="section-content ${getSectionContentClass('section-traffic')}">
                                ${trafficItems}
                            </div>
                        </div>
                    `;
                }
            }
            
            // Arrival/Departure Delay section
            let arrDepHtml = '';
            const arrDepAirports = Object.keys(trafficPrograms)
                .filter(icao => airportMatchesFilter(icao) && 
                    trafficPrograms[icao].some(p => p.type === 'ARR DELAY' || p.type === 'DEP DELAY'))
                .sort((a, b) => AIRPORTS.indexOf(a) - AIRPORTS.indexOf(b));
            if (arrDepAirports.length > 0) {
                let arrDepItems = '';
                for (const icao of arrDepAirports) {
                    const name = AIRPORT_NAMES[icao] || icao;
                    const programs = trafficPrograms[icao].filter(p => p.type === 'ARR DELAY' || p.type === 'DEP DELAY');
                    for (const prog of programs) {
                        const delayType = prog.type === 'ARR DELAY' ? 'ARRIVAL' : 'DEPARTURE';
                        
                        // Build timing display
                        let timeParts = [];
                        if (prog.startTime) timeParts.push(`Start: ${prog.startTime}Z`);
                        if (prog.endTime) timeParts.push(`End: ${prog.endTime}Z`);
                        
                        // Build delay info
                        let delayInfo = [];
                        if (prog.minDelay && prog.maxDelay) {
                            delayInfo.push(`Delay: ${prog.minDelay}-${prog.maxDelay} min`);
                        } else if (prog.avgDelay) {
                            delayInfo.push(`Avg: ${prog.avgDelay}`);
                        }
                        if (prog.trend) {
                            delayInfo.push(`Trend: ${prog.trend}`);
                        }
                        
                        const timeDisplay = timeParts.length > 0 ? timeParts.join(' | ') : '';
                        const delayDisplay = delayInfo.join(' | ');
                        
                        arrDepItems += `
                            <div class="traffic-item">
                                <span class="airport">${icao}</span> ${name} - 
                                <span class="program">${delayType} DELAY</span>
                                ${timeDisplay ? `<div style="color: #f39c12; font-size: 11px; margin-top: 2px;">${timeDisplay}</div>` : ''}
                                ${delayDisplay ? `<div style="color: #e67e22; font-size: 11px;">${delayDisplay}</div>` : ''}
                                <div class="reason">${prog.reason || ''}</div>
                            </div>
                        `;
                    }
                }
                arrDepHtml = `
                    <div id="section-arr-dep" class="collapsible-section section-arr-dep ${getSectionClass('section-arr-dep')}">
                        <div class="section-header" onclick="toggleSection('section-arr-dep')">
                            <h3>&#x23F1; Arrival/Departure Delays (${arrDepAirports.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-arr-dep')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-arr-dep')}">
                            ${arrDepItems}
                        </div>
                    </div>
                `;
            }
            
            // Deicing Programs section - highlight airports with formal deicing
            const deicingAirports = Object.keys(trafficPrograms)
                .filter(icao => airportMatchesFilter(icao) && 
                    trafficPrograms[icao].some(p => p.type === 'DEICING'))
                .sort((a, b) => AIRPORTS.indexOf(a) - AIRPORTS.indexOf(b));
            if (deicingAirports.length > 0) {
                let deicingItems = '';
                for (const icao of deicingAirports) {
                    const name = AIRPORT_NAMES[icao] || icao;
                    const deicingProg = trafficPrograms[icao].find(p => p.type === 'DEICING');
                    const startTime = deicingProg.startTime ? `Started: ${deicingProg.startTime}` : '';
                    deicingItems += `
                        <div class="deicing-item">
                            <span class="airport">${icao}</span> ${name} ${startTime}
                        </div>
                    `;
                }
                trafficHtml += `
                    <div id="section-deicing" class="collapsible-section section-deicing ${getSectionClass('section-deicing')}">
                        <div class="section-header" onclick="toggleSection('section-deicing')">
                            <h3> Active Deicing Programs (${deicingAirports.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-deicing')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-deicing')}">
                            ${deicingItems}
                        </div>
                    </div>
                `;
            }
            
            // FAA Advisory - Planned/Possible ground stops (in advisory order)
            const plannedATCsList = (faaAdvisoryData.plannedATCsList || [])
                .filter(entry => airportMatchesFilter(entry.icao));
            if (plannedATCsList.length > 0) {
                let plannedItems = '';
                for (const entry of plannedATCsList) {
                    const name = AIRPORT_NAMES[entry.icao] || entry.icao;
                    plannedItems += `
                        <div class="planned-item">
                            <span class="airport">${entry.icao}</span> ${name} - ${entry.program}
                        </div>
                    `;
                }
                trafficHtml += `
                    <div id="section-planned" class="collapsible-section section-planned ${getSectionClass('section-planned')}">
                        <div class="section-header" onclick="toggleSection('section-planned')">
                            <h3> POSSIBLE ATC'S (${plannedATCsList.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-planned')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-planned')}">
                            ${plannedItems}
                        </div>
                    </div>
                `;
            }
            
            // FAA Advisory - Runway/Taxiway closures
            const closureAirports = Object.keys(faaAdvisoryData.runwayClosures)
                .filter(icao => airportMatchesFilter(icao))
                .sort((a, b) => AIRPORTS.indexOf(a) - AIRPORTS.indexOf(b));
            if (closureAirports.length > 0) {
                let closureItems = '';
                for (const icao of closureAirports) {
                    const name = AIRPORT_NAMES[icao] || icao;
                    const closures = faaAdvisoryData.runwayClosures[icao];
                    for (const closure of closures) {
                        closureItems += `
                            <div class="closure-item">
                                <span class="airport">${icao}</span> ${name} - ${closure}
                            </div>
                        `;
                    }
                }
                trafficHtml += `
                    <div id="section-closure" class="collapsible-section section-closure ${getSectionClass('section-closure')}">
                        <div class="section-header" onclick="toggleSection('section-closure')">
                            <h3>&#x1F6A7; Runway/Taxiway Closures (${closureAirports.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-closure')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-closure')}">
                            ${closureItems}
                        </div>
                    </div>
                `;
            }
            
            // AFP Section
            const afpPrograms = faaAdvisoryData.afpPrograms || [];
            if (afpPrograms.length > 0) {
                let afpItems = '';
                for (const prog of afpPrograms) {
                    afpItems += `
                        <div class="forecast-note" style="border-color: #9b59b6;">
                            <span style="color: #9b59b6;"></span> ${prog}
                        </div>
                    `;
                }
                trafficHtml += `
                    <div id="section-afp" class="collapsible-section section-afp ${getSectionClass('section-afp')}">
                        <div class="section-header" onclick="toggleSection('section-afp')">
                            <h3> Airspace Flow Programs (${afpPrograms.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-afp')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-afp')}">
                            <div style="font-size:10px;color:#666;margin-bottom:8px;">En route traffic management programs</div>
                            ${afpItems}
                        </div>
                    </div>
                `;
            }
            
            // VIP Movement Section
            const vipMovements = faaAdvisoryData.vipMovements || [];
            if (vipMovements.length > 0) {
                let vipItems = '';
                const vipAirportCodes = new Set();
                
                for (const vip of vipMovements) {
                    vipItems += `
                        <div class="forecast-note" style="border-color: #c0392b;">
                            <span style="color: #e74c3c;"></span> ${vip}
                        </div>
                    `;
                    
                    // Extract airport codes (3-letter codes that follow DEP or ARR)
                    const codeMatches = vip.match(/(?:DEP|ARR)\s+([A-Z]{3})/g);
                    if (codeMatches) {
                        for (const match of codeMatches) {
                            const code = match.match(/[A-Z]{3}$/)[0];
                            if (code) {
                                vipAirportCodes.add(code);
                            }
                        }
                    }
                }
                
                // Build airport reference section
                let airportRef = '';
                if (vipAirportCodes.size > 0) {
                    const airportList = Array.from(vipAirportCodes).map(code => {
                        const icao = 'K' + code;
                        const name = AIRPORT_NAMES[icao] || code;
                        return `<span style="margin-right: 12px;"><strong>${code}</strong> = ${name}</span>`;
                    }).join('');
                    airportRef = `<div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid #444; font-size: 11px; color: #888;">
                        <div style="margin-bottom: 4px; color: #aaa;">Airport Reference:</div>
                        ${airportList}
                    </div>`;
                }
                
                trafficHtml += `
                    <div id="section-vip" class="collapsible-section section-vip ${getSectionClass('section-vip')}">
                        <div class="section-header" onclick="toggleSection('section-vip')">
                            <h3> VIP MOVEMENT (${vipMovements.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-vip')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-vip')}">
                            <div style="font-size:10px;color:#666;margin-bottom:8px;">VIP temporary flight restrictions</div>
                            ${vipItems}
                            ${airportRef}
                        </div>
                    </div>
                `;
            }
            
            // Rocket Launch Section
            const plannedLaunches = faaAdvisoryData.plannedLaunches || [];
            let launchesWithin24Hours = 0;
            
            if (plannedLaunches.length > 0) {
                let launchItems = '';
                const now = new Date();
                const in24Hours = new Date(now.getTime() + 24 * 60 * 60 * 1000);
                
                for (const launch of plannedLaunches) {
                    // Split into mission name and times
                    const parts = launch.split(' | ');
                    const missionName = parts[0];
                    const times = parts.slice(1);
                    
                    // Check if launch is within 24 hours by parsing PRIMARY time
                    let isWithin24Hours = false;
                    for (const time of times) {
                        if (time.includes('PRIMARY')) {
                            // Parse date like "12/17/25 1219Z"
                            const dateMatch = time.match(/(\d{1,2})\/(\d{1,2})\/(\d{2})\s+(\d{2})(\d{2})Z/);
                            if (dateMatch) {
                                const month = parseInt(dateMatch[1]) - 1;
                                const day = parseInt(dateMatch[2]);
                                const year = 2000 + parseInt(dateMatch[3]);
                                const hour = parseInt(dateMatch[4]);
                                const minute = parseInt(dateMatch[5]);
                                const launchDate = new Date(Date.UTC(year, month, day, hour, minute));
                                
                                if (launchDate <= in24Hours) {
                                    isWithin24Hours = true;
                                    launchesWithin24Hours++;
                                }
                            }
                            break;
                        }
                    }
                    
                    // Style based on whether launch is within 24 hours
                    const opacity = isWithin24Hours ? '1' : '0.5';
                    const borderColor = isWithin24Hours ? '#e67e22' : '#666';
                    const missionColor = isWithin24Hours ? '#e67e22' : '#888';
                    
                    let timesHtml = '';
                    if (times.length > 0) {
                        const leftBorderColor = isWithin24Hours ? '#e67e22' : '#666';
                        timesHtml = `<div style="padding-left: 25px; margin-top: 6px; border-left: 2px solid ${leftBorderColor}; margin-left: 10px;">`;
                        for (const time of times) {
                            const isPrimary = time.includes('PRIMARY');
                            const color = isWithin24Hours 
                                ? (isPrimary ? '#27ae60' : '#95a5a6')
                                : '#666';
                            const icon = isPrimary ? '' : '';
                            timesHtml += `<div style="color: ${color}; padding: 2px 0; font-size: 11px;">${icon} ${time}</div>`;
                        }
                        timesHtml += '</div>';
                    }
                    
                    const futureLabel = isWithin24Hours ? '' : '<span style="color: #888; font-size: 10px; margin-left: 8px;">(>24hrs)</span>';
                    
                    launchItems += `
                        <div class="forecast-note" style="border-color: ${borderColor}; opacity: ${opacity};">
                            <div><span style="color: ${missionColor};"></span> <strong>${missionName}</strong>${futureLabel}</div>
                            ${timesHtml}
                        </div>
                    `;
                }
                
                const launchCountDisplay = launchesWithin24Hours > 0 
                    ? `${launchesWithin24Hours} of ${plannedLaunches.length}` 
                    : `0 of ${plannedLaunches.length}`;
                    
                trafficHtml += `
                    <div id="section-rocket" class="collapsible-section section-rocket ${getSectionClass('section-rocket')}">
                        <div class="section-header" onclick="toggleSection('section-rocket')">
                            <h3> ROCKET LAUNCHES (${launchCountDisplay})</h3>
                            <span class="section-toggle">${getSectionToggle('section-rocket')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-rocket')}">
                            <div style="font-size:10px;color:#666;margin-bottom:8px;">Rocket/space launches affecting airspace (${launchesWithin24Hours} within 24hrs)</div>
                            ${launchItems}
                        </div>
                    </div>
                `;
            }
            
            // Store for dashboard card update
            window.launchesWithin24Hours = launchesWithin24Hours;
            window.totalLaunches = plannedLaunches.length;
            
            // Staffing Triggers Section
            const staffingTriggers = faaAdvisoryData.staffingTriggers || [];
            if (staffingTriggers.length > 0) {
                let staffItems = '';
                for (const staff of staffingTriggers) {
                    staffItems += `
                        <div class="forecast-note" style="border-color: #3498db;">
                            <span style="color: #3498db;"></span> ${staff}
                        </div>
                    `;
                }
                trafficHtml += `
                    <div id="section-staffing" class="collapsible-section section-staffing ${getSectionClass('section-staffing')}">
                        <div class="section-header" onclick="toggleSection('section-staffing')">
                            <h3> ATC STAFFING (${staffingTriggers.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-staffing')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-staffing')}">
                            <div style="font-size:10px;color:#666;margin-bottom:8px;">ATC facility staffing impacts</div>
                            ${staffItems}
                        </div>
                    </div>
                `;
            }
            
            // Runway/NOTAM alerts for critical situations
            let runwayAlertHtml = '';
            const criticalRunways = [];
            
            // Collect all airports from all categories
            const allAirports = [
                ...filteredCategories.active,
                ...filteredCategories.residual,
                ...filteredCategories.likely,
                ...filteredCategories.possible,
                ...filteredCategories.marginal,
                ...filteredCategories.none
            ];
            
            for (const apt of allAirports) {
                const status = apt.runway_status;
                if (status && (status.status === 'critical' || status.brakingAction === 'NIL' || status.brakingAction === 'POOR')) {
                    criticalRunways.push({ icao: apt.icao, ...status });
                }
            }
            
            // Sort by airport rank (busiest first)
            criticalRunways.sort((a, b) => AIRPORTS.indexOf(a.icao) - AIRPORTS.indexOf(b.icao));
            
            if (criticalRunways.length > 0) {
                let runwayItems = '';
                for (const rwy of criticalRunways) {
                    const name = AIRPORT_NAMES[rwy.icao] || rwy.icao;
                    let alertMsg = '';
                    if (rwy.message === 'AIRPORT CLOSED') {
                        alertMsg = '<span style="color: #e74c3c;">AIRPORT CLOSED</span>';
                    } else if (rwy.available === 0) {
                        alertMsg = '<span style="color: #e74c3c;">NO RUNWAYS AVAILABLE</span>';
                    } else {
                        alertMsg = `${rwy.available}/${rwy.total} runways open`;
                    }
                    
                    let brakingHtml = '';
                    if (rwy.brakingAction) {
                        const brakingClass = rwy.brakingAction === 'GOOD' ? 'braking-good' : 
                                            rwy.brakingAction === 'MEDIUM' || rwy.brakingAction === 'FAIR' ? 'braking-fair' :
                                            rwy.brakingAction === 'POOR' ? 'braking-poor' : 'braking-nil';
                        brakingHtml = `<span class="braking-action ${brakingClass}">${rwy.brakingAction}</span>`;
                    }
                    
                    runwayItems += `
                        <div class="notam-item">
                            <span class="airport" style="color: #f39c12;">${rwy.icao}</span> ${name} - ${alertMsg} ${brakingHtml}
                            ${rwy.closedRunways.length > 0 ? `<div style="color: #888; font-size: 10px;">Closed: ${rwy.closedRunways.join(', ')}</div>` : ''}
                        </div>
                    `;
                }
                runwayAlertHtml = `
                    <div id="section-runway" class="collapsible-section section-runway ${getSectionClass('section-runway')}">
                        <div class="section-header" onclick="toggleSection('section-runway')">
                            <h3>&#x1F6EC; Runway/Braking Alerts (${criticalRunways.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-runway')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-runway')}">
                            ${runwayItems}
                        </div>
                    </div>
                `;
            }
            
            // TAF Forecasts with frozen precip
            let tafHtml = '';
            const tafWarnings = [];
            for (const icao of AIRPORTS) {
                if (!airportMatchesFilter(icao)) continue;
                const taf = tafData[icao];
                if (taf && taf.frozenForecasts && taf.frozenForecasts.length > 0) {
                    const name = AIRPORT_NAMES[icao] || icao;
                    for (const fc of taf.frozenForecasts.slice(0, 1)) {
                        tafWarnings.push({
                            icao: icao,
                            name: name,
                            wx: fc.wx,
                            raw: fc.raw,
                            fullTaf: taf.raw || ''
                        });
                    }
                }
            }
            
            if (tafWarnings.length > 0) {
                let tafItems = '';
                for (const warn of tafWarnings) {
                    const tafId = `taf-full-${warn.icao}`;
                    tafItems += `
                        <div class="forecast-note" onclick="toggleTafFull('${tafId}')">
                            <span class="airport">${warn.icao}</span> ${warn.name} - 
                            <span style="color: #9b59b6;">${warn.wx}</span>
                            <span class="taf-expand-icon">&#x25BC; TAF</span>
                            <div class="taf-full" id="${tafId}">${warn.fullTaf}</div>
                        </div>
                    `;
                }
                
                tafHtml = `
                    <div id="section-taf" class="collapsible-section section-taf ${getSectionClass('section-taf')}">
                        <div class="section-header" onclick="toggleSection('section-taf')">
                            <h3>&#x2744; TAF Winter (${tafWarnings.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-taf')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-taf')}">
                            ${tafItems}
                        </div>
                    </div>
                `;
            }
            
            // Frost Risk section - airports with frost conditions (cold + night/early morning)
            let frostHtml = '';
            const frostAirports = allAirportsForFrost.filter(apt => apt.frost_risk);
            
            // Sort by airport rank (busiest first)
            frostAirports.sort((a, b) => AIRPORTS.indexOf(a.icao) - AIRPORTS.indexOf(b.icao));
            
            if (frostAirports.length > 0) {
                let frostItems = '';
                for (const apt of frostAirports) {
                    const name = AIRPORT_NAMES[apt.icao] || apt.icao;
                    const localTime = getLocalTime(apt.icao);
                    const localTimeStr = localTime ? localTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '';
                    const dewSpread = apt.dewpoint_c !== null ? `Dew spread: ${apt.temp_c - apt.dewpoint_c}&deg;C` : '';
                    const historyId = `history-frost-${apt.icao}`;
                    const historyHtml = generateHistoryHtml(apt, historyId);
                    
                    frostItems += `
                        <div class="forecast-note" style="border-color: #2980b9; cursor: pointer;" onclick="toggleHistory('${historyId}')">
                            <span class="airport">${apt.icao}</span> ${name} - 
                            <span style="color: #3498db;">${tempToF(apt.temp_c)}&deg;F (${apt.temp_c}&deg;C)</span>
                            <span style="color: #888; font-size: 10px; margin-left: 8px;">Local: ${localTimeStr}</span>
                            ${dewSpread ? `<span style="color: #666; font-size: 10px; margin-left: 8px;">${dewSpread}</span>` : ''}
                            <div class="expand-hint">Tap for history</div>
                            ${historyHtml}
                        </div>
                    `;
                }
                
                frostHtml = `
                    <div id="section-frost" class="collapsible-section section-frost ${getSectionClass('section-frost')}">
                        <div class="section-header" onclick="toggleSection('section-frost')" style="background:#1f2d3d;border:1px solid #2980b9;border-bottom:none;">
                            <h3 style="color:#3498db;">&#x1F319; Frost Risk (${frostAirports.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-frost')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-frost')}" style="background:#152535;border:1px solid #2980b9;border-top:none;">
                            <div style="font-size:10px;color:#666;margin-bottom:8px;">Airports below 4&deg;C during night hours (10pm-9am local) - potential for frost/ice formation</div>
                            ${frostItems}
                        </div>
                    </div>
                `;
            }
            
            // Rain/Precip section - non-frozen precipitation (rain, drizzle, showers)
            let precipHtml = '';
            const nonFrozenPrecipCodes = ['RA', 'DZ', 'SHRA', 'TSRA', 'SHGR', 'UP'];
            const precipAirports = allAirportsForFrost.filter(apt => {
                if (!apt.weather || apt.weather.length === 0) return false;
                for (const wx of apt.weather) {
                    const stripped = wx.replace(/^[-+]/, '');
                    for (const code of nonFrozenPrecipCodes) {
                        if (stripped.includes(code) && !stripped.includes('FZ')) {
                            return true;
                        }
                    }
                }
                return false;
            });
            
            if (precipAirports.length > 0) {
                // Sort by airport rank
                precipAirports.sort((a, b) => AIRPORTS.indexOf(a.icao) - AIRPORTS.indexOf(b.icao));
                
                let precipItems = '';
                for (const apt of precipAirports) {
                    const name = AIRPORT_NAMES[apt.icao] || apt.icao;
                    // Get the precip types
                    const precipTypes = apt.weather.filter(wx => {
                        const stripped = wx.replace(/^[-+]/, '');
                        return nonFrozenPrecipCodes.some(code => stripped.includes(code)) && !stripped.includes('FZ');
                    }).join(' ');
                    const ceiling = apt.ceiling_text || '';
                    const vis = apt.visibility_text || '';
                    const historyId = `history-precip-${apt.icao}`;
                    const historyHtml = generateHistoryHtml(apt, historyId);
                    
                    precipItems += `
                        <div class="forecast-note" style="border-color: #3498db; cursor: pointer;" onclick="toggleHistory('${historyId}')">
                            <span class="airport">${apt.icao}</span> ${name} - 
                            <span style="color: #3498db; font-weight: bold;">${precipTypes}</span>
                            <span style="color: #888; font-size: 10px; margin-left: 8px;">${ceiling} ${vis}</span>
                            <span style="color: #888; font-size: 10px; margin-left: 8px;">${apt.temp_c !== null ? tempToF(apt.temp_c) + '&deg;F' : ''}</span>
                            <div class="expand-hint">Tap for history</div>
                            ${historyHtml}
                        </div>
                    `;
                }
                
                precipHtml = `
                    <div id="section-precip" class="collapsible-section section-precip ${getSectionClass('section-precip')}">
                        <div class="section-header" onclick="toggleSection('section-precip')">
                            <h3>&#x1F327; Rain/Precip (${precipAirports.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-precip')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-precip')}">
                            <div style="font-size:10px;color:#666;margin-bottom:8px;">Active rain, drizzle, or showers (non-frozen precipitation)</div>
                            ${precipItems}
                        </div>
                    </div>
                `;
            }
            
            // LIFR section - airports currently reporting LIFR
            let lifrHtml = '';
            const lifrAirports = allAirportsForFrost.filter(apt => apt.flight_rules === 'LIFR');
            // Sort by airport rank (busiest first)
            lifrAirports.sort((a, b) => AIRPORTS.indexOf(a.icao) - AIRPORTS.indexOf(b.icao));
            if (lifrAirports.length > 0) {
                let lifrItems = '';
                for (const apt of lifrAirports) {
                    const name = AIRPORT_NAMES[apt.icao] || apt.icao;
                    const ceiling = apt.ceiling_text || 'N/A';
                    const vis = apt.visibility_text || 'N/A';
                    const historyId = `history-lifr-${apt.icao}`;
                    const historyHtml = generateHistoryHtml(apt, historyId);
                    
                    lifrItems += `
                        <div class="forecast-note" style="border-color: #9b59b6; cursor: pointer;" onclick="toggleHistory('${historyId}')">
                            <span class="airport">${apt.icao}</span> ${name} - 
                            <span style="color: #9b59b6;">Ceil: ${ceiling}, Vis: ${vis}</span>
                            <div class="expand-hint">Tap for history</div>
                            ${historyHtml}
                        </div>
                    `;
                }
                lifrHtml = `
                    <div id="section-lifr" class="collapsible-section section-lifr ${getSectionClass('section-lifr')}">
                        <div class="section-header" onclick="toggleSection('section-lifr')">
                            <h3>&#x1F7E3; LIFR Now (${lifrAirports.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-lifr')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-lifr')}">
                            <div style="font-size:10px;color:#666;margin-bottom:8px;">Ceiling &lt;500ft or Visibility &lt;1SM</div>
                            ${lifrItems}
                        </div>
                    </div>
                `;
            }
            
            // IFR section - airports currently reporting IFR
            let ifrHtml = '';
            const ifrAirports = allAirportsForFrost.filter(apt => apt.flight_rules === 'IFR');
            // Sort by airport rank (busiest first)
            ifrAirports.sort((a, b) => AIRPORTS.indexOf(a.icao) - AIRPORTS.indexOf(b.icao));
            if (ifrAirports.length > 0) {
                let ifrItems = '';
                for (const apt of ifrAirports) {
                    const name = AIRPORT_NAMES[apt.icao] || apt.icao;
                    const ceiling = apt.ceiling_text || 'N/A';
                    const vis = apt.visibility_text || 'N/A';
                    const historyId = `history-ifr-${apt.icao}`;
                    const historyHtml = generateHistoryHtml(apt, historyId);
                    
                    ifrItems += `
                        <div class="forecast-note" style="border-color: #e74c3c; cursor: pointer;" onclick="toggleHistory('${historyId}')">
                            <span class="airport">${apt.icao}</span> ${name} - 
                            <span style="color: #e74c3c;">Ceil: ${ceiling}, Vis: ${vis}</span>
                            <div class="expand-hint">Tap for history</div>
                            ${historyHtml}
                        </div>
                    `;
                }
                ifrHtml = `
                    <div id="section-ifr" class="collapsible-section section-ifr ${getSectionClass('section-ifr')}">
                        <div class="section-header" onclick="toggleSection('section-ifr')">
                            <h3>&#x1F534; IFR Now (${ifrAirports.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-ifr')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-ifr')}">
                            <div style="font-size:10px;color:#666;margin-bottom:8px;">Ceiling 500-1000ft or Visibility 1-3SM</div>
                            ${ifrItems}
                        </div>
                    </div>
                `;
            }
            
            // TAF LIFR section - TAFs forecasting LIFR conditions
            let tafLifrHtml = '';
            const tafLifrAirports = [];
            for (const icao of AIRPORTS) {
                if (!airportMatchesFilter(icao)) continue;
                const taf = tafData[icao];
                if (taf && taf.raw) {
                    const raw = taf.raw;
                    if (/\b(VV00[0-4]|BKN00[0-4]|OVC00[0-4]|[0-9]\/[0-9]SM|M1\/4SM)\b/.test(raw)) {
                        const name = AIRPORT_NAMES[icao] || icao;
                        // Extract the LIFR portion
                        const match = raw.match(/(VV00[0-4]|BKN00[0-4]|OVC00[0-4]|[0-9]\/[0-9]SM|M1\/4SM)/);
                        tafLifrAirports.push({ icao, name, condition: match ? match[0] : 'LIFR', raw });
                    }
                }
            }
            if (tafLifrAirports.length > 0) {
                let tafLifrItems = '';
                for (const apt of tafLifrAirports) {
                    const tafId = `taf-lifr-${apt.icao}`;
                    tafLifrItems += `
                        <div class="forecast-note" style="border-color: #8e44ad;" onclick="toggleTafFull('${tafId}')">
                            <span class="airport">${apt.icao}</span> ${apt.name} - 
                            <span style="color: #8e44ad;">${apt.condition}</span>
                            <span class="taf-expand-icon"> TAF</span>
                            <div class="taf-full" id="${tafId}">${apt.raw}</div>
                        </div>
                    `;
                }
                tafLifrHtml = `
                    <div id="section-taf-lifr" class="collapsible-section section-taf-lifr ${getSectionClass('section-taf-lifr')}">
                        <div class="section-header" onclick="toggleSection('section-taf-lifr')">
                            <h3>&#x1F4CB; TAF LIFR (${tafLifrAirports.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-taf-lifr')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-taf-lifr')}">
                            <div style="font-size:10px;color:#666;margin-bottom:8px;">TAF forecasts LIFR conditions (Ceiling &lt;500ft or Vis &lt;1SM)</div>
                            ${tafLifrItems}
                        </div>
                    </div>
                `;
            }
            
            // TAF IFR section - TAFs forecasting IFR conditions
            let tafIfrHtml = '';
            const tafIfrAirports = [];
            for (const icao of AIRPORTS) {
                if (!airportMatchesFilter(icao)) continue;
                const taf = tafData[icao];
                if (taf && taf.raw) {
                    const raw = taf.raw;
                    // Only match IFR if not already LIFR
                    if (!/\b(VV00[0-4]|BKN00[0-4]|OVC00[0-4]|[0-9]\/[0-9]SM|M1\/4SM)\b/.test(raw) &&
                        /\b(VV00[5-9]|BKN00[5-9]|OVC00[5-9]|BKN010|OVC010|1SM|2SM)\b/.test(raw)) {
                        const name = AIRPORT_NAMES[icao] || icao;
                        const match = raw.match(/(VV00[5-9]|BKN00[5-9]|OVC00[5-9]|BKN010|OVC010|1SM|2SM)/);
                        tafIfrAirports.push({ icao, name, condition: match ? match[0] : 'IFR', raw });
                    }
                }
            }
            if (tafIfrAirports.length > 0) {
                let tafIfrItems = '';
                for (const apt of tafIfrAirports) {
                    const tafId = `taf-ifr-${apt.icao}`;
                    tafIfrItems += `
                        <div class="forecast-note" style="border-color: #c0392b;" onclick="toggleTafFull('${tafId}')">
                            <span class="airport">${apt.icao}</span> ${apt.name} - 
                            <span style="color: #c0392b;">${apt.condition}</span>
                            <span class="taf-expand-icon"> TAF</span>
                            <div class="taf-full" id="${tafId}">${apt.raw}</div>
                        </div>
                    `;
                }
                tafIfrHtml = `
                    <div id="section-taf-ifr" class="collapsible-section section-taf-ifr ${getSectionClass('section-taf-ifr')}">
                        <div class="section-header" onclick="toggleSection('section-taf-ifr')">
                            <h3>&#x1F4CB; TAF IFR (${tafIfrAirports.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-taf-ifr')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-taf-ifr')}">
                            <div style="font-size:10px;color:#666;margin-bottom:8px;">TAF forecasts IFR conditions (Ceiling 500-1000ft or Vis 1-3SM)</div>
                            ${tafIfrItems}
                        </div>
                    </div>
                `;
            }
            
            // High Wind section - airports with wind or gusts at/above threshold
            let highWindHtml = '';
            const highWindAirports = allAirportsForFrost.filter(apt => {
                const speed = apt.wind_speed || 0;
                const gust = apt.wind_gust || 0;
                return speed >= windThreshold || gust >= windThreshold;
            });
            
            if (highWindAirports.length > 0) {
                // Delta hubs
                const DELTA_HUBS = ['KATL', 'KMSP', 'KDTW', 'KSLC', 'KJFK', 'KLGA', 'KBOS', 'KSEA', 'KLAX'];
                
                // Create three sorted lists
                const hubsOnly = highWindAirports.filter(apt => DELTA_HUBS.includes(apt.icao))
                    .sort((a, b) => DELTA_HUBS.indexOf(a.icao) - DELTA_HUBS.indexOf(b.icao));
                const byBusiest = [...highWindAirports].sort((a, b) => AIRPORTS.indexOf(a.icao) - AIRPORTS.indexOf(b.icao));
                const byWindSpeed = [...highWindAirports].sort((a, b) => {
                    const maxA = Math.max(a.wind_speed || 0, a.wind_gust || 0);
                    const maxB = Math.max(b.wind_speed || 0, b.wind_gust || 0);
                    return maxB - maxA;
                });
                
                // Helper function to generate wind item HTML
                const generateWindItem = (apt, idSuffix) => {
                    const name = AIRPORT_NAMES[apt.icao] || apt.icao;
                    let windText = '';
                    if (apt.wind_variable) {
                        windText = `VRB${apt.wind_speed}kt`;
                    } else if (apt.wind_dir !== null) {
                        windText = `${String(apt.wind_dir).padStart(3, '0')} @ ${apt.wind_speed}kt`;
                    } else {
                        windText = `${apt.wind_speed}kt`;
                    }
                    if (apt.wind_gust) {
                        windText += ` G${apt.wind_gust}kt`;
                    }
                    const maxWind = Math.max(apt.wind_speed || 0, apt.wind_gust || 0);
                    const windColor = maxWind >= 35 ? '#e74c3c' : maxWind >= 25 ? '#e67e22' : '#f39c12';
                    const historyId = `history-wind-${idSuffix}-${apt.icao}`;
                    const historyHtml = generateHistoryHtml(apt, historyId);
                    
                    return `
                        <div class="forecast-note" style="border-color: ${windColor}; cursor: pointer; padding: 4px 8px; font-size: 11px;" onclick="toggleHistory('${historyId}')">
                            <span class="airport">${apt.icao}</span> ${name} - 
                            <span style="color: ${windColor}; font-weight: bold;">${windText}</span>
                            <div class="expand-hint" style="font-size: 9px;">Tap for history</div>
                            ${historyHtml}
                        </div>
                    `;
                };
                
                let hubItems = '';
                if (hubsOnly.length > 0) {
                    for (const apt of hubsOnly) {
                        hubItems += generateWindItem(apt, 'hub');
                    }
                } else {
                    hubItems = '<div style="font-size:10px;color:#666;text-align:center;padding:8px;">No hubs affected</div>';
                }
                
                let busiestItems = '';
                for (const apt of byBusiest) {
                    busiestItems += generateWindItem(apt, 'busy');
                }
                
                let windSpeedItems = '';
                for (const apt of byWindSpeed) {
                    windSpeedItems += generateWindItem(apt, 'speed');
                }
                
                highWindHtml = `
                    <div id="section-high-wind" class="collapsible-section section-high-wind ${getSectionClass('section-high-wind')}">
                        <div class="section-header" onclick="toggleSection('section-high-wind')">
                            <h3>&#x1F4A8; High Wind (${highWindAirports.length}) - ${windThreshold}kt+</h3>
                            <span class="section-toggle">${getSectionToggle('section-high-wind')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-high-wind')}">
                            <div style="font-size:10px;color:#666;margin-bottom:8px;">Airports with sustained winds or gusts ${windThreshold}kt</div>
                            <div class="wind-columns">
                                <div class="wind-column">
                                    <div class="wind-column-header"> Hubs (${hubsOnly.length})</div>
                                    ${hubItems}
                                </div>
                                <div class="wind-column">
                                    <div class="wind-column-header"> By Traffic (Busiest First)</div>
                                    ${busiestItems}
                                </div>
                                <div class="wind-column">
                                    <div class="wind-column-header"> By Wind Speed (Highest First)</div>
                                    ${windSpeedItems}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Thunderstorm section - active thunderstorms
            let tstormHtml = '';
            const tstormAirports = allAirportsForFrost.filter(apt => {
                return apt.weather && apt.weather.some(wx => wx.includes('TS'));
            });
            // Sort by airport rank (busiest first)
            tstormAirports.sort((a, b) => AIRPORTS.indexOf(a.icao) - AIRPORTS.indexOf(b.icao));
            if (tstormAirports.length > 0) {
                let tstormItems = '';
                for (const apt of tstormAirports) {
                    const name = AIRPORT_NAMES[apt.icao] || apt.icao;
                    const tsWeather = apt.weather.filter(wx => wx.includes('TS')).join(' ');
                    const otherWx = apt.weather.filter(wx => !wx.includes('TS')).join(' ');
                    const historyId = `history-tstorm-${apt.icao}`;
                    const historyHtml = generateHistoryHtml(apt, historyId);
                    
                    // Build radar link with airport coordinates
                    const coords = AIRPORT_COORDS[apt.icao];
                    const radarLink = coords 
                        ? `https://aviationweather.gov/gfa/?tab=obs&layers=rad,metar&center=${coords.lat},${coords.lon}&zoom=6&radproduct=cref&metarplottype=wind,wx`
                        : `https://aviationweather.gov/gfa/?tab=obs&layers=rad,metar&zoom=4.75&radproduct=cref&metarplottype=wind,wx`;
                    
                    tstormItems += `
                        <div class="forecast-note" style="border-color: #9b59b6; cursor: pointer;" onclick="toggleHistory('${historyId}')">
                            <span class="airport">${apt.icao}</span> ${name} - 
                            <span style="color: #9b59b6; font-weight: bold;"> ${tsWeather}</span>
                            ${otherWx ? `<span style="color: #888; margin-left: 6px;">${otherWx}</span>` : ''}
                            <a href="${radarLink}" target="_blank" onclick="event.stopPropagation();" style="margin-left: 8px; color: #3498db; font-size: 10px; text-decoration: none;"> Radar </a>
                            <div class="expand-hint">Tap for history</div>
                            ${historyHtml}
                        </div>
                    `;
                }
                tstormHtml = `
                    <div id="section-tstorm" class="collapsible-section section-tstorm ${getSectionClass('section-tstorm')}">
                        <div class="section-header" onclick="toggleSection('section-tstorm')">
                            <h3>&#x26A1; Active Thunderstorms (${tstormAirports.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-tstorm')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-tstorm')}">
                            <div style="font-size:10px;color:#666;margin-bottom:8px;">Airports currently reporting thunderstorm activity</div>
                            ${tstormItems}
                        </div>
                    </div>
                `;
            }
            
            // TAF Thunderstorm section
            let tafTstormHtml = '';
            const tafTstormAirports = [];
            for (const icao of AIRPORTS) {
                if (!airportMatchesFilter(icao)) continue;
                const taf = tafData[icao];
                if (taf && taf.raw && /\bTS\b/.test(taf.raw)) {
                    // Extract the TS-related portions
                    const tsMatches = taf.raw.match(/(?:FM\d{6}|TEMPO\s+\d{4}\/\d{4}|BECMG\s+\d{4}\/\d{4}|PROB\d{2}\s+\d{4}\/\d{4})?[^A-Z]*\b\S*TS\S*\b/g) || [];
                    tafTstormAirports.push({
                        icao: icao,
                        tsInfo: tsMatches.slice(0, 2).join(', ') || 'TS',
                        raw: taf.raw
                    });
                }
            }
            if (tafTstormAirports.length > 0) {
                let tafTstormItems = '';
                for (const apt of tafTstormAirports) {
                    const name = AIRPORT_NAMES[apt.icao] || apt.icao;
                    const tafId = `taf-tstorm-${apt.icao}`;
                    tafTstormItems += `
                        <div class="forecast-note" style="border-color: #8e44ad; cursor:pointer;" onclick="toggleTafFull('${tafId}')">
                            <span class="airport">${apt.icao}</span> ${name} - 
                            <span style="color: #8e44ad;"> ${apt.tsInfo}</span>
                            <span class="taf-expand-icon"> TAF</span>
                            <div class="taf-full" id="${tafId}">${apt.raw}</div>
                        </div>
                    `;
                }
                tafTstormHtml = `
                    <div id="section-taf-tstorm" class="collapsible-section section-taf-tstorm ${getSectionClass('section-taf-tstorm')}">
                        <div class="section-header" onclick="toggleSection('section-taf-tstorm')">
                            <h3>&#x1F4CB; TAF Thunderstorms (${tafTstormAirports.length})</h3>
                            <span class="section-toggle">${getSectionToggle('section-taf-tstorm')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-taf-tstorm')}">
                            <div style="font-size:10px;color:#666;margin-bottom:8px;">Airports with thunderstorms in TAF forecast</div>
                            ${tafTstormItems}
                        </div>
                    </div>
                `;
            }
            
            // TAF High Wind section
            let tafWindHtml = '';
            const tafWindAirports = [];
            for (const icao of AIRPORTS) {
                if (!airportMatchesFilter(icao)) continue;
                const taf = tafData[icao];
                if (taf && taf.raw) {
                    // Match wind patterns like 25015G25KT or 31030KT
                    const windMatches = [...taf.raw.matchAll(/\b(\d{3}|VRB)(\d{2,3})(G(\d{2,3}))?KT\b/g)];
                    let maxSpeed = 0;
                    let maxGust = 0;
                    let maxWindStr = '';
                    for (const match of windMatches) {
                        const speed = parseInt(match[2]);
                        const gust = match[4] ? parseInt(match[4]) : 0;
                        if (speed >= windThreshold || gust >= windThreshold) {
                            if (Math.max(speed, gust) > Math.max(maxSpeed, maxGust)) {
                                maxSpeed = speed;
                                maxGust = gust;
                                maxWindStr = match[0];
                            }
                        }
                    }
                    if (maxSpeed >= windThreshold || maxGust >= windThreshold) {
                        tafWindAirports.push({
                            icao: icao,
                            maxSpeed: maxSpeed,
                            maxGust: maxGust,
                            windStr: maxWindStr,
                            raw: taf.raw
                        });
                    }
                }
            }
            // Sort by max wind descending
            tafWindAirports.sort((a, b) => Math.max(b.maxSpeed, b.maxGust) - Math.max(a.maxSpeed, a.maxGust));
            if (tafWindAirports.length > 0) {
                let tafWindItems = '';
                for (const apt of tafWindAirports) {
                    const name = AIRPORT_NAMES[apt.icao] || apt.icao;
                    const maxWind = Math.max(apt.maxSpeed, apt.maxGust);
                    const windColor = maxWind >= 35 ? '#e74c3c' : maxWind >= 25 ? '#e67e22' : '#d35400';
                    const tafId = `taf-wind-${apt.icao}`;
                    tafWindItems += `
                        <div class="forecast-note" style="border-color: ${windColor}; cursor:pointer;" onclick="toggleTafFull('${tafId}')">
                            <span class="airport">${apt.icao}</span> ${name} - 
                            <span style="color: ${windColor}; font-weight: bold;"> ${apt.windStr}</span>
                            <span class="taf-expand-icon"> TAF</span>
                            <div class="taf-full" id="${tafId}">${apt.raw}</div>
                        </div>
                    `;
                }
                tafWindHtml = `
                    <div id="section-taf-wind" class="collapsible-section section-taf-wind ${getSectionClass('section-taf-wind')}">
                        <div class="section-header" onclick="toggleSection('section-taf-wind')">
                            <h3>&#x1F4CB; TAF High Wind (${tafWindAirports.length}) - ${windThreshold}kt+</h3>
                            <span class="section-toggle">${getSectionToggle('section-taf-wind')}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass('section-taf-wind')}">
                            <div style="font-size:10px;color:#666;margin-bottom:8px;">Airports with forecast winds or gusts ${windThreshold}kt</div>
                            ${tafWindItems}
                        </div>
                    </div>
                `;
            }
            
            // Temperature sections - Current conditions
            // Helper function to generate temp item HTML
            function generateTempItem(apt, tempF, tempC, colorClass) {
                const name = AIRPORT_NAMES[apt.icao] || apt.icao;
                const trendSymbol = apt.trend ? apt.trend.symbol : '';
                const trendClass = apt.trend ? apt.trend.class : '';
                return `
                    <div class="temp-item" style="padding: 4px 8px; font-size: 11px;">
                        <div class="airport-info">
                            <span class="icao">${apt.icao}</span>
                            <span class="name" style="font-size: 10px;">${name}</span>
                        </div>
                        <div class="temp-display" style="font-size: 12px;">
                            ${tempF}F
                            <span class="trend-indicator ${trendClass}">${trendSymbol}</span>
                        </div>
                    </div>
                `;
            }
            
            // Helper to generate 3-column temp section
            function generateTempSection(airports, sectionId, title, subtitle, headerClass, coldestFirst = true) {
                if (airports.length === 0) return '';
                
                // Separate hubs
                const hubsOnly = airports.filter(apt => ALL_HUBS.includes(apt.icao));
                
                // Sort by traffic (busiest first - lower index in AIRPORTS = busier)
                const byTraffic = [...airports].sort((a, b) => {
                    const rankA = AIRPORTS.indexOf(a.icao);
                    const rankB = AIRPORTS.indexOf(b.icao);
                    return (rankA === -1 ? 999 : rankA) - (rankB === -1 ? 999 : rankB);
                });
                
                // Sort by temperature
                const byTemp = coldestFirst 
                    ? [...airports].sort((a, b) => a.temp_c - b.temp_c)
                    : [...airports].sort((a, b) => b.temp_c - a.temp_c);
                
                // Generate items for each column
                let hubItems = '';
                if (hubsOnly.length > 0) {
                    for (const apt of hubsOnly) {
                        const tempF = Math.round(apt.temp_c * 9/5 + 32);
                        hubItems += generateTempItem(apt, tempF, apt.temp_c, headerClass);
                    }
                } else {
                    hubItems = '<div style="font-size:10px;color:#666;text-align:center;padding:8px;">No hubs in range</div>';
                }
                
                let trafficItems = '';
                for (const apt of byTraffic) {
                    const tempF = Math.round(apt.temp_c * 9/5 + 32);
                    trafficItems += generateTempItem(apt, tempF, apt.temp_c, headerClass);
                }
                
                let tempItems = '';
                for (const apt of byTemp) {
                    const tempF = Math.round(apt.temp_c * 9/5 + 32);
                    tempItems += generateTempItem(apt, tempF, apt.temp_c, headerClass);
                }
                
                const tempSortLabel = coldestFirst ? ' Coldest First' : ' Hottest First';
                
                return `
                    <div id="${sectionId}" class="collapsible-section ${sectionId.replace('section-', 'section-')} ${getSectionClass(sectionId)}">
                        <div class="section-header" onclick="toggleSection('${sectionId}')">
                            <h3>${title} (${airports.length})</h3>
                            <span class="section-toggle">${getSectionToggle(sectionId)}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass(sectionId)}">
                            <div style="font-size:10px;color:#666;margin-bottom:8px;">${subtitle}</div>
                            <div class="temp-columns">
                                <div class="temp-column">
                                    <div class="temp-column-header ${headerClass}"> Hubs (${hubsOnly.length})</div>
                                    ${hubItems}
                                </div>
                                <div class="temp-column">
                                    <div class="temp-column-header ${headerClass}"> By Traffic</div>
                                    ${trafficItems}
                                </div>
                                <div class="temp-column">
                                    <div class="temp-column-header ${headerClass}">${tempSortLabel}</div>
                                    ${tempItems}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Generate temperature sections
            const tempFreezingHtml = generateTempSection(
                tempFreezingAirports,
                'section-temp-freezing',
                '&#x1F9CA; Freezing Temps - 32F',
                'Airports currently at or below freezing (32F / 0C)',
                'freezing',
                true
            );
            
            const tempApproachHtml = generateTempSection(
                tempApproachAirports,
                'section-temp-approach',
                '&#x2B07; Near Freezing - 33-40F ',
                'Airports 33-40F and trending down toward freezing',
                'approach',
                true
            );
            
            const tempNormalHtml = generateTempSection(
                tempNormalAirports,
                'section-temp-normal',
                '&#x1F321; Normal Temps - 41-89F',
                'Airports in normal temperature range',
                'normal',
                true
            );
            
            const tempHotHtml = generateTempSection(
                tempHotAirports,
                'section-temp-hot',
                '&#x1F525; Hot Temps - 90F',
                'Airports at or above 90F (32C)',
                'hot',
                false
            );
            
            // NWS Forecast Temperature sections (24-48 hour forecasts)
            // Helper to generate forecast temp item
            function generateForecastTempItem(data) {
                const name = AIRPORT_NAMES[data.icao] || data.icao;
                let tempDisplay = '';
                if (data.lowTempF !== null && data.highTempF !== null) {
                    tempDisplay = `Low: ${data.lowTempF}F / High: ${data.highTempF}F`;
                } else if (data.lowTempF !== null) {
                    tempDisplay = `Low: ${data.lowTempF}F`;
                } else if (data.highTempF !== null) {
                    tempDisplay = `High: ${data.highTempF}F`;
                }
                return `
                    <div class="temp-item" style="padding: 4px 8px; font-size: 11px;">
                        <div class="airport-info">
                            <span class="icao">${data.icao}</span>
                            <span class="name" style="font-size: 10px;">${name}</span>
                        </div>
                        <div class="temp-display" style="font-size: 12px;">
                            ${tempDisplay}
                        </div>
                    </div>
                `;
            }
            
            // Collect NWS forecast data for filtered airports
            const forecastTempData = [];
            for (const icao of AIRPORTS) {
                if (!airportMatchesFilter(icao)) continue;
                const nws = nwsForecastData[icao];
                if (nws && (nws.lowTempF !== null || nws.highTempF !== null)) {
                    forecastTempData.push(nws);
                }
            }
            
            // Helper to generate 3-column forecast section
            function generateForecastTempSection(airports, sectionId, title, subtitle, headerClass, coldestFirst = true) {
                if (airports.length === 0) return '';
                
                // Separate hubs
                const hubsOnly = airports.filter(apt => ALL_HUBS.includes(apt.icao));
                
                // Sort by traffic (busiest first)
                const byTraffic = [...airports].sort((a, b) => {
                    const rankA = AIRPORTS.indexOf(a.icao);
                    const rankB = AIRPORTS.indexOf(b.icao);
                    return (rankA === -1 ? 999 : rankA) - (rankB === -1 ? 999 : rankB);
                });
                
                // Sort by forecast low temp
                const byTemp = coldestFirst 
                    ? [...airports].sort((a, b) => (a.lowTempF || 999) - (b.lowTempF || 999))
                    : [...airports].sort((a, b) => (b.highTempF || -999) - (a.highTempF || -999));
                
                // Generate items for each column
                let hubItems = '';
                if (hubsOnly.length > 0) {
                    for (const apt of hubsOnly) {
                        hubItems += generateForecastTempItem(apt);
                    }
                } else {
                    hubItems = '<div style="font-size:10px;color:#666;text-align:center;padding:8px;">No hubs in range</div>';
                }
                
                let trafficItems = '';
                for (const apt of byTraffic) {
                    trafficItems += generateForecastTempItem(apt);
                }
                
                let tempItems = '';
                for (const apt of byTemp) {
                    tempItems += generateForecastTempItem(apt);
                }
                
                const tempSortLabel = coldestFirst ? ' Coldest Forecast' : ' Hottest Forecast';
                
                return `
                    <div id="${sectionId}" class="collapsible-section section-${sectionId.replace('section-', '')} ${getSectionClass(sectionId)}">
                        <div class="section-header" onclick="toggleSection('${sectionId}')">
                            <h3>${title} (${airports.length})</h3>
                            <span class="section-toggle">${getSectionToggle(sectionId)}</span>
                        </div>
                        <div class="section-content ${getSectionContentClass(sectionId)}">
                            <div style="font-size:10px;color:#666;margin-bottom:8px;">${subtitle}</div>
                            <div class="temp-columns">
                                <div class="temp-column">
                                    <div class="temp-column-header ${headerClass}"> Hubs (${hubsOnly.length})</div>
                                    ${hubItems}
                                </div>
                                <div class="temp-column">
                                    <div class="temp-column-header ${headerClass}"> By Traffic</div>
                                    ${trafficItems}
                                </div>
                                <div class="temp-column">
                                    <div class="temp-column-header ${headerClass}">${tempSortLabel}</div>
                                    ${tempItems}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Forecast Freezing (low 32F)
            const fcstFreezingList = forecastTempData.filter(t => t.lowTempF !== null && t.lowTempF <= 32);
            const tafTempFreezingHtml = generateForecastTempSection(
                fcstFreezingList,
                'section-taf-temp-freezing',
                ' Forecast Freezing - Low 32F',
                'NWS forecast low temps at or below freezing (next 24-48 hrs)',
                'freezing',
                true
            );
            
            // Forecast Near Freezing (low 33-40F)
            const fcstApproachList = forecastTempData.filter(t => t.lowTempF !== null && t.lowTempF > 32 && t.lowTempF <= 40);
            const tafTempApproachHtml = generateForecastTempSection(
                fcstApproachList,
                'section-taf-temp-approach',
                ' Forecast Near Freeze - Low 33-40F',
                'NWS forecast lows approaching freezing (next 24-48 hrs)',
                'approach',
                true
            );
            
            // Forecast Normal
            const fcstNormalList = forecastTempData.filter(t => {
                if (t.lowTempF !== null && t.lowTempF <= 40) return false;
                if (t.highTempF !== null && t.highTempF >= 90) return false;
                return true;
            });
            const tafTempNormalHtml = generateForecastTempSection(
                fcstNormalList,
                'section-taf-temp-normal',
                ' Forecast Normal - 41-89F',
                'NWS forecast temps in normal range (next 24-48 hrs)',
                'normal',
                true
            );
            
            // Forecast Hot (high 90F)
            const fcstHotList = forecastTempData.filter(t => t.highTempF !== null && t.highTempF >= 90);
            const tafTempHotHtml = generateForecastTempSection(
                fcstHotList,
                'section-taf-temp-hot',
                ' Forecast Hot - High 90F',
                'NWS forecast highs at or above 90F (next 24-48 hrs)',
                'hot',
                false
            );
            
            // Search results section - show ALL matching airports when searching
            let searchResultsHtml = '';
            
            // When there's a search term, combine all matching airports from all categories
            if (currentSearchTerm) {
                // Combine all filtered categories into one list for search display
                const allMatchingAirports = [
                    ...filteredCategories.active,
                    ...filteredCategories.residual,
                    ...filteredCategories.likely,
                    ...filteredCategories.possible,
                    ...filteredCategories.marginal,
                    ...filteredCategories.none,
                    ...Object.values(searchedAirports) // Include non-top-100 searched airports
                ];
                
                if (allMatchingAirports.length > 0) {
                    searchResultsHtml = `
                        <div id="section-search" class="collapsible-section section-search ${getSectionClass('section-search')}">
                            <div class="section-header" onclick="toggleSection('section-search')" style="background:#1f3d2d;border:1px solid #3a8c5a;border-bottom:none;">
                                <h3 style="color:#3ce78c;">&#x1F50D; Search Results (${allMatchingAirports.length})</h3>
                                <span class="section-toggle">${getSectionToggle('section-search')}</span>
                            </div>
                            <div class="section-content ${getSectionContentClass('section-search')}" style="background:#1a2d25;border:1px solid #3a8c5a;border-top:none;">
                                <div class="airport-list">
                    `;
                    
                    for (const apt of allMatchingAirports) {
                        const cat = categorize(apt);
                        const catColors = {
                            active: '#e74c3c',
                            likely: '#f39c12', 
                            residual: '#9b59b6',
                            possible: '#f1c40f',
                            marginal: '#f39c12',
                            none: '#2ecc71',
                            unknown: '#888'
                        };
                        const catLabels = {
                            active: '&#x1F534; Active',
                            likely: '&#x1F7E0; Likely',
                            residual: '&#x1F7E3; Residual', 
                            possible: '&#x1F7E1; Possible',
                            marginal: '&#x1F7E0; Marginal',
                            none: '&#x1F7E2; None',
                            unknown: ' Unknown'
                        };
                        const catColor = catColors[cat] || '#888';
                        const catLabel = catLabels[cat] || cat;
                        
                        const name = getAirportName(apt.icao);
                        const airportInfo = getAirportInfo(apt.icao);
                        const iataCode = airportInfo?.iata || '';
                        const elevation = airportInfo?.elevation_ft ? `${airportInfo.elevation_ft}ft` : '';
                        const wx = formatWeatherDisplay(apt);
                        const frClass = `fr-${apt.flight_rules.toLowerCase()}`;
                        const metarUrl = `https://aviationweather.gov/data/metar/?id=${apt.icao}&hours=6`;
                        const timeSince = getTimeSince(apt.obs_time);
                        const historyId = `history-search-${apt.icao}`;
                        
                        // Store wind data for runway map
                        currentWindData[apt.icao] = {
                            direction: (apt.wind_variable || apt.wind_dir === 'VRB') ? null : apt.wind_dir,
                            speed: apt.wind_speed,
                            gust: apt.wind_gust,
                            variable: apt.wind_variable || apt.wind_dir === 'VRB'
                        };
                        
                        let windHtml = '';
                        if (apt.wind_speed !== null) {
                            let windText = apt.wind_variable ? `VRB${apt.wind_speed}kt` : 
                                apt.wind_dir !== null ? `${String(apt.wind_dir).padStart(3, '0')}&deg;/${apt.wind_speed}kt` : `${apt.wind_speed}kt`;
                            if (apt.wind_gust) windText += `G${apt.wind_gust}`;
                            windHtml = `<span class="wind-info"> ${windText}</span>`;
                        }
                        
                        let historyHtml = '';
                        if (apt.history && apt.history.length > 0) {
                            historyHtml = `<div class="history" id="${historyId}"><div class="history-title">Last ${apt.history.length} observations</div>`;
                            historyHtml += `<div class="history-header"><span class="time">Time (Z/Local)</span><span class="ceiling">Ceil</span><span class="wx">Weather</span><span class="wind">Wind</span><span class="temp">Temp</span></div>`;
                            for (const h of apt.history) {
                                const hTimeData = formatObsTime(h.obs_time);
                                const hTime = hTimeData.combined;
                                const hCeiling = h.ceiling_text || '&mdash;';
                                const hWx = formatHistoryWeather(h);
                                const hWind = h.wind_speed !== null ? 
                                    (h.wind_variable ? `VRB${h.wind_speed}` : `${h.wind_speed}kt`) + (h.wind_gust ? `G${h.wind_gust}` : '') : '&mdash;';
                                const hTemp = h.temp_c !== null ? `${tempToF(h.temp_c)}&deg;F/${h.temp_c}&deg;C` : 'N/A';
                                historyHtml += `<div class="history-row"><span class="time">${hTime}</span><span class="ceiling">${hCeiling}</span><span class="wx">${hWx}</span><span class="wind">${hWind}</span><span class="temp">${hTemp}</span></div>`;
                            }
                            historyHtml += '</div>';
                        }
                        
                        const icaoDisplay = iataCode ? `${apt.icao}/${iataCode}` : apt.icao;
                        
                        searchResultsHtml += `
                            <div class="airport-card" onclick="toggleHistory('${historyId}')" style="border-left:3px solid ${catColor};">
                                <div class="airport-main">
                                    <div class="left">
                                        <div class="icao" style="background:${catColor}22;">${icaoDisplay}</div>
                                        <div>
                                            <div class="name">
                                                <a href="${metarUrl}" target="_blank" onclick="event.stopPropagation();" title="View METARs">${name} </a>
                                                <button class="runway-map-btn" onclick="showRunwayMap('${apt.icao}')" title="View Runway Map">&#x1F6EB; Map</button>
                                            </div>
                                            <div class="weather">${wx} <span class="flight-rules ${frClass}">${apt.flight_rules}</span> ${windHtml}</div>
                                            <div class="obs-time ${timeSince.stale ? 'stale' : ''}">${timeSince.zulu} &bull; ${timeSince.text}</div>
                                            <div style="margin-top:4px;"><span style="color:${catColor};font-size:11px;font-weight:bold;">${catLabel}</span></div>
                                            ${apt.taf && apt.taf.raw ? `
                                                <div class="taf-forecast" style="cursor:pointer;" onclick="toggleTafInline(document.getElementById('taf-search-${apt.icao}')); event.stopPropagation();">
                                                    &#x1F4CB; TAF: <span style="color:${apt.taf.frozenForecasts && apt.taf.frozenForecasts.length > 0 ? '#9b59b6' : '#4a90d9'};">${apt.taf.frozenForecasts && apt.taf.frozenForecasts.length > 0 ? apt.taf.frozenForecasts[0].wx : 'Available'}</span>
                                                    <span style="color:#666;font-size:9px;margin-left:4px;">&#x25BC; expand</span>
                                                </div>
                                                <div class="taf-inline" id="taf-search-${apt.icao}" onclick="toggleTafInline(this); event.stopPropagation();">${apt.taf.raw}</div>
                                            ` : ''}
                                        </div>
                                    </div>
                                    <div class="right">
                                        <div class="trend ${apt.trend?.class || 'steady'}" title="${apt.trend?.text || ''}">${apt.trend?.symbol || '&#x2192;'}</div>
                                        <div class="temp">
                                            <div class="temp-value">${apt.temp_c !== null ? tempToF(apt.temp_c) + '&deg;F' : 'N/A'}</div>
                                            <div class="temp-f">${apt.temp_c !== null ? apt.temp_c + '&deg;C' : ''}</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="expand-hint">Tap to see history</div>
                                ${historyHtml}
                            </div>
                        `;
                    }
                    
                    searchResultsHtml += `
                                </div>
                            </div>
                        </div>
                    `;
                }
            } else {
                // No search term - show non-top-100 searched airports if any (shouldn't happen normally)
                const searchedAirportsList = Object.values(searchedAirports);
                if (searchedAirportsList.length > 0) {
                    searchResultsHtml = buildSearchResultsHtml(searchedAirportsList);
                }
            }
            
            // When searching, show simplified view with just search results
            if (currentSearchTerm) {
                let html = searchResultsHtml;
                
                if (html === '') {
                    html = `<div class="status-msg info">No airports found matching "${currentSearchTerm}"</div>`;
                }
                
                // Data status summary
                const advActive = Object.keys(faaAdvisoryData.terminalActive).length;
                const advClosures = Object.keys(faaAdvisoryData.runwayClosures).length;
                
                html += `
                    <div style="background: #1a1a2e; border: 1px solid #333; border-radius: 8px; padding: 10px; margin-top: 20px; font-size: 11px; color: #666;">
                        <strong style="color: #888;">Data Status:</strong>
                        <span style="margin-left: 10px;">TAFs: ${Object.keys(tafData).length}</span>
                        <span style="margin-left: 10px;">ATCSCC: ${advActive > 0 || advClosures > 0 ? `${advActive} active, ${advClosures} rwys` : ''}</span>
                    </div>
                `;
                
                content.innerHTML = html;
                return; // Exit early - don't show normal view when searching
            }
            
            let html = trafficHtml + arrDepHtml + runwayAlertHtml + tafHtml + frostHtml + precipHtml + lifrHtml + ifrHtml + tafLifrHtml + tafIfrHtml + highWindHtml + tafWindHtml + tstormHtml + tafTstormHtml + tempFreezingHtml + tempApproachHtml + tempNormalHtml + tempHotHtml + tafTempFreezingHtml + tafTempApproachHtml + tafTempNormalHtml + tafTempHotHtml;


            if (filteredCategories.active.length > 0) {
                html += renderSection('&#x1F534; Active Deicing', filteredCategories.active, 'section-active');
            }
            if (filteredCategories.residual.length > 0) {
                html += renderSection('&#x1F7E3; Residual (Recent Frozen Precip)', filteredCategories.residual, 'section-residual');
            }
            if (filteredCategories.likely.length > 0) {
                html += renderSection('&#x1F7E0; Likely Deicing', filteredCategories.likely, 'section-likely');
            }
            if (filteredCategories.possible.length > 0) {
                html += renderSection('&#x1F7E1; Possible (Below Freezing)', filteredCategories.possible, 'section-possible');
            }
            
            // Add Clear section (collapsed by default) for airports without deicing conditions
            if (filteredCategories.none.length > 0) {
                html += renderSection('&#x1F7E2; Clear (No Deicing)', filteredCategories.none, 'section-none');
            }

            if (filteredCategories.active.length === 0 && filteredCategories.likely.length === 0 && filteredCategories.residual.length === 0 && filteredCategories.possible.length === 0) {
                if (currentSearchTerm || currentRegionFilter !== 'all') {
                    html += `<div class="status-msg info">No matching airports with deicing conditions</div>`;
                } else {
                    html += `<div class="status-msg info">&#x2705; No airports currently reporting deicing conditions</div>`;
                }
            }
            
            // Data status summary
            const advActive = Object.keys(faaAdvisoryData.terminalActive).length;
            const advClosures = Object.keys(faaAdvisoryData.runwayClosures).length;
            
            html += `
                <div style="background: #1a1a2e; border: 1px solid #333; border-radius: 8px; padding: 10px; margin-top: 20px; font-size: 11px; color: #666;">
                    <strong style="color: #888;">Data Status:</strong>
                    <span style="margin-left: 10px;">TAFs: ${Object.keys(tafData).length}</span>
                    <span style="margin-left: 10px;">ATCSCC: ${advActive > 0 || advClosures > 0 ? `${advActive} active, ${advClosures} rwys` : ''}</span>
                </div>
            `;

            content.innerHTML = html;
            
            // Refresh weather map if visible
            if (weatherMapVisible) {
                renderWeatherMap();
            }
        }

        // Weather Map Functions
        let weatherMapVisible = false;
        
        function toggleWeatherMap() {
            const content = document.getElementById('weatherMapContent');
            const toggle = document.getElementById('weatherMapToggle');
            weatherMapVisible = !weatherMapVisible;
            
            if (weatherMapVisible) {
                content.classList.add('active');
                toggle.textContent = ' Hide';
                renderWeatherMap();
            } else {
                content.classList.remove('active');
                toggle.textContent = ' Show';
            }
        }
        
        function renderWeatherMap() {
            const container = document.getElementById('weatherMapSvg');
            if (!container) return;
            
            // Map dimensions and projection settings
            const width = 800;
            const height = 500;
            const padding = 20;
            
            // Continental US/Canada bounds (excluding Hawaii/Alaska for main view)
            const minLat = 24;  // Southern US
            const maxLat = 55;  // Northern Canada
            const minLon = -130; // Western coast
            const maxLon = -60;  // Eastern coast
            
            // Simple Mercator-like projection
            function projectLon(lon) {
                return padding + ((lon - minLon) / (maxLon - minLon)) * (width - 2 * padding);
            }
            
            function projectLat(lat) {
                // Invert Y axis (lat increases going up, but SVG Y increases going down)
                return height - padding - ((lat - minLat) / (maxLat - minLat)) * (height - 2 * padding);
            }
            
            // Determine weather category for airport based on TAF with strict priority
            // PRIORITY ORDER (highest to lowest):
            // 1. Thunderstorms (TS) - Purple Triangle
            // 2. Freezing Rain/Ice (FZRA, FZDZ, PL, IC) - Magenta Diamond  
            // 3. Snow (SN, BLSN, GS, GR) - Cyan Square
            // 4. LIFR conditions - Dark Red Circle
            // 5. IFR conditions - Red Circle
            // 6. High Wind (25kt+/35G+) - Blue Circle
            // 7. MVFR conditions - Gold Circle
            // 8. Low Visibility Fog/Mist - Gray Circle
            // 9. VFR - Green Circle
            function getAirportWeatherCategory(icao) {
                const taf = tafData[icao];
                const metar = lastRenderData?.categories;
                
                // Helper to check conditions string for weather/vis/ceiling
                function analyzeConditions(conditions) {
                    if (!conditions) return null;
                    const c = conditions.toUpperCase();
                    
                    // Priority 1: Thunderstorms
                    if (/\b(TS|TSRA|TSSN|TSGR|VCTS)\b/.test(c)) {
                        return { color: '#9b59b6', priority: 1, label: 'TS', shape: 'triangle' };
                    }
                    
                    // Priority 2: Freezing precipitation
                    if (/\b(FZRA|FZDZ|\+FZRA|\-FZRA|PL|IC)\b/.test(c)) {
                        return { color: '#ff00ff', priority: 2, label: 'FZPCP', shape: 'diamond' };
                    }
                    
                    // Priority 3: Snow
                    if (/\b(\+SN|SN|\-SN|BLSN|GS|GR|SG)\b/.test(c)) {
                        return { color: '#00ffff', priority: 3, label: 'SNOW', shape: 'square' };
                    }
                    
                    // Priority 4: LIFR (vis < 1SM or ceiling < 500ft)
                    const lifrVis = /\b(M?1\/4SM|M?1\/2SM|M?3\/4SM)\b/.test(c);
                    const lifrCeil = /\b(VV00[1-4]|OVC00[1-4]|BKN00[1-4])\b/.test(c);
                    if (lifrVis || lifrCeil) {
                        return { color: '#c0392b', priority: 4, label: 'LIFR', shape: 'circle' };
                    }
                    
                    // Priority 5: IFR (vis < 3SM or ceiling < 1000ft)
                    const ifrVis = /\b(1SM|1 1\/2SM|2SM|2 1\/2SM)\b/.test(c);
                    const ifrCeil = /\b(VV00[5-9]|OVC00[5-9]|BKN00[5-9]|OVC010|BKN010)\b/.test(c);
                    if (ifrVis || ifrCeil) {
                        return { color: '#e74c3c', priority: 5, label: 'IFR', shape: 'circle' };
                    }
                    
                    // Priority 6: High winds
                    const windMatch = c.match(/\b(\d{3})(\d{2})(G(\d{2}))?KT\b/);
                    if (windMatch) {
                        const speed = parseInt(windMatch[2]);
                        const gust = windMatch[4] ? parseInt(windMatch[4]) : 0;
                        if (speed >= 25 || gust >= 35) {
                            return { color: '#2980b9', priority: 6, label: 'WIND', shape: 'circle' };
                        }
                    }
                    
                    // Priority 7: MVFR (vis 3-5SM or ceiling 1000-3000ft)
                    const mvfrVis = /\b(3SM|4SM|5SM)\b/.test(c);
                    const mvfrCeil = /\b(OVC0[1-2]\d|BKN0[1-2]\d|OVC030|BKN030)\b/.test(c);
                    if (mvfrVis || mvfrCeil) {
                        return { color: '#f39c12', priority: 7, label: 'MVFR', shape: 'circle' };
                    }
                    
                    // Priority 8: Fog/Mist/Haze
                    if (/\b(FG|BR|HZ|FU)\b/.test(c)) {
                        return { color: '#7f8c8d', priority: 8, label: 'FG/HZ', shape: 'circle' };
                    }
                    
                    return null;
                }
                
                // Check TAF parsed condition changes for worst weather
                if (taf && taf.conditionChanges && taf.conditionChanges.length > 0) {
                    let worstCondition = null;
                    
                    // Check each condition change period
                    for (const change of taf.conditionChanges) {
                        const result = analyzeConditions(change.conditions);
                        if (result && (!worstCondition || result.priority < worstCondition.priority)) {
                            worstCondition = result;
                        }
                    }
                    
                    // If we found significant weather in TAF changes, return it
                    if (worstCondition && worstCondition.priority <= 7) {
                        return worstCondition;
                    }
                }
                
                // Also check raw TAF if no parsed changes
                if (taf && taf.raw) {
                    const rawResult = analyzeConditions(taf.raw);
                    if (rawResult && rawResult.priority <= 7) {
                        return rawResult;
                    }
                }
                
                // Fallback to current METAR
                if (metar) {
                    for (const cat of ['active', 'residual', 'likely', 'possible', 'marginal', 'none']) {
                        const found = metar[cat]?.find(a => a.icao === icao);
                        if (found) {
                            // Check current thunderstorms
                            if (found.weather?.some(wx => /TS/.test(wx))) {
                                return { color: '#9b59b6', priority: 1, label: 'TS', shape: 'triangle' };
                            }
                            // Check current freezing precip
                            if (found.weather?.some(wx => /(FZRA|FZDZ|PL|IC)/.test(wx))) {
                                return { color: '#ff00ff', priority: 2, label: 'FZPCP', shape: 'diamond' };
                            }
                            // Check current snow
                            if (found.weather?.some(wx => /SN/.test(wx))) {
                                return { color: '#00ffff', priority: 3, label: 'SNOW', shape: 'square' };
                            }
                            // Flight rules
                            if (found.flight_rules === 'LIFR') {
                                return { color: '#c0392b', priority: 4, label: 'LIFR', shape: 'circle' };
                            }
                            if (found.flight_rules === 'IFR') {
                                return { color: '#e74c3c', priority: 5, label: 'IFR', shape: 'circle' };
                            }
                            // High wind
                            if (found.wind_speed >= 25 || found.wind_gust >= 35) {
                                return { color: '#2980b9', priority: 6, label: 'WIND', shape: 'circle' };
                            }
                            if (found.flight_rules === 'MVFR') {
                                return { color: '#f39c12', priority: 7, label: 'MVFR', shape: 'circle' };
                            }
                            // Check for fog/mist
                            if (found.weather?.some(wx => /(FG|BR|HZ)/.test(wx))) {
                                return { color: '#7f8c8d', priority: 8, label: 'FG/HZ', shape: 'circle' };
                            }
                            // VFR
                            if (found.flight_rules === 'VFR') {
                                return { color: '#27ae60', priority: 9, label: 'VFR', shape: 'circle' };
                            }
                        }
                    }
                }
                
                // Default to VFR
                return { color: '#27ae60', priority: 9, label: 'VFR', shape: 'circle' };
            }
            
            // Build SVG
            let svg = `<svg class="weather-map-svg" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">`;
            
            // Background
            svg += `<rect width="${width}" height="${height}" fill="#0a0a15"/>`;
            
            // Simplified US coastline path (approximate)
            const usCoastline = [
                // West Coast
                [-124.7, 48.4], [-124.4, 46.3], [-124.0, 43.0], [-124.2, 40.0], [-122.4, 37.8], [-120.5, 34.5], [-117.1, 32.5],
                // Mexico Border
                [-117.1, 32.5], [-111.0, 31.3], [-108.2, 31.8], [-106.5, 31.8], [-104.0, 29.5], [-103.0, 29.0], [-101.4, 29.8], [-99.5, 27.5], [-97.4, 26.0],
                // Gulf Coast  
                [-97.4, 26.0], [-97.0, 28.0], [-94.0, 29.8], [-90.0, 29.2], [-89.0, 29.0], [-88.0, 30.2], [-87.5, 30.4], [-86.5, 30.4], [-85.0, 29.7], [-83.0, 28.8], [-82.5, 27.5], [-80.0, 25.0],
                // East Coast
                [-80.0, 25.0], [-80.1, 26.5], [-81.0, 31.0], [-81.5, 32.0], [-79.0, 33.5], [-76.0, 35.0], [-75.5, 37.0], [-74.0, 39.5], [-74.0, 40.5], [-73.0, 41.0], [-71.0, 41.5], [-70.0, 42.0], [-70.5, 43.5], [-67.0, 44.5], [-67.0, 45.0]
            ];
            
            // US-Canada border (simplified)
            const usBorder = [
                [-67.0, 45.0], [-70.0, 46.0], [-71.0, 45.0], [-75.0, 45.0], [-79.0, 43.5], [-82.5, 42.0], [-83.0, 46.5], [-88.0, 48.0], [-90.0, 48.0], [-95.0, 49.0], [-123.0, 49.0], [-124.7, 48.4]
            ];
            
            // Canada coastline (simplified)
            const canadaCoast = [
                [-124.7, 48.4], [-127.0, 50.0], [-128.0, 52.0], [-130.0, 54.0], [-130.0, 55.0]
            ];
            
            const eastCanada = [
                [-67.0, 45.0], [-64.0, 44.5], [-66.0, 45.5], [-64.5, 47.5], [-61.0, 46.0], [-60.0, 47.0], [-57.0, 47.5], [-55.5, 47.0], [-53.0, 47.5], [-52.5, 47.5]
            ];
            
            // Draw coastlines
            function drawPath(points, stroke) {
                if (points.length < 2) return '';
                let d = `M ${projectLon(points[0][0])},${projectLat(points[0][1])}`;
                for (let i = 1; i < points.length; i++) {
                    d += ` L ${projectLon(points[i][0])},${projectLat(points[i][1])}`;
                }
                return `<path d="${d}" fill="none" stroke="${stroke}" stroke-width="1.5"/>`;
            }
            
            svg += drawPath(usCoastline, '#334');
            svg += drawPath(usBorder, '#445');
            svg += drawPath(canadaCoast, '#334');
            svg += drawPath(eastCanada, '#334');
            
            // Great Lakes (simplified outlines)
            const greatLakes = [
                // Superior
                [[-92.0, 46.5], [-89.0, 47.0], [-86.5, 47.5], [-85.0, 47.0], [-84.5, 46.5], [-86.0, 46.5], [-88.0, 46.0], [-92.0, 46.5]],
                // Michigan
                [[-88.0, 46.0], [-87.0, 45.0], [-86.0, 44.0], [-86.0, 42.0], [-87.5, 41.7], [-87.5, 44.5], [-88.0, 46.0]],
                // Huron
                [[-84.5, 46.0], [-83.0, 45.5], [-82.5, 44.0], [-82.0, 43.5], [-83.5, 44.0], [-84.0, 45.0], [-84.5, 46.0]],
                // Erie
                [[-83.5, 42.0], [-81.5, 42.0], [-79.0, 42.8], [-79.5, 42.2], [-81.0, 41.5], [-83.5, 41.5], [-83.5, 42.0]],
                // Ontario
                [[-79.8, 43.2], [-77.5, 43.5], [-76.5, 44.0], [-77.0, 43.5], [-79.0, 43.3], [-79.8, 43.2]]
            ];
            
            for (const lake of greatLakes) {
                let d = `M ${projectLon(lake[0][0])},${projectLat(lake[0][1])}`;
                for (let i = 1; i < lake.length; i++) {
                    d += ` L ${projectLon(lake[i][0])},${projectLat(lake[i][1])}`;
                }
                d += ' Z';
                svg += `<path d="${d}" fill="#0a0a15" stroke="#223" stroke-width="1"/>`;
            }
            
            // Grid lines
            for (let lon = -120; lon <= -70; lon += 10) {
                const x = projectLon(lon);
                svg += `<line x1="${x}" y1="${padding}" x2="${x}" y2="${height-padding}" stroke="#1a1a2e" stroke-width="0.5"/>`;
                svg += `<text x="${x}" y="${height - 5}" text-anchor="middle" fill="#444" font-size="8">${Math.abs(lon)}W</text>`;
            }
            for (let lat = 30; lat <= 50; lat += 10) {
                const y = projectLat(lat);
                svg += `<line x1="${padding}" y1="${y}" x2="${width-padding}" y2="${y}" stroke="#1a1a2e" stroke-width="0.5"/>`;
                svg += `<text x="12" y="${y + 3}" fill="#444" font-size="8">${lat}N</text>`;
            }
            
            // Collect airports with their weather
            const airportMarkers = [];
            
            for (const icao of AIRPORTS) {
                const coords = AIRPORT_COORDS[icao];
                if (!coords) continue;
                
                // Skip Hawaii/Alaska for main map (they'd be off the projection)
                if (coords.lat < minLat || coords.lat > maxLat || coords.lon < minLon || coords.lon > maxLon) {
                    continue;
                }
                
                const x = projectLon(coords.lon);
                const y = projectLat(coords.lat);
                const weather = getAirportWeatherCategory(icao);
                
                airportMarkers.push({ icao, x, y, weather, coords });
            }
            
            // Sort by priority so most severe are on top
            airportMarkers.sort((a, b) => b.weather.priority - a.weather.priority);
            
            // Draw airport markers with shapes based on weather type
            for (const marker of airportMarkers) {
                const iataCode = AIRPORT_INFO[marker.icao]?.iata || marker.icao.substring(1);
                const isHub = ALL_HUBS.includes(marker.icao) || marker.icao.startsWith('CY');
                const size = isHub ? 8 : 5;
                
                // Outer glow for severe weather (priority 1-5)
                if (marker.weather.priority <= 5) {
                    svg += `<circle cx="${marker.x}" cy="${marker.y}" r="${size + 5}" fill="${marker.weather.color}" opacity="0.35"/>`;
                }
                
                // Draw shape based on weather type
                const shape = marker.weather.shape || 'circle';
                
                if (shape === 'triangle') {
                    // Thunderstorm - upward triangle
                    const h = size * 1.5;
                    svg += `<polygon points="${marker.x},${marker.y - h} ${marker.x - h},${marker.y + h*0.6} ${marker.x + h},${marker.y + h*0.6}" 
                            fill="${marker.weather.color}" stroke="#fff" stroke-width="1"/>`;
                } else if (shape === 'diamond') {
                    // Freezing precip - diamond
                    const d = size * 1.2;
                    svg += `<polygon points="${marker.x},${marker.y - d} ${marker.x + d},${marker.y} ${marker.x},${marker.y + d} ${marker.x - d},${marker.y}" 
                            fill="${marker.weather.color}" stroke="#fff" stroke-width="1"/>`;
                } else if (shape === 'square') {
                    // Snow - square
                    const s = size * 0.9;
                    svg += `<rect x="${marker.x - s}" y="${marker.y - s}" width="${s*2}" height="${s*2}" 
                            fill="${marker.weather.color}" stroke="#fff" stroke-width="1"/>`;
                } else {
                    // Circle for all others
                    svg += `<circle cx="${marker.x}" cy="${marker.y}" r="${size}" fill="${marker.weather.color}" stroke="#fff" stroke-width="0.8"/>`;
                }
                
                // Label for hub airports and Canadian airports
                if (isHub) {
                    svg += `<text x="${marker.x}" y="${marker.y - size - 3}" text-anchor="middle" fill="#fff" font-size="8" font-family="Arial" font-weight="bold">${iataCode}</text>`;
                }
            }
            
            // Title
            svg += `<text x="${width/2}" y="18" text-anchor="middle" fill="#888" font-size="11" font-family="Arial">TAF + Current Weather Map (Priority: TS  FZ  SN  LIFR  IFR  Wind  MVFR)</text>`;
            
            svg += '</svg>';
            
            container.innerHTML = svg;
        }

        // D-ATIS Functions - Popup Window
        let datisPopup = null;
        let datisData = {};
        let previousAtisData = JSON.parse(localStorage.getItem('previousAtisData') || '{}');
        let acknowledgedChanges = {};
        let datisRefreshInterval = null;
        const DATIS_REFRESH_SECONDS = 120; // 2 minutes
        
        // Official FAA D-ATIS airports (76 total)
        const DATIS_AIRPORTS = [
            // Delta Hubs first
            'KATL', 'KBOS', 'KDTW', 'KJFK', 'KLAX', 'KLGA', 'KMSP', 'KSEA', 'KSLC',
            // All other D-ATIS airports alphabetically
            'KABQ', 'KADW', 'KALB', 'KAUS', 'KBDL', 'KBNA', 'KBOI', 'KBUF', 'KBUR', 
            'KBWI', 'KCHS', 'KCLE', 'KCLT', 'KCMH', 'KCVG', 'KDAL', 'KDCA', 'KDEN', 
            'KDFW', 'KELP', 'KEWR', 'KFLL', 'KGSO', 'KHOU', 'KHPN', 'KIAD', 'KIAH', 
            'KIND', 'KJAX', 'KLAS', 'KLIT', 'KMCI', 'KMCO', 'KMDW', 'KMEM', 'KMIA', 
            'KMKE', 'KMSY', 'KOAK', 'KOKC', 'KOMA', 'KONT', 'KORD', 'KPBI', 'KPDX', 
            'KPHL', 'KPHX', 'KPIT', 'KPVD', 'KRDU', 'KRNO', 'KRSW', 'KSAN', 'KSAT', 
            'KSDF', 'KSFO', 'KSJC', 'KSMF', 'KSNA', 'KSTL', 'KTEB', 'KTPA', 'KTUL', 
            'KVNY', 'PANC', 'PHNL', 'TJSJ'
        ];
        
        // D-ATIS airport names for display
        const DATIS_NAMES = {
            'KABQ': 'Albuquerque', 'KADW': 'Joint Base Andrews', 'KALB': 'Albany',
            'KATL': 'Atlanta', 'KAUS': 'Austin', 'KBDL': 'Bradley/Hartford',
            'KBNA': 'Nashville', 'KBOI': 'Boise', 'KBOS': 'Boston',
            'KBUF': 'Buffalo', 'KBUR': 'Burbank', 'KBWI': 'Baltimore',
            'KCHS': 'Charleston', 'KCLE': 'Cleveland', 'KCLT': 'Charlotte',
            'KCMH': 'Columbus', 'KCVG': 'Cincinnati', 'KDAL': 'Dallas Love',
            'KDCA': 'Washington Reagan', 'KDEN': 'Denver', 'KDFW': 'Dallas/Ft Worth',
            'KDTW': 'Detroit', 'KELP': 'El Paso', 'KEWR': 'Newark',
            'KFLL': 'Ft Lauderdale', 'KGSO': 'Greensboro', 'KHOU': 'Houston Hobby',
            'KHPN': 'Westchester', 'KIAD': 'Washington Dulles', 'KIAH': 'Houston IAH',
            'KIND': 'Indianapolis', 'KJAX': 'Jacksonville', 'KJFK': 'New York JFK',
            'KLAS': 'Las Vegas', 'KLAX': 'Los Angeles', 'KLGA': 'New York LGA',
            'KLIT': 'Little Rock', 'KMCI': 'Kansas City', 'KMCO': 'Orlando',
            'KMDW': 'Chicago Midway', 'KMEM': 'Memphis', 'KMIA': 'Miami',
            'KMKE': 'Milwaukee', 'KMSP': 'Minneapolis', 'KMSY': 'New Orleans',
            'KOAK': 'Oakland', 'KOKC': 'Oklahoma City', 'KOMA': 'Omaha',
            'KONT': 'Ontario CA', 'KORD': 'Chicago ORD', 'KPBI': 'Palm Beach',
            'KPDX': 'Portland', 'KPHL': 'Philadelphia', 'KPHX': 'Phoenix',
            'KPIT': 'Pittsburgh', 'KPVD': 'Providence', 'KRDU': 'Raleigh',
            'KRNO': 'Reno', 'KRSW': 'Ft Myers', 'KSAN': 'San Diego',
            'KSAT': 'San Antonio', 'KSDF': 'Louisville', 'KSEA': 'Seattle',
            'KSFO': 'San Francisco', 'KSJC': 'San Jose', 'KSLC': 'Salt Lake City',
            'KSMF': 'Sacramento', 'KSNA': 'Orange County', 'KSTL': 'St Louis',
            'KTEB': 'Teterboro', 'KTPA': 'Tampa', 'KTUL': 'Tulsa',
            'KVNY': 'Van Nuys', 'PANC': 'Anchorage', 'PHNL': 'Honolulu',
            'TJSJ': 'San Juan'
        };
        
        function openDatisPopup() {
            // Check if popup already open
            if (datisPopup && !datisPopup.closed) {
                datisPopup.focus();
                return;
            }
            
            // Open new popup window
            datisPopup = window.open('', 'DatisPopup', 'width=550,height=700,scrollbars=yes,resizable=yes');
            
            if (!datisPopup) {
                alert('Popup blocked! Please allow popups for this site.');
                return;
            }
            
            // Write initial HTML to popup
            datisPopup.document.write(getDatisPopupHtml());
            datisPopup.document.close();
            
            // Start fetching data and auto-refresh
            fetchAllDatisForPopup();
            startDatisAutoRefresh();
            
            // Check if popup closes and stop refresh
            const checkClosed = setInterval(() => {
                if (datisPopup.closed) {
                    clearInterval(checkClosed);
                    stopDatisAutoRefresh();
                }
            }, 1000);
        }
        
        let datisCountdown = DATIS_REFRESH_SECONDS;
        let datisCountdownInterval = null;
        
        function startDatisAutoRefresh() {
            stopDatisAutoRefresh(); // Clear any existing
            datisCountdown = DATIS_REFRESH_SECONDS;
            
            // Update countdown every second
            datisCountdownInterval = setInterval(() => {
                if (datisPopup && !datisPopup.closed) {
                    datisCountdown--;
                    const mins = Math.floor(datisCountdown / 60);
                    const secs = datisCountdown % 60;
                    const countdownEl = datisPopup.document.getElementById('countdown');
                    if (countdownEl) {
                        countdownEl.textContent = `Next refresh: ${mins}:${secs.toString().padStart(2, '0')}`;
                    }
                    
                    if (datisCountdown <= 0) {
                        datisCountdown = DATIS_REFRESH_SECONDS;
                        fetchAllDatisForPopup();
                    }
                }
            }, 1000);
        }
        
        function stopDatisAutoRefresh() {
            if (datisCountdownInterval) {
                clearInterval(datisCountdownInterval);
                datisCountdownInterval = null;
            }
        }
        
        function getDatisPopupHtml() {
            // Get saved selections or use defaults (max 5)
            const defaultSelections = ['KATL', 'KLGA', 'KJFK', 'KMSP', 'KDTW'];
            let savedSelections = JSON.parse(localStorage.getItem('datisSelectedAirports') || 'null') || defaultSelections;
            // Ensure max 5
            if (savedSelections.length > 5) {
                savedSelections = savedSelections.slice(0, 5);
                localStorage.setItem('datisSelectedAirports', JSON.stringify(savedSelections));
            }
            
            // Helper to get IATA from ICAO
            const getIata = (icao) => icao.startsWith('K') ? icao.substring(1) : 
                                      icao === 'PANC' ? 'ANC' : 
                                      icao === 'PHNL' ? 'HNL' : 
                                      icao === 'TJSJ' ? 'SJU' : icao;
            
            // Build 2-column airport button grid (sorted by busy ranking - DATIS_AIRPORTS order)
            let airportButtonsHtml = '';
            for (const icao of DATIS_AIRPORTS) {
                const iata = getIata(icao);
                const isDelta = DL_HUBS.includes(icao);
                const isSelected = savedSelections.includes(icao);
                airportButtonsHtml += `
                    <button class="airport-btn ${isSelected ? 'selected' : ''} ${isDelta ? 'delta' : ''}" 
                            data-icao="${icao}"
                            onclick="window.opener.toggleDatisAirportBtn('${icao}')">
                        ${iata}
                    </button>
                `;
            }
            
            return `
<!DOCTYPE html>
<html>
<head>
    <title> D-ATIS Monitor</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #fff;
            margin: 0;
            padding: 10px;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: #252540;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        .header h1 {
            margin: 0;
            font-size: 16px;
            color: #f39c12;
        }
        .header-time {
            font-size: 12px;
            color: #888;
        }
        .refresh-btn {
            background: #f39c12;
            color: #000;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        .refresh-btn:hover { background: #e67e22; }
        
        .main-container {
            display: flex;
            gap: 10px;
        }
        
        .selector-panel {
            width: 140px;
            flex-shrink: 0;
            background: #252540;
            border-radius: 8px;
            padding: 8px;
            max-height: calc(100vh - 80px);
            overflow-y: auto;
        }
        
        .selector-title {
            font-size: 11px;
            color: #888;
            margin-bottom: 8px;
            text-align: center;
        }
        
        .airport-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 3px;
        }
        
        .airport-btn {
            background: #1a1a2e;
            border: 1px solid #444;
            color: #888;
            padding: 4px 2px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            font-weight: bold;
            transition: all 0.15s;
        }
        
        .airport-btn:hover {
            background: #2a2a4e;
            border-color: #666;
        }
        
        .airport-btn.selected {
            background: #27ae60;
            border-color: #2ecc71;
            color: #fff;
        }
        
        .airport-btn.selected:hover {
            background: #229954;
        }
        
        .airport-btn.delta {
            color: #e74c3c;
        }
        
        .airport-btn.delta.selected {
            color: #fff;
        }
        
        .selection-count {
            font-size: 10px;
            color: #888;
            text-align: center;
            margin-top: 8px;
            padding-top: 6px;
            border-top: 1px solid #444;
        }
        
        .error-msg {
            background: #c0392b;
            color: #fff;
            padding: 6px;
            border-radius: 4px;
            font-size: 10px;
            text-align: center;
            margin-top: 6px;
            display: none;
        }
        
        .error-msg.show {
            display: block;
            animation: shake 0.3s;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-4px); }
            75% { transform: translateX(4px); }
        }
        
        .experimental-banner {
            background: linear-gradient(135deg, #c0392b, #e74c3c);
            color: #fff;
            padding: 6px 12px;
            text-align: center;
            font-size: 11px;
            font-weight: bold;
            margin-bottom: 8px;
            border-radius: 4px;
        }
        
        .atis-panel {
            flex: 1;
            overflow-y: auto;
            max-height: calc(100vh - 80px);
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #888;
        }
        .airport {
            background: #252540;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
            border-left: 3px solid #f39c12;
            position: relative;
        }
        .airport.delta-hub { border-left-color: #e74c3c; }
        .airport.changed {
            border-left-color: #9b59b6;
            background: #2d1f3d;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(155, 89, 182, 0.4); }
            50% { box-shadow: 0 0 0 8px rgba(155, 89, 182, 0); }
        }
        .airport-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        .airport-code {
            font-weight: bold;
            font-size: 14px;
            color: #fff;
        }
        .airport-code.delta-hub { color: #e74c3c; }
        .atis-letter {
            background: #f39c12;
            color: #000;
            font-weight: bold;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        .atis-letter.changed {
            background: #9b59b6;
            color: #fff;
        }
        .airport-info {
            font-size: 11px;
            color: #ccc;
            line-height: 1.4;
        }
        .runways { color: #27ae60; margin-bottom: 4px; }
        .approaches { color: #3498db; margin-bottom: 4px; }
        .notams {
            color: #e67e22;
            font-size: 10px;
            margin-top: 4px;
            padding-top: 4px;
            border-top: 1px solid #333;
        }
        .timestamp {
            font-size: 9px;
            color: #666;
            margin-top: 4px;
        }
        .atis-type-header {
            font-size: 10px;
            font-weight: bold;
            color: #f39c12;
            margin: 4px 0 2px 0;
        }
        .ack-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: #9b59b6;
            color: #fff;
            border: none;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
        }
        .ack-btn:hover { background: #8e44ad; }
        .error { color: #888; font-style: italic; }
        .ack-all-btn {
            background: #9b59b6;
            color: #fff;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 8px;
        }
        .ack-all-btn:hover { background: #8e44ad; }
        .change-count {
            background: #9b59b6;
            color: #fff;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 11px;
            margin-left: 8px;
        }
        .countdown {
            font-size: 10px;
            color: #888;
            margin-right: 8px;
        }
        .change-detail {
            background: #3d2d1f;
            border-left: 2px solid #f39c12;
            padding: 4px 8px;
            margin: 4px 0;
            font-size: 10px;
            border-radius: 3px;
        }
        .change-detail .was {
            color: #e74c3c;
            text-decoration: line-through;
        }
        .change-detail .now {
            color: #27ae60;
            font-weight: bold;
        }
        .change-detail .arrow {
            color: #f39c12;
            margin: 0 4px;
        }
        .change-label {
            color: #f39c12;
            font-weight: bold;
            margin-right: 4px;
        }
    </style>
</head>
<body>
    <div class="experimental-banner"> EXPERIMENTAL - Parser under development. Verify against raw ATIS.</div>
    <div class="header">
        <div>
            <h1> D-ATIS Monitor</h1>
            <div class="header-time" id="lastUpdate">Loading...</div>
        </div>
        <div>
            <span id="changeCount"></span>
            <button class="ack-all-btn" id="ackAllBtn" style="display:none;" onclick="window.opener.acknowledgeAllDatisChanges()"> ACK All</button>
            <span class="countdown" id="countdown">Next refresh: 2:00</span>
            <button class="refresh-btn" onclick="window.opener.fetchAllDatisForPopup()"> Refresh</button>
        </div>
    </div>
    <div class="main-container">
        <div class="selector-panel">
            <div class="selector-title">SELECT 5 AIRPORTS</div>
            <div class="airport-grid" id="airportGrid">
                ${airportButtonsHtml}
            </div>
            <div class="selection-count" id="selectionCount">${savedSelections.length}/5 selected</div>
            <div class="error-msg" id="errorMsg">Maximum 5 airports!</div>
        </div>
        <div class="atis-panel" id="datisContent">
            <div class="loading">Fetching D-ATIS data...</div>
        </div>
    </div>
</body>
</html>`;
        }
        
        // Get currently selected airports
        function getSelectedDatisAirports() {
            const defaultSelections = ['KATL', 'KLGA', 'KJFK', 'KMSP', 'KDTW'];
            let selections = JSON.parse(localStorage.getItem('datisSelectedAirports') || 'null') || defaultSelections;
            // Ensure max 5
            if (selections.length > 5) {
                selections = selections.slice(0, 5);
                localStorage.setItem('datisSelectedAirports', JSON.stringify(selections));
            }
            return selections;
        }
        
        // Save selected airports
        function saveSelectedDatisAirports(airports) {
            // Ensure max 5
            if (airports.length > 5) {
                airports = airports.slice(0, 5);
            }
            localStorage.setItem('datisSelectedAirports', JSON.stringify(airports));
        }
        
        // Toggle airport selection via button click
        function toggleDatisAirportBtn(icao) {
            const current = getSelectedDatisAirports();
            const isSelected = current.includes(icao);
            
            if (isSelected) {
                // Unselect it
                const updated = current.filter(a => a !== icao);
                saveSelectedDatisAirports(updated);
                updateDatisGridUI();
                // Don't auto-refresh - wait for manual refresh or auto-refresh timer
            } else {
                // Try to select it
                if (current.length >= 5) {
                    // Show error
                    if (datisPopup && !datisPopup.closed) {
                        const errorEl = datisPopup.document.getElementById('errorMsg');
                        if (errorEl) {
                            errorEl.classList.add('show');
                            setTimeout(() => errorEl.classList.remove('show'), 2000);
                        }
                    }
                    return;
                }
                current.push(icao);
                saveSelectedDatisAirports(current);
                updateDatisGridUI();
                // Don't auto-refresh - wait for manual refresh or auto-refresh timer
            }
        }
        
        // Update the grid UI to reflect current selections
        function updateDatisGridUI() {
            if (!datisPopup || datisPopup.closed) return;
            
            const current = getSelectedDatisAirports();
            const buttons = datisPopup.document.querySelectorAll('.airport-btn');
            
            buttons.forEach(btn => {
                const icao = btn.getAttribute('data-icao');
                if (current.includes(icao)) {
                    btn.classList.add('selected');
                } else {
                    btn.classList.remove('selected');
                }
            });
            
            const countEl = datisPopup.document.getElementById('selectionCount');
            if (countEl) {
                countEl.textContent = `${current.length}/5 selected`;
            }
        }
        
        // Toggle airport selection (legacy - keep for compatibility)
        function toggleDatisAirport(icao, checked) {
            const selected = getSelectedDatisAirports();
            if (checked && !selected.includes(icao)) {
                if (selected.length < 5) {
                    selected.push(icao);
                }
            } else if (!checked) {
                const idx = selected.indexOf(icao);
                if (idx > -1) selected.splice(idx, 1);
            }
            saveSelectedDatisAirports(selected);
            updateDatisGridUI();
        }
        
        // Add airport (legacy)
        function addDatisAirport(icao) {
            if (!icao) return;
            const selected = getSelectedDatisAirports();
            if (selected.length >= 5) {
                return;
            }
            if (!selected.includes(icao)) {
                selected.push(icao);
                saveSelectedDatisAirports(selected);
                updateDatisGridUI();
                // Don't auto-refresh - wait for manual refresh or auto-refresh timer
            }
        }
        
        // Remove airport (legacy)
        function removeDatisAirport(icao) {
            const selected = getSelectedDatisAirports();
            const idx = selected.indexOf(icao);
            if (idx > -1) {
                selected.splice(idx, 1);
                saveSelectedDatisAirports(selected);
                updateDatisGridUI();
                // Don't auto-refresh - wait for manual refresh or auto-refresh timer
            }
        }
        
        // Update selection count display (legacy)
        function updateDatisSelectionCount() {
            if (!datisPopup || datisPopup.closed) return;
            const countEl = datisPopup.document.getElementById('selectionCount');
            if (countEl) {
                const selected = getSelectedDatisAirports();
                countEl.textContent = `${selected.length}/5 selected`;
            }
        }
        
        // Refresh the popup (reopen with new selections)
        function refreshDatisPopup() {
            if (!datisPopup || datisPopup.closed) return;
            datisPopup.document.body.innerHTML = getDatisPopupHtml().match(/<body[^>]*>([\s\S]*)<\/body>/i)[1];
            fetchAllDatisForPopup();
        }
        
        async function fetchDatis(icao) {
            const url = `https://datis.clowd.io/api/${icao}`;
            
            // Try each proxy
            for (let i = 0; i < CORS_PROXIES.length; i++) {
                try {
                    const proxyUrl = CORS_PROXIES[i](url);
                    const response = await fetch(proxyUrl);
                    if (!response.ok) continue;
                    
                    const text = await response.text();
                    if (!text || text.length < 10) continue;
                    
                    // Parse JSON
                    try {
                        const data = JSON.parse(text);
                        if (data && (Array.isArray(data) || data.datis)) {
                            return Array.isArray(data) ? data : [data];
                        }
                    } catch (parseErr) {
                        continue;
                    }
                } catch (e) {
                    continue;
                }
            }
            
            return null;
        }
        
        async function fetchAllDatisForPopup() {
            if (!datisPopup || datisPopup.closed) return;
            
            const contentEl = datisPopup.document.getElementById('datisContent');
            const lastUpdateEl = datisPopup.document.getElementById('lastUpdate');
            const changeCountEl = datisPopup.document.getElementById('changeCount');
            const ackAllBtn = datisPopup.document.getElementById('ackAllBtn');
            
            if (!contentEl) return;
            
            // Reset countdown
            datisCountdown = DATIS_REFRESH_SECONDS;
            
            // Get selected airports only
            const selectedAirports = getSelectedDatisAirports();
            
            contentEl.innerHTML = '<div class="loading">Fetching D-ATIS data...</div>';
            
            // Fetch in smaller batches
            const batchSize = 5;
            const results = [];
            
            for (let i = 0; i < selectedAirports.length; i += batchSize) {
                if (datisPopup.closed) return;
                
                const batch = selectedAirports.slice(i, i + batchSize);
                contentEl.innerHTML = `<div class="loading">Fetching D-ATIS... ${i + 1}-${Math.min(i + batchSize, selectedAirports.length)} of ${selectedAirports.length}</div>`;
                
                const batchPromises = batch.map(icao => fetchDatis(icao).then(data => ({ icao, data })));
                const batchResults = await Promise.all(batchPromises);
                results.push(...batchResults);
                
                if (i + batchSize < selectedAirports.length) {
                    await new Promise(r => setTimeout(r, 200));
                }
            }
            
            if (datisPopup.closed) return;
            
            // Store data and check for changes
            const now = new Date();
            const timestamp = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            let changedCount = 0;
            
            let html = '';
            for (const { icao, data } of results) {
                const isDeltaHub = DL_HUBS.includes(icao);
                const airportName = DATIS_NAMES[icao] || AIRPORT_NAMES[icao] || icao;
                // Handle non-K prefix airports (PANC, PHNL, TJSJ)
                const iata = icao.startsWith('K') ? icao.substring(1) : 
                             icao === 'PANC' ? 'ANC' : 
                             icao === 'PHNL' ? 'HNL' : 
                             icao === 'TJSJ' ? 'SJU' : icao;
                
                let hasChanged = false;
                let allLetters = [];
                let changes = []; // Track specific changes
                
                if (data && data.length > 0) {
                    // Collect all ATIS data
                    for (const atis of data) {
                        const letter = extractAtisLetter(atis.datis);
                        // API returns lowercase "arr" or "dep", or check the ATIS text
                        let type = 'COMBINED';
                        if (atis.type === 'arr' || atis.datis.includes('ARR ATIS')) {
                            type = 'ARR';
                        } else if (atis.type === 'dep' || atis.datis.includes('DEP ATIS')) {
                            type = 'DEP';
                        }
                        const parsed = parseDatis(atis.datis);
                        allLetters.push({ letter, type, datis: atis.datis, parsed });
                    }
                    
                    // Build current state for comparison
                    const currentState = {
                        letters: allLetters.map(a => `${a.type}:${a.letter}`).join(','),
                        runways: allLetters.map(a => a.parsed.runways || '').join('|'),
                        approaches: allLetters.map(a => a.parsed.approaches || '').join('|')
                    };
                    
                    // Compare with previous state
                    const prevState = previousAtisData[icao];
                    if (prevState && !acknowledgedChanges[icao]) {
                        // Check for letter change
                        if (prevState.letters !== currentState.letters) {
                            hasChanged = true;
                            const prevLetterParts = prevState.letters.split(',');
                            const currLetterParts = currentState.letters.split(',');
                            for (let i = 0; i < Math.max(prevLetterParts.length, currLetterParts.length); i++) {
                                const prev = prevLetterParts[i] || '';
                                const curr = currLetterParts[i] || '';
                                if (prev !== curr) {
                                    const prevLetter = prev.split(':')[1] || '?';
                                    const currLetter = curr.split(':')[1] || '?';
                                    const typeLabel = curr.split(':')[0] || '';
                                    changes.push({ 
                                        type: 'ATIS Letter' + (typeLabel !== 'COMBINED' ? ` (${typeLabel})` : ''), 
                                        was: prevLetter, 
                                        now: currLetter 
                                    });
                                }
                            }
                        }
                        
                        // Check for runway change
                        if (prevState.runways !== currentState.runways) {
                            hasChanged = true;
                            changes.push({ 
                                type: 'Runways', 
                                was: prevState.runways.replace(/\|/g, ' / ') || 'N/A', 
                                now: currentState.runways.replace(/\|/g, ' / ') || 'N/A' 
                            });
                        }
                        
                        // Check for approach change
                        if (prevState.approaches !== currentState.approaches) {
                            hasChanged = true;
                            changes.push({ 
                                type: 'Approaches', 
                                was: prevState.approaches.replace(/\|/g, ' / ') || 'N/A', 
                                now: currentState.approaches.replace(/\|/g, ' / ') || 'N/A' 
                            });
                        }
                    }
                    
                    if (hasChanged) changedCount++;
                    
                    // Store current state
                    datisData[icao] = {
                        ...currentState,
                        data: data,
                        timestamp: now.toISOString()
                    };
                }
                
                const changedClass = hasChanged ? 'changed' : '';
                html += `<div class="airport ${isDeltaHub ? 'delta-hub' : ''} ${changedClass}" id="datis-${icao}">`;
                
                if (hasChanged) {
                    html += `<button class="ack-btn" onclick="window.opener.acknowledgeDatisChange('${icao}')"> ACK</button>`;
                }
                
                html += `<div class="airport-header">`;
                html += `<span class="airport-code ${isDeltaHub ? 'delta-hub' : ''}">${iata} - ${airportName}${isDeltaHub ? ' (DL)' : ''}</span>`;
                
                if (data && data.length > 0) {
                    // Show all ATIS letters
                    const letterBadges = allLetters.map(a => {
                        const typeLabel = a.type === 'ARR' ? 'A' : a.type === 'DEP' ? 'D' : '';
                        return `<span class="atis-letter ${hasChanged ? 'changed' : ''}">${typeLabel}${a.letter}</span>`;
                    }).join(' ');
                    html += letterBadges;
                    html += `</div>`;
                    
                    // Show change details if changed
                    if (hasChanged && changes.length > 0) {
                        html += `<div class="change-details">`;
                        for (const change of changes) {
                            html += `<div class="change-detail">`;
                            html += `<span class="change-label">${change.type}:</span>`;
                            html += `<span class="was">${change.was}</span>`;
                            html += `<span class="arrow"></span>`;
                            html += `<span class="now">${change.now}</span>`;
                            html += `</div>`;
                        }
                        html += `</div>`;
                    }
                    
                    html += `<div class="airport-info">`;
                    
                    // Show each ATIS separately if multiple
                    for (let i = 0; i < data.length; i++) {
                        const atis = data[i];
                        // Handle both lowercase API values and uppercase in text
                        let atisType = '';
                        if (atis.type === 'arr' || atis.datis.includes('ARR ATIS')) {
                            atisType = 'ARR';
                        } else if (atis.type === 'dep' || atis.datis.includes('DEP ATIS')) {
                            atisType = 'DEP';
                        }
                        const parsed = parseDatis(atis.datis);
                        
                        if (data.length > 1) {
                            html += `<div class="atis-type-header">${atisType === 'ARR' ? ' ARRIVAL' : atisType === 'DEP' ? ' DEPARTURE' : ' ATIS'}</div>`;
                        }
                        
                        // Weather summary line
                        const wxParts = [];
                        if (parsed.wind) wxParts.push(parsed.wind);
                        if (parsed.visibility) wxParts.push(parsed.visibility);
                        if (parsed.weather) wxParts.push(parsed.weather);
                        if (parsed.ceiling) wxParts.push(parsed.ceiling);
                        if (parsed.altimeter) wxParts.push('A' + parsed.altimeter);
                        
                        if (wxParts.length > 0) {
                            html += `<div class="weather-line"> <strong>Wx:</strong> ${wxParts.join('  ')}</div>`;
                        }
                        
                        if (parsed.runways) {
                            html += `<div class="runways"> <strong>Runways:</strong> ${parsed.runways}</div>`;
                        }
                        if (parsed.approaches) {
                            html += `<div class="approaches"> <strong>Approaches:</strong> ${parsed.approaches}</div>`;
                        }
                        if (parsed.notams && parsed.notams.length > 0) {
                            html += `<div class="notams"> <strong>Alerts:</strong> ${parsed.notams}</div>`;
                        }
                        
                        if (i < data.length - 1) {
                            html += `<div style="border-top: 1px dashed #444; margin: 6px 0;"></div>`;
                        }
                    }
                    
                    html += `<div class="timestamp">Updated: ${timestamp}</div>`;
                    html += `</div>`;
                } else {
                    html += `</div>`;
                    html += `<div class="airport-info error">D-ATIS not available</div>`;
                }
                
                html += `</div>`;
            }
            
            contentEl.innerHTML = html;
            lastUpdateEl.textContent = `Last update: ${timestamp}`;
            
            // Update change count
            if (changedCount > 0) {
                changeCountEl.innerHTML = `<span class="change-count">${changedCount} changed</span>`;
                ackAllBtn.style.display = 'inline-block';
            } else {
                changeCountEl.innerHTML = '';
                ackAllBtn.style.display = 'none';
            }
            
            // Save current state for next comparison (only if not already stored)
            for (const { icao, data } of results) {
                if (data && data.length > 0 && !previousAtisData[icao]) {
                    const allLetters = data.map(atis => {
                        const letter = extractAtisLetter(atis.datis);
                        const type = atis.type || (atis.datis.includes('ARR') ? 'ARR' : atis.datis.includes('DEP') ? 'DEP' : 'COMBINED');
                        return `${type}:${letter}`;
                    }).join(',');
                    const parsed = data.map(atis => parseDatis(atis.datis));
                    previousAtisData[icao] = {
                        letters: allLetters,
                        runways: parsed.map(p => p.runways || '').join('|'),
                        approaches: parsed.map(p => p.approaches || '').join('|')
                    };
                }
            }
            localStorage.setItem('previousAtisData', JSON.stringify(previousAtisData));
        }
        
        function acknowledgeDatisChange(icao) {
            acknowledgedChanges[icao] = true;
            
            // Update the stored data
            if (datisData[icao]) {
                previousAtisData[icao] = {
                    letters: datisData[icao].letters,
                    runways: datisData[icao].runways,
                    approaches: datisData[icao].approaches
                };
                localStorage.setItem('previousAtisData', JSON.stringify(previousAtisData));
            }
            
            // Remove highlight from this airport
            if (datisPopup && !datisPopup.closed) {
                const el = datisPopup.document.getElementById(`datis-${icao}`);
                if (el) {
                    el.classList.remove('changed');
                    const ackBtn = el.querySelector('.ack-btn');
                    if (ackBtn) ackBtn.remove();
                    const letterEl = el.querySelector('.atis-letter');
                    if (letterEl) letterEl.classList.remove('changed');
                    // Remove change details section
                    const changeDetails = el.querySelector('.change-details');
                    if (changeDetails) changeDetails.remove();
                }
                
                // Update count
                const changedEls = datisPopup.document.querySelectorAll('.airport.changed');
                const changeCountEl = datisPopup.document.getElementById('changeCount');
                const ackAllBtn = datisPopup.document.getElementById('ackAllBtn');
                
                if (changedEls.length === 0) {
                    changeCountEl.innerHTML = '';
                    ackAllBtn.style.display = 'none';
                } else {
                    changeCountEl.innerHTML = `<span class="change-count">${changedEls.length} changed</span>`;
                }
            }
        }
        
        function acknowledgeAllDatisChanges() {
            if (!datisPopup || datisPopup.closed) return;
            
            const changedEls = datisPopup.document.querySelectorAll('.airport.changed');
            changedEls.forEach(el => {
                const icao = el.id.replace('datis-', '');
                acknowledgeDatisChange(icao);
            });
        }
        
        function extractAtisLetter(datis) {
            // Look for "ATIS INFO X" or "INFO X"
            const match = datis.match(/ATIS\s+INFO\s+([A-Z])|INFO\s+([A-Z])\s+\d{4}Z/i);
            if (match) {
                return match[1] || match[2];
            }
            return '?';
        }
        
        function parseDatis(datis) {
            const result = {
                runways: '',
                approaches: '',
                notams: '',
                wind: '',
                visibility: '',
                ceiling: '',
                altimeter: '',
                weather: ''
            };
            
            if (!datis) return result;
            
            // Normalize the text
            const text = datis.toUpperCase();
            
            // ===== EXTRACT WEATHER DATA (METAR portion - before RMK) =====
            const rmkIndex = text.indexOf(' RMK ');
            const metarPart = rmkIndex > 0 ? text.substring(0, rmkIndex) : text.split('.')[0];
            
            // Wind: pattern like 11003KT, 25015G25KT, VRB03KT, CALM
            const windMatch = metarPart.match(/\b(VRB|\d{3})(\d{2,3})(G(\d{2,3}))?KT\b/);
            if (windMatch) {
                const dir = windMatch[1];
                const spd = parseInt(windMatch[2]);
                const gust = windMatch[4] ? parseInt(windMatch[4]) : null;
                result.wind = gust ? `${dir}@${spd}G${gust}kt` : `${dir}@${spd}kt`;
            } else if (/\bCALM\b/.test(metarPart)) {
                result.wind = 'Calm';
            }
            
            // Visibility: patterns like 3/4SM, 10SM, 1 1/2SM, P6SM, M1/4SM
            const visMatch = metarPart.match(/\b([PM])?(\d+)?\s*(\d\/\d)?SM\b/);
            if (visMatch) {
                let vis = '';
                if (visMatch[1] === 'P') vis = '>';
                if (visMatch[1] === 'M') vis = '<';
                if (visMatch[2]) vis += visMatch[2];
                if (visMatch[3]) vis += (visMatch[2] ? ' ' : '') + visMatch[3];
                result.visibility = vis + 'SM';
            }
            
            // Ceiling/Sky: VV002, BKN015, OVC025, FEW040, SCT080, CLR, SKC
            const skyPatterns = metarPart.match(/\b(VV|OVC|BKN|FEW|SCT|CLR|SKC)(\d{3})?\b/g);
            if (skyPatterns) {
                const ceilings = [];
                for (const sky of skyPatterns) {
                    if (sky === 'CLR' || sky === 'SKC') {
                        ceilings.push('Clear');
                        continue;
                    }
                    const match = sky.match(/(VV|OVC|BKN|FEW|SCT)(\d{3})/);
                    if (match) {
                        const type = match[1];
                        const alt = parseInt(match[2]) * 100;
                        const altStr = alt < 1000 ? String(alt) : (alt/1000).toFixed(1).replace('.0','') + 'k';
                        ceilings.push(`${type}${altStr}`);
                    }
                }
                if (ceilings.length > 0) {
                    result.ceiling = ceilings.slice(0, 2).join(' ');
                }
            }
            
            // Weather phenomena: BR, FG, RA, SN, TS, etc.
            const wxLabels = {
                'BR': 'Mist', 'FG': 'Fog', 'HZ': 'Haze', 'RA': 'Rain', 'DZ': 'Drizzle',
                'SN': 'Snow', 'TS': 'T-Storm', 'TSRA': 'T-Storm', 'FZRA': 'FZRA',
                'FZDZ': 'FZDZ', '+RA': 'Hvy Rain', '-RA': 'Lt Rain', 'FU': 'Smoke',
                '+SN': 'Hvy Snow', '-SN': 'Lt Snow', 'VCSH': 'VC Shwrs', 'VCTS': 'VC T-Storm',
                '-DZ': 'Lt Drizzle', '+DZ': 'Hvy Drizzle', 'GR': 'Hail', 'GS': 'Sm Hail',
                'SQ': 'Squall', 'FC': 'Funnel', 'PO': 'Dust Devil', 'BLSN': 'Blowing Snow'
            };
            // Look for weather phenomena - can be after visibility (with possible RVR in between) and before sky condition
            // Pattern handles: "3/4SM BR VV002" or "3/4SM R25L/P6000FT BR VV002"
            const wxPatterns = metarPart.match(/\s([-+]?(?:VC)?(?:MI|PR|BC|DR|BL|SH|TS|FZ)?(?:DZ|RA|SN|SG|IC|PL|GR|GS|UP|BR|FG|FU|VA|DU|SA|HZ|PY|PO|SQ|FC|SS|DS)+)\s+(?:VV|OVC|BKN|SCT|FEW|CLR|SKC|\d{2}\/)/g);
            if (wxPatterns) {
                const wxCodes = [];
                for (const wxMatch of wxPatterns) {
                    const code = wxMatch.trim().split(/\s/)[0];
                    if (code && code.length >= 2) {
                        wxCodes.push(wxLabels[code] || code);
                    }
                }
                if (wxCodes.length > 0) {
                    result.weather = wxCodes.join(', ');
                }
            }
            
            // Altimeter: A3009, A2992
            const altMatch = metarPart.match(/\bA(\d{4})\b/);
            if (altMatch) {
                const alt = altMatch[1];
                result.altimeter = alt.substring(0,2) + '.' + alt.substring(2);
            }
            
            // ===== EXTRACT RUNWAYS =====
            const runwaysArr = new Set();
            const runwaysDep = new Set();
            
            // Pattern: "APCHS RY 24R AND 25L" or variations
            // Match the runway numbers that come after approach mentions
            const apchSection = text.match(/(?:INST(?:RUMENT)?\s+)?APCHS?\s+(?:AND\s+)?(?:RNAV\s+)?(?:RNP\s+)?(?:APCHS?\s+)?(?:RWY?|RY)\s*(\d{1,2}[LRC]?)(?:\s*(?:AND|,)\s*(\d{1,2}[LRC]?))?/gi);
            if (apchSection) {
                for (const m of apchSection) {
                    const nums = m.match(/\d{1,2}[LRC]/g);
                    if (nums) nums.forEach(r => runwaysArr.add(r));
                }
            }
            
            // Pattern: "SIMUL INSTR DEPARTURES IN PROG RWYS 24 AND 25"
            const simulDepMatch = text.match(/(?:SIMUL(?:TANEOUS)?\s+)?(?:INSTR?(?:UMENT)?\s+)?DEP(?:ARTURE)?S?\s+(?:IN\s+PROG(?:RESS)?)?\s*(?:RWY?S?|RY)\s*(\d{1,2}[LRC]?)(?:\s*(?:AND|,)\s*(\d{1,2}[LRC]?))?/gi);
            if (simulDepMatch) {
                for (const m of simulDepMatch) {
                    const nums = m.match(/\d{1,2}[LRC]?/g);
                    if (nums) {
                        // Filter out numbers that are likely part of other context
                        nums.filter(n => parseInt(n) <= 36).forEach(r => runwaysDep.add(r));
                    }
                }
            }
            
            // Pattern: "DEPARTING RWY 31L" or "DEP RY 27L"  
            const depMatch = text.match(/DEP(?:ARTING|G)?\s+(?:RWY?|RY)\s*(\d{1,2}[LRC]?)(?:\s*(?:AND|,)\s*(\d{1,2}[LRC]?))?/gi);
            if (depMatch) {
                for (const m of depMatch) {
                    const nums = m.match(/\d{1,2}[LRC]?/g);
                    if (nums) nums.filter(n => parseInt(n) <= 36).forEach(r => runwaysDep.add(r));
                }
            }
            
            // Pattern: "ARRIVALS RWY 27L" or "ARR RY 27L" or "LANDING RWY"
            const arrMatch = text.match(/(?:ARR(?:IVAL)?S?|LANDING|LNDG)\s+(?:RWY?|RY)\s*(\d{1,2}[LRC]?)(?:\s*(?:AND|,)\s*(\d{1,2}[LRC]?))?/gi);
            if (arrMatch) {
                for (const m of arrMatch) {
                    const nums = m.match(/\d{1,2}[LRC]?/g);
                    if (nums) nums.filter(n => parseInt(n) <= 36).forEach(r => runwaysArr.add(r));
                }
            }
            
            // Pattern: "LANDING AND DEPARTING RY 26"
            const ldgDepMatch = text.match(/LAND(?:ING|G)\s+AND\s+DEP(?:ARTING|G)?\s*(?:RWY?|RY)\s*(\d{1,2}[LRC]?)(?:\s*(?:AND|,)\s*(\d{1,2}[LRC]?))?/gi);
            if (ldgDepMatch) {
                for (const m of ldgDepMatch) {
                    const nums = m.match(/\d{1,2}[LRC]?/g);
                    if (nums) {
                        nums.filter(n => parseInt(n) <= 36).forEach(r => {
                            runwaysArr.add(r);
                            runwaysDep.add(r);
                        });
                    }
                }
            }
            
            // Build runway string - separate arrival/departure if different
            if (runwaysArr.size > 0 || runwaysDep.size > 0) {
                const arrList = [...runwaysArr].sort();
                const depList = [...runwaysDep].sort();
                
                if (arrList.length > 0 && depList.length > 0 && arrList.join(',') !== depList.join(',')) {
                    result.runways = `Arr: ${arrList.join(', ')} | Dep: ${depList.join(', ')}`;
                } else if (arrList.length > 0) {
                    result.runways = arrList.join(', ');
                } else if (depList.length > 0) {
                    result.runways = depList.join(', ');
                }
            }
            
            // ===== EXTRACT APPROACHES =====
            const approaches = [];
            
            // Pattern: "INST APCHS" = Instrument approaches (ILS)
            if (/INST(?:RUMENT)?\s+APCHS?/i.test(text)) {
                approaches.push('ILS');
            }
            
            // Pattern: "RNAV RNP APCHS" or "RNAV APCHS"
            if (/RNAV\s+(?:RNP\s+)?APCHS?/i.test(text)) {
                approaches.push('RNAV');
            }
            
            // Pattern: "VISUAL APCHS" or "VISUAL APCH"
            if (/VISUAL\s+APCHS?/i.test(text)) {
                approaches.push('Visual');
            }
            
            // Pattern: "GPS APCHS" 
            if (/GPS\s+APCHS?/i.test(text)) {
                approaches.push('GPS');
            }
            
            // Pattern: "ILS APCH RWY 27L" (specific ILS callout)
            const ilsRwyMatch = text.match(/ILS\s+(?:APCH\s+)?(?:RWY?|RY)\s*(\d{1,2}[LRC]?)/gi);
            if (ilsRwyMatch) {
                for (const m of ilsRwyMatch) {
                    const rwy = m.match(/\d{1,2}[LRC]?/);
                    if (rwy) approaches.push('ILS ' + rwy[0]);
                }
            }
            
            // Pattern: "EXPECT ILS" or "EXPECT VISUAL"
            const expectMatch = text.match(/EXPECT\s+(ILS|VISUAL|RNAV|GPS|VOR|LOC)/gi);
            if (expectMatch) {
                for (const m of expectMatch) {
                    const type = m.replace(/EXPECT\s+/i, '');
                    if (!approaches.some(a => a.toUpperCase().includes(type))) {
                        approaches.push('Exp ' + type);
                    }
                }
            }
            
            if (approaches.length > 0) {
                result.approaches = [...new Set(approaches)].slice(0, 4).join(', ');
            }
            
            // ===== EXTRACT NOTAMS / ALERTS =====
            const notams = [];
            
            // OTS patterns - "RY 25R MALSR OTS"
            const rwyOtsMatch = text.match(/(?:RWY?|RY)\s*(\d{1,2}[LRC]?)\s+(MALSR|ALSF|PAPI|VASI|ALS|REIL|VGSI)\s+OTS/gi);
            if (rwyOtsMatch) {
                for (const m of rwyOtsMatch) {
                    notams.push(m.trim().replace(/\s+/g, ' '));
                }
            }
            
            // OTS patterns - "PAPI OTS 25R"
            const equipOtsMatch = text.match(/(MALSR|ALSF|PAPI|VASI|ALS|REIL|VGSI)\s+OTS\s*(?:RWY?|RY)?\s*(\d{1,2}[LRC]?)?/gi);
            if (equipOtsMatch) {
                for (const m of equipOtsMatch) {
                    const cleaned = m.trim().replace(/\s+/g, ' ');
                    if (!notams.some(n => n.includes(cleaned))) {
                        notams.push(cleaned);
                    }
                }
            }
            
            // VOR/DME OTS - "VENTURA VOR OTS"
            const navaidOtsMatch = text.match(/[A-Z]{3,}\s+(?:VOR|DME|VORTAC|NDB|ILS|LOC|GS)\s+OTS/gi);
            if (navaidOtsMatch) {
                for (const m of navaidOtsMatch) {
                    if (!notams.some(n => n.includes(m.trim()))) {
                        notams.push(m.trim());
                    }
                }
            }
            
            // Runway/Taxiway closures
            const closedMatch = text.match(/(?:RWY?|RY|TWY|TAXIWAY)\s*[\dA-Z\/]+\s*CL[SO]D/gi);
            if (closedMatch) {
                for (const m of closedMatch) {
                    if (!notams.includes(m.trim())) notams.push(m.trim());
                }
            }
            
            // Bird activity
            if (/BIRD\s+ACT(?:IVITY)?/i.test(text)) {
                notams.push('BIRD ACTIVITY');
            }
            
            // Runway incursion warnings
            if (/RUNWAY\s+INCURSION/i.test(text)) {
                notams.push(' RWY INCURSION CAUTION');
            }
            
            // TFR
            if (/\bTFR\b/.test(text)) {
                notams.push('TFR');
            }
            
            // Construction
            if (/\bCONST(?:RUCTION)?\b/i.test(text)) {
                notams.push('CONSTRUCTION');
            }
            
            // Crane
            if (/\bCRANE\b/i.test(text)) {
                notams.push('CRANE');
            }
            
            // Braking action
            const brakingMatch = text.match(/BRAKING\s+ACTION\s+(GOOD|MEDIUM|POOR|NIL)/i);
            if (brakingMatch) {
                notams.push('BA: ' + brakingMatch[1]);
            }
            
            // LAHSO
            if (/\bLAHSO\b/.test(text)) {
                notams.push('LAHSO');
            }
            
            // Low visibility ops
            if (/LOW\s+VIS(?:IBILITY)?\s+(?:PROC|OPS)/i.test(text)) {
                notams.push('LOW VIS OPS');
            }
            
            // Hazardous weather info
            if (/HAZD?\s+WX/i.test(text)) {
                notams.push('HAZ WX AVBL');
            }
            
            if (notams.length > 0) {
                result.notams = [...new Set(notams)].slice(0, 6).join('; ');
            }
            
            return result;
        }

        // Collapsible section state management
        const sectionState = JSON.parse(localStorage.getItem('deicingMonitorSections') || '{}');
        let navigatedSection = null; // Track section navigated to via summary card
        
        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            if (!section) return;
            const content = section.querySelector('.section-content');
            const toggle = section.querySelector('.section-toggle');
            
            if (section.classList.contains('collapsed')) {
                section.classList.remove('collapsed');
                if (content) content.classList.remove('collapsed');
                if (toggle) toggle.textContent = '';
                sectionState[sectionId] = 'expanded';
            } else {
                section.classList.add('collapsed');
                if (content) content.classList.add('collapsed');
                if (toggle) toggle.textContent = '';
                sectionState[sectionId] = 'collapsed';
                
                // If this was the section navigated to via summary card, scroll to top
                if (navigatedSection === sectionId) {
                    navigatedSection = null;
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
            }
            
            localStorage.setItem('deicingMonitorSections', JSON.stringify(sectionState));
        }
        
        function getSectionClass(sectionId) {
            // Default to collapsed unless explicitly expanded
            return sectionState[sectionId] === 'expanded' ? '' : 'collapsed';
        }
        
        function getSectionToggle(sectionId) {
            // Default to collapsed unless explicitly expanded
            return sectionState[sectionId] === 'expanded' ? '&#x25BC;' : '&#x25B6;';
        }
        
        function getSectionContentClass(sectionId) {
            // Default to collapsed unless explicitly expanded
            return sectionState[sectionId] === 'expanded' ? '' : 'collapsed';
        }
        
        function expandAllSections() {
            const sections = ['section-traffic', 'section-arr-dep', 'section-deicing', 'section-planned', 
                             'section-closure', 'section-runway', 'section-infogrid', 'section-taf', 'section-frost', 'section-precip',
                             'section-lifr', 'section-ifr', 'section-taf-lifr', 'section-taf-ifr', 'section-high-wind',
                             'section-taf-wind', 'section-tstorm', 'section-taf-tstorm',
                             'section-active', 'section-residual', 'section-likely', 'section-possible', 'section-none'];
            for (const sectionId of sections) {
                const section = document.getElementById(sectionId);
                if (section) {
                    section.classList.remove('collapsed');
                    const content = section.querySelector('.section-content');
                    const toggle = section.querySelector('.section-toggle');
                    if (content) content.classList.remove('collapsed');
                    if (toggle) toggle.textContent = '';
                    sectionState[sectionId] = 'expanded';
                }
            }
            localStorage.setItem('deicingMonitorSections', JSON.stringify(sectionState));
        }
        
        function collapseAllSections() {
            const sections = ['section-traffic', 'section-arr-dep', 'section-deicing', 'section-planned', 
                             'section-closure', 'section-runway', 'section-infogrid', 'section-taf', 'section-frost', 'section-precip',
                             'section-lifr', 'section-ifr', 'section-taf-lifr', 'section-taf-ifr', 'section-high-wind',
                             'section-taf-wind', 'section-tstorm', 'section-taf-tstorm',
                             'section-active', 'section-residual', 'section-likely', 'section-possible', 'section-none'];
            for (const sectionId of sections) {
                const section = document.getElementById(sectionId);
                if (section) {
                    section.classList.add('collapsed');
                    const content = section.querySelector('.section-content');
                    const toggle = section.querySelector('.section-toggle');
                    if (content) content.classList.add('collapsed');
                    if (toggle) toggle.textContent = '';
                    sectionState[sectionId] = 'collapsed';
                }
            }
            localStorage.setItem('deicingMonitorSections', JSON.stringify(sectionState));
        }
        
        function updateDashboardCard(cardType, count, hasHub = false) {
            const countEl = document.getElementById(`count-${cardType}`);
            const cardEl = document.getElementById(`card-${cardType}`);
            
            if (countEl) {
                // Add asterisk if a hub is affected
                const asterisk = hasHub ? '*' : '';
                countEl.textContent = count + asterisk;
            }
            
            if (cardEl) {
                // Handle both number and string counts (like "2/5")
                const isZero = count === 0 || count === '0' || count === '0/0';
                if (isZero) {
                    cardEl.classList.add('disabled');
                } else {
                    cardEl.classList.remove('disabled');
                }
                
                // Add visual indicator for hub affected
                if (hasHub && count > 0) {
                    cardEl.classList.add('hub-affected');
                } else {
                    cardEl.classList.remove('hub-affected');
                }
            }
        }
        
        function scrollToSection(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                // Track this as the navigated section
                navigatedSection = sectionId;
                
                // Expand the section if collapsed
                if (section.classList.contains('collapsed')) {
                    section.classList.remove('collapsed');
                    const content = section.querySelector('.section-content');
                    const toggle = section.querySelector('.section-toggle');
                    if (content) content.classList.remove('collapsed');
                    if (toggle) toggle.textContent = '';
                    sectionState[sectionId] = 'expanded';
                    localStorage.setItem('deicingMonitorSections', JSON.stringify(sectionState));
                }
                // Scroll to section
                section.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        function toggleHistory(id) {
            const el = document.getElementById(id);
            if (el) {
                el.classList.toggle('show');
            }
        }

        function toggleTafFull(tafId) {
            const el = document.getElementById(tafId);
            if (el) {
                el.classList.toggle('show');
                // Update the expand icon
                const parent = el.parentElement;
                const icon = parent.querySelector('.taf-expand-icon');
                if (icon) {
                    icon.textContent = el.classList.contains('show') ? ' TAF' : ' TAF';
                }
            }
            event.stopPropagation();
        }
        
        function toggleTafInline(el) {
            if (!el) return;
            el.classList.toggle('expanded');
            // Update the expand indicator in the parent taf-forecast div
            const parent = el.previousElementSibling;
            if (parent && parent.classList.contains('taf-forecast')) {
                const indicator = parent.querySelector('span:last-child');
                if (indicator) {
                    indicator.textContent = el.classList.contains('expanded') ? ' collapse' : ' expand';
                }
            }
            event.stopPropagation();
        }

        function renderSection(title, airports, sectionId) {
            // Determine section color based on title
            let sectionClass = 'section-deice-default';
            if (title.includes('Active')) sectionClass = 'section-deice-active';
            else if (title.includes('Residual')) sectionClass = 'section-deice-residual';
            else if (title.includes('Likely')) sectionClass = 'section-deice-likely';
            else if (title.includes('Possible')) sectionClass = 'section-deice-possible';
            else if (title.includes('Clear') || title.includes('None')) sectionClass = 'section-deice-none';
            
            let html = `
                <div id="${sectionId}" class="collapsible-section ${sectionClass} ${getSectionClass(sectionId)}">
                    <div class="section-header" onclick="toggleSection('${sectionId}')">
                        <h3>${title} (${airports.length})</h3>
                        <span class="section-toggle">${getSectionToggle(sectionId)}</span>
                    </div>
                    <div class="section-content ${getSectionContentClass(sectionId)}">
                        <div class="airport-list">
            `;

            for (const apt of airports) {
                const name = AIRPORT_NAMES[apt.icao] || apt.icao;
                const wx = formatWeatherDisplay(apt);
                const frClass = `fr-${apt.flight_rules.toLowerCase()}`;
                const rank = AIRPORTS.indexOf(apt.icao) + 1;
                const metarUrl = `https://aviationweather.gov/data/metar/?id=${apt.icao}&hours=6`;
                const notamUrl = `https://notams.aim.faa.gov/notamSearch/`;
                const timeSince = getTimeSince(apt.obs_time);
                const historyId = `history-${apt.icao}`;
                
                // Store wind data globally for runway map
                currentWindData[apt.icao] = {
                    direction: (apt.wind_variable || apt.wind_dir === 'VRB') ? null : apt.wind_dir,
                    speed: apt.wind_speed,
                    gust: apt.wind_gust,
                    variable: apt.wind_variable || apt.wind_dir === 'VRB'
                };
                
                // Format wind info
                let windHtml = '';
                if (apt.wind_speed !== null) {
                    let windClass = '';
                    let windText = '';
                    
                    if (apt.wind_variable) {
                        windText = `VRB${apt.wind_speed}kt`;
                    } else if (apt.wind_dir !== null) {
                        windText = `${String(apt.wind_dir).padStart(3, '0')}&deg;/${apt.wind_speed}kt`;
                    } else {
                        windText = `${apt.wind_speed}kt`;
                    }
                    
                    if (apt.wind_gust) {
                        windText += `G${apt.wind_gust}`;
                        windClass = apt.wind_gust >= 25 ? 'strong' : 'gusty';
                    } else if (apt.wind_speed >= 20) {
                        windClass = 'strong';
                    }
                    
                    windHtml = `<span class="wind-info ${windClass}"> ${windText}</span>`;
                }
                
                // Format visibility
                let visHtml = '';
                if (apt.visibility_text) {
                    let visClass = apt.visibility < 3 ? 'low' : '';
                    visHtml = `<span class="vis-info ${visClass}">&#x1F441; ${apt.visibility_text}</span>`;
                }
                
                // Build badges HTML
                let badgesHtml = '<div class="badges">';
                
                // Traffic program badges (highest priority)
                if (apt.traffic_programs) {
                    for (const prog of apt.traffic_programs) {
                        if (prog.type === 'GROUND STOP') {
                            badgesHtml += `<span class="badge badge-gs" title="${prog.reason}">GS</span>`;
                        } else if (prog.type === 'GDP') {
                            badgesHtml += `<span class="badge badge-gdp" title="${prog.reason}">GDP</span>`;
                        } else if (prog.type === 'DEICING') {
                            badgesHtml += `<span class="badge badge-deicing" title="${prog.reason}"> DEICING</span>`;
                        } else if (prog.type === 'ARR DELAY') {
                            badgesHtml += `<span class="badge badge-delay" title="${prog.reason}">ARR DLY</span>`;
                        } else if (prog.type === 'DEP DELAY') {
                            badgesHtml += `<span class="badge badge-delay" title="${prog.reason}">DEP DLY</span>`;
                        } else if (prog.type !== 'CLOSED') {
                            // Skip CLOSED, show any other type
                            badgesHtml += `<span class="badge badge-delay" title="${prog.reason}">${prog.type}</span>`;
                        }
                    }
                }
                
                // Runway/taxiway closure badge
                const closures = faaAdvisoryData.runwayClosures[apt.icao];
                if (closures && closures.length > 0) {
                    badgesHtml += `<span class="badge badge-closure" title="${closures.join(', ')}">&#x1F6A7; RWY WORK</span>`;
                }
                
                // Planned ground stop badge
                const planned = faaAdvisoryData.terminalPlanned[apt.icao];
                if (planned && planned.length > 0) {
                    badgesHtml += `<span class="badge badge-planned" title="${planned.join(', ')}"> GS POSS</span>`;
                }
                
                // Rush hour badge
                if (apt.rush_status) {
                    badgesHtml += `<span class="badge badge-rush">${apt.rush_status}</span>`;
                }
                
                // Frost risk badge (night + cold)
                if (apt.frost_risk) {
                    badgesHtml += `<span class="badge badge-frost">&#x1F319; FROST RISK</span>`;
                }
                
                // Dewpoint spread badge - fog/icing risk when spread is small
                if (apt.dewpoint_spread !== null && apt.temp_c !== null && apt.temp_c <= 5) {
                    if (apt.dewpoint_spread <= 2) {
                        badgesHtml += `<span class="badge" style="background:#8e44ad;color:white;" title="Temp/Dewpoint spread: ${apt.dewpoint_spread}&deg;C - High fog/ice risk"> DEW ${apt.dewpoint_spread}&deg;</span>`;
                    } else if (apt.dewpoint_spread <= 4) {
                        badgesHtml += `<span class="badge" style="background:#5d6d7e;color:white;" title="Temp/Dewpoint spread: ${apt.dewpoint_spread}&deg;C - Moisture"> DEW ${apt.dewpoint_spread}&deg;</span>`;
                    }
                }
                
                // TAF frozen precip forecast badge with timing
                if (apt.taf && apt.taf.frozenForecasts && apt.taf.frozenForecasts.length > 0) {
                    const fc = apt.taf.frozenForecasts[0];
                    const summary = apt.taf.summary || '';
                    badgesHtml += `<span class="badge badge-taf-sn" title="${fc.raw}\n${summary}">TAF: ${fc.wx}</span>`;
                }
                
                // Hub badge
                if (apt.hub_airlines) {
                    const hubText = apt.hub_airlines.length > 2 
                        ? apt.hub_airlines.slice(0, 2).join('/') + '+' 
                        : apt.hub_airlines.join('/');
                    badgesHtml += `<span class="badge badge-hub" title="${apt.hub_airlines.join(', ')} hub">HUB: ${hubText}</span>`;
                }
                
                badgesHtml += '</div>';
                
                // Recent frozen precip indicator
                let recentFrozenHtml = '';
                if (apt.had_recent_frozen && !apt.frozen_precip) {
                    const frozenAgo = apt.last_frozen_time ? getTimeSince(apt.last_frozen_time).text : 'recently';
                    recentFrozenHtml = `<div class="recent-frozen-note"> ${apt.recent_frozen_types.join(', ')} ended ${frozenAgo}</div>`;
                }
                
                // TAF forecast indicator - expandable
                let tafHtml = '';
                if (apt.taf && apt.taf.raw) {
                    const hasFrozen = apt.taf.frozenForecasts && apt.taf.frozenForecasts.length > 0;
                    const wxSummary = hasFrozen ? apt.taf.frozenForecasts[0].wx : 'Available';
                    const tafCardId = `taf-card-${apt.icao}`;
                    tafHtml = `
                        <div class="taf-forecast" style="cursor:pointer;" onclick="toggleTafInline(document.getElementById('${tafCardId}')); event.stopPropagation();">
                            &#x1F4CB; TAF: <span style="color:${hasFrozen ? '#9b59b6' : '#4a90d9'};">${wxSummary}</span>
                            <span style="color:#666;font-size:9px;margin-left:4px;">&#x25BC; expand</span>
                        </div>
                        <div class="taf-inline" id="${tafCardId}" onclick="toggleTafInline(this); event.stopPropagation();">${apt.taf.raw}</div>
                    `;
                }
                
                // HOT estimate with fluid types
                let hotHtml = '';
                if (apt.hot_estimate) {
                    const hot = apt.hot_estimate;
                    const statusColors = {
                        ok: '#1abc9c',
                        caution: '#f39c12',
                        short: '#e67e22',
                        critical: '#e74c3c'
                    };
                    const statusColor = statusColors[hot.status] || '#888';
                    const statusBg = hot.status === 'critical' ? '#3d1a1a' : 
                                    hot.status === 'short' ? '#3d2a1a' : 
                                    hot.status === 'caution' ? '#3d3d1a' : '#1a3d2d';
                    
                    hotHtml = `
                        <div class="hot-estimate" style="background:${statusBg};color:${statusColor};">
                            <span style="font-weight:bold;"> HOT:</span> 
                            <span title="Type I fluid">I: ${hot.typeI.min}-${hot.typeI.max}m</span> | 
                            <span title="Type IV fluid" style="color:#9b59b6;">IV: ${hot.typeIV.min}-${hot.typeIV.max}m</span>
                            <span style="opacity:0.8;font-size:9px;margin-left:4px;">(${hot.intensity} ${hot.precipName})</span>
                        </div>`;
                }
                
                // Runway status
                let runwayHtml = '';
                if (apt.runway_status) {
                    const rwy = apt.runway_status;
                    if (rwy.status !== 'good' || rwy.brakingAction) {
                        let brakingHtml = '';
                        if (rwy.brakingAction) {
                            const brakingClass = rwy.brakingAction === 'GOOD' ? 'braking-good' : 
                                                rwy.brakingAction === 'MEDIUM' || rwy.brakingAction === 'FAIR' ? 'braking-fair' :
                                                rwy.brakingAction === 'POOR' ? 'braking-poor' : 'braking-nil';
                            brakingHtml = `<span class="braking-action ${brakingClass}">BRAKING: ${rwy.brakingAction}</span>`;
                        }
                        
                        let statusText = rwy.message || `${rwy.available}/${rwy.total} rwys`;
                        runwayHtml = `<div class="runway-status ${rwy.status}">&#x1F6EC; ${statusText} ${brakingHtml}</div>`;
                    }
                }
                
                let historyHtml = '';
                if (apt.history && apt.history.length > 0) {
                    historyHtml = `<div class="history" id="${historyId}"><div class="history-title">Last ${apt.history.length} observations</div>`;
                    historyHtml += `<div class="history-header"><span class="time">Time (Z/Local)</span><span class="ceiling">Ceil</span><span class="wx">Weather</span><span class="wind">Wind</span><span class="temp">Temp</span></div>`;
                    for (const h of apt.history) {
                        const hTimeData = formatObsTime(h.obs_time);
                        const hTime = hTimeData.combined;
                        const hCeiling = h.ceiling_text || '&mdash;';
                        const hWx = formatHistoryWeather(h);
                        const hWind = h.wind_speed !== null ? 
                            (h.wind_variable ? `VRB${h.wind_speed}` : `${h.wind_speed}kt`) + (h.wind_gust ? `G${h.wind_gust}` : '') : '&mdash;';
                        const hTemp = h.temp_c !== null ? `${tempToF(h.temp_c)}&deg;F/${h.temp_c}&deg;C` : 'N/A';
                        // Highlight rows with frozen precip (handle intensity prefixes like -SN, +SN)
                        const hasFrozen = h.weather.some(w => {
                            const stripped = w.replace(/^[-+]/, '');
                            return FROZEN_PRECIP.some(code => stripped === code || stripped.includes(code));
                        });
                        const rowStyle = hasFrozen ? 'background: #3d2850;' : '';
                        historyHtml += `<div class="history-row" style="${rowStyle}"><span class="time">${hTime}</span><span class="ceiling">${hCeiling}</span><span class="wx">${hWx}</span><span class="wind">${hWind}</span><span class="temp">${hTemp}</span></div>`;
                    }
                    historyHtml += '</div>';
                }
                
                html += `
                    <div class="airport-card" onclick="toggleHistory('${historyId}')">
                        <div class="airport-main">
                            <div class="left">
                                <div class="icao">#${rank} ${apt.icao}</div>
                                <div>
                                    <div class="name">
                                        <a href="${metarUrl}" target="_blank" onclick="event.stopPropagation();" title="View METARs">${name} </a>
                                        <a href="${notamUrl}" target="_blank" onclick="event.stopPropagation();" class="notam-link" title="FAA NOTAM Search"></a>
                                        <button class="runway-map-btn" onclick="showRunwayMap('${apt.icao}', event)" title="View Runway Map">&#x1F6EB; Map</button>
                                    </div>
                                    <div class="weather">${wx} <span class="flight-rules ${frClass}">${apt.flight_rules}</span> ${windHtml} ${visHtml}</div>
                                    <div class="obs-time ${timeSince.stale ? 'stale' : ''}">${timeSince.zulu} &bull; ${timeSince.text}</div>
                                    ${recentFrozenHtml}
                                    ${tafHtml}
                                    ${hotHtml}
                                    ${runwayHtml}
                                    ${badgesHtml}
                                </div>
                            </div>
                            <div class="right">
                                <div class="trend ${apt.trend.class}" title="${apt.trend.text}">${apt.trend.symbol}</div>
                                <div class="temp">
                                    <div class="temp-value">${tempToF(apt.temp_c)}&deg;F</div>
                                    <div class="temp-f">${apt.temp_c}&deg;C</div>
                                </div>
                            </div>
                        </div>
                        <div class="expand-hint">Tap to see history</div>
                        ${historyHtml}
                    </div>
                `;
            }

            html += '</div></div></div>';
            return html;
        }

        function setAutoRefresh() {
            const mins = parseInt(document.getElementById('autoRefresh').value);
            if (refreshInterval) clearInterval(refreshInterval);
            if (mins > 0) {
                refreshInterval = setInterval(fetchData, mins * 60 * 1000);
            }
        }

        // Start
        console.log('=== Airport Weather & ATC Monitor v2.3 ===');
        (async function init() {
            console.log('=== INIT STARTING ===');
            console.log('Calling loadRunwayData...');
            await loadRunwayData(); // Load worldwide runway data first
            console.log('loadRunwayData complete, RUNWAY_DATA has', Object.keys(RUNWAY_DATA).length, 'entries');
            // Update subtitle based on excluded airports
            updateSubtitle();
            console.log('Calling fetchData...');
            fetchData();
        })();
        setAutoRefresh();
        
        // Timezone detection and display
        function detectUserTimezone() {
            const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
            
            // Map timezone to friendly name
            const tzNames = {
                'America/New_York': 'Eastern',
                'America/Detroit': 'Eastern',
                'America/Indiana/Indianapolis': 'Eastern',
                'America/Kentucky/Louisville': 'Eastern',
                'America/Chicago': 'Central',
                'America/Menominee': 'Central',
                'America/Denver': 'Mountain',
                'America/Phoenix': 'Arizona',
                'America/Boise': 'Mountain',
                'America/Los_Angeles': 'Pacific',
                'America/Anchorage': 'Alaska',
                'Pacific/Honolulu': 'Hawaii',
                'America/Toronto': 'Eastern',
                'America/Vancouver': 'Pacific',
                'America/Edmonton': 'Mountain',
                'America/Winnipeg': 'Central',
                'America/Halifax': 'Atlantic',
                'America/St_Johns': 'Newfoundland',
                'America/Montreal': 'Eastern',
            };
            
            let name = tzNames[tz];
            if (!name) {
                // Try to extract from timezone string
                const parts = tz.split('/');
                name = parts[parts.length - 1].replace(/_/g, ' ');
            }
            
            return { timezone: tz, name: name };
        }
        
        const userTz = detectUserTimezone();
        
        function updateTimezones() {
            const now = new Date();
            
            const formatTime = (tz, includeZ = false) => {
                try {
                    const time = now.toLocaleTimeString('en-US', { 
                        timeZone: tz, 
                        hour: '2-digit', 
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: false 
                    });
                    return includeZ ? time + 'Z' : time;
                } catch (e) {
                    return '--:--:--';
                }
            };
            
            const formatDate = (tz) => {
                try {
                    const date = now.toLocaleDateString('en-US', { 
                        timeZone: tz, 
                        weekday: 'short',
                        month: 'short',
                        day: 'numeric'
                    });
                    return date;
                } catch (e) {
                    return '---';
                }
            };
            
            // Zulu/UTC
            const zuluEl = document.getElementById('tz-zulu');
            const zuluDateEl = document.getElementById('tz-zulu-date');
            if (zuluEl) zuluEl.textContent = formatTime('UTC', true);
            if (zuluDateEl) zuluDateEl.textContent = formatDate('UTC');
            
            // Local timezone (user's detected timezone)
            const localEl = document.getElementById('tz-local');
            const localDateEl = document.getElementById('tz-local-date');
            const localLabel = document.getElementById('tz-local-label');
            if (localEl) localEl.textContent = formatTime(userTz.timezone);
            if (localDateEl) localDateEl.textContent = formatDate(userTz.timezone);
            if (localLabel) localLabel.textContent = userTz.name;
            
            // Expanded timezones (for toggle)
            const eastEl = document.getElementById('tz-eastern');
            const eastDateEl = document.getElementById('tz-eastern-date');
            if (eastEl) eastEl.textContent = formatTime('America/New_York');
            if (eastDateEl) eastDateEl.textContent = formatDate('America/New_York');
            
            const centEl = document.getElementById('tz-central');
            const centDateEl = document.getElementById('tz-central-date');
            if (centEl) centEl.textContent = formatTime('America/Chicago');
            if (centDateEl) centDateEl.textContent = formatDate('America/Chicago');
            
            const mtEl = document.getElementById('tz-mountain');
            const mtDateEl = document.getElementById('tz-mountain-date');
            if (mtEl) mtEl.textContent = formatTime('America/Denver');
            if (mtDateEl) mtDateEl.textContent = formatDate('America/Denver');
            
            const pacEl = document.getElementById('tz-pacific');
            const pacDateEl = document.getElementById('tz-pacific-date');
            if (pacEl) pacEl.textContent = formatTime('America/Los_Angeles');
            if (pacDateEl) pacDateEl.textContent = formatDate('America/Los_Angeles');
        }
        
        function toggleAllTimezones() {
            const expanded = document.getElementById('timezoneBoxExpanded');
            const toggle = document.getElementById('tzToggle');
            
            if (expanded.style.display === 'none') {
                expanded.style.display = 'flex';
                toggle.classList.add('expanded');
                toggle.textContent = '+';
            } else {
                expanded.style.display = 'none';
                toggle.classList.remove('expanded');
                toggle.textContent = '+';
            }
        }
        
        updateTimezones();
        setInterval(updateTimezones, 1000);
    </script>
</body>
</html>
